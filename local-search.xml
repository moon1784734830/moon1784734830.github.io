<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表系列之递归</title>
    <link href="/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="递归的本质"><a href="#递归的本质" class="headerlink" title="递归的本质"></a>递归的本质</h2><p>递归是一种将大问题分解为相同结构小问题的编程技巧</p><p>在链表中，递归特别适用，因为链表本身就是递归定义的：</p><ul><li>链表 &#x3D; 头节点 + 剩余链表</li><li>剩余链表 &#x3D; 头节点 + 剩余链表</li><li>…直到空节点</li></ul><p>递归解决链表问题的核心三要素：</p><ol><li><strong>递归终止条件</strong>：什么时候停止递归</li><li><strong>递归逻辑</strong>：如何处理当前节点</li><li><strong>返回值</strong>：向上一层返回什么</li></ol><hr><h2 id="入门篇：反转链表"><a href="#入门篇：反转链表" class="headerlink" title="入门篇：反转链表"></a>入门篇：反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，反转整个链表并返回新的头节点</p><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>假设链表为：1 → 2 → 3 → 4 → 5</p><p>递归的思考方式：</p><ol><li>先递归反转 2 → 3 → 4 → 5，得到 5 → 4 → 3 → 2</li><li>然后处理节点1，让2的next指向1</li><li>将1的next设为NULL</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">newHead</span> =</span> reverseList(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解"><a href="#递归过程图解" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs isbl">原链表：<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-variable"><span class="hljs-literal">NULL</span></span><br><br>递归栈：<br>第<span class="hljs-number">1</span>层：<span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-number">1</span>) </span><br><span class="hljs-function">第<span class="hljs-number">2</span>层：  <span class="hljs-title">reverseList</span>(<span class="hljs-number">2</span>)</span><br>第<span class="hljs-number">3</span>层：    <span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-number">3</span>)</span><br>第<span class="hljs-number">4</span>层：      <span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>) → 返回<span class="hljs-number">3</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">回溯过程：</span><br><span class="hljs-function">第<span class="hljs-number">3</span>层：<span class="hljs-number">3</span>已反转，处理<span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-number">2</span>，<span class="hljs-number">2</span>.next = <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br><span class="hljs-function">       返回<span class="hljs-number">3</span></span><br><span class="hljs-function">第<span class="hljs-number">2</span>层：<span class="hljs-number">3</span> → <span class="hljs-number">2</span>已反转，处理<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span>，<span class="hljs-number">1</span>.next = <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br><span class="hljs-function">       返回<span class="hljs-number">3</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">最终：<span class="hljs-number">3</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span> → <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br></code></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：head为空或head-&gt;next为空</li><li>核心操作：<code>head-&gt;next-&gt;next = head</code>（让下一个节点指向当前节点）</li><li>断开原连接：<code>head-&gt;next = NULL</code>（避免成环）</li><li>返回值：新的头节点（始终是原链表的尾节点）</li></ul><hr><h2 id="进阶篇一：合并两个有序链表"><a href="#进阶篇一：合并两个有序链表" class="headerlink" title="进阶篇一：合并两个有序链表"></a>进阶篇一：合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>将两个升序链表合并为一个新的升序链表</p><h3 id="递归思路-1"><a href="#递归思路-1" class="headerlink" title="递归思路"></a>递归思路</h3><p>每次选择两个链表中较小的头节点，然后递归处理剩余部分</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* list1, <span class="hljs-keyword">struct</span> ListNode* list2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>    <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br>    <br>    <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程示例"><a href="#递归过程示例" class="headerlink" title="递归过程示例"></a>递归过程示例</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">list1:<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 3 </span>→ 5<br>list2:<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 4 </span>→ 6<br><br>第1层：比较1和2，选1，递归merge(3→5, 2→4→6)<br>第2层：比较3和2，选2，递归merge(3→5, 4→6)<br>第3层：比较3和4，选3，递归merge(5, 4→6)<br>第4层：比较5和4，选4，递归merge(5, 6)<br>第5层：比较5和6，选5，递归merge(NULL, 6)<br>第6层：返回6<br><br>回溯构建：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→<span class="hljs-number"> 4 </span>→<span class="hljs-number"> 5 </span>→ 6<br></code></pre></td></tr></table></figure><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：任一链表为空，返回另一个链表</li><li>递归逻辑：选择较小的节点，将其next指向递归结果</li><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)（递归栈深度）</li></ul><hr><h2 id="进阶篇二：两两交换链表节点"><a href="#进阶篇二：两两交换链表节点" class="headerlink" title="进阶篇二：两两交换链表节点"></a>进阶篇二：两两交换链表节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LeetCode 24. 两两交换链表中的节点</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，两两交换其中相邻的节点</p><p>例如：1 → 2 → 3 → 4 变为 2 → 1 → 4 → 3</p><h3 id="递归思路-2"><a href="#递归思路-2" class="headerlink" title="递归思路"></a>递归思路</h3><ol><li>递归处理后续节点（从第3个节点开始）</li><li>交换当前的两个节点</li><li>返回新的头节点</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(!head || !head-&gt;next)<br>        <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span> =</span> head-&gt;next;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span> =</span> next-&gt;next;<br>    <br>    next-&gt;next = cur;<br>    cur-&gt;next = swapPairs(tmp);<br>    <br>    <span class="hljs-keyword">return</span> next;  <span class="hljs-comment">// 新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解-1"><a href="#递归过程图解-1" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">原链表：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→ 4<br><br>第1层：处理1和2<br>       递归处理3 → 4<br>第2层：处理3和4<br>       递归处理NULL<br>       返回4<br>       <br>回溯：<br>第2层：交换3和4，返回<span class="hljs-number"> 4 </span>→ 3<br>第1层：交换1和2，连接返回结果<br>      <span class="hljs-number"> 2 </span>→<span class="hljs-number"> 1 </span>→ (4 → 3)<br>       返回2<br><br>最终：2 →<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 4 </span>→ 3<br></code></pre></td></tr></table></figure><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：节点为空或只剩一个节点</li><li>保存三个关键指针：cur、next、tmp</li><li>返回值：交换后的新头节点（原来的第二个节点）</li></ul><hr><h2 id="高级篇一：K个一组翻转链表"><a href="#高级篇一：K个一组翻转链表" class="headerlink" title="高级篇一：K个一组翻转链表"></a>高级篇一：K个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，每k个节点一组进行翻转</p><p>例如：1 → 2 → 3 → 4 → 5，k&#x3D;2<br>结果：2 → 1 → 4 → 3 → 5</p><h3 id="递归思路-3"><a href="#递归思路-3" class="headerlink" title="递归思路"></a>递归思路</h3><ol><li>检查是否有k个节点</li><li>如果有，翻转前k个节点</li><li>递归处理剩余部分</li><li>连接翻转后的部分和递归结果</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 检查是否有k个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span> =</span> head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// 不足k个，直接返回head</span><br>        p = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 翻转前k个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">q</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">pre</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q != p) &#123;  <span class="hljs-comment">// 翻转从head到p的前k个节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tmp</span> =</span> q-&gt;next;<br>        q-&gt;next = pre;<br>        pre = q;<br>        q = tmp;<br>    &#125;<br><br>    head-&gt;next = reverseKGroup(p, k);<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程示例-1"><a href="#递归过程示例-1" class="headerlink" title="递归过程示例"></a>递归过程示例</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">原链表：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→<span class="hljs-number"> 4 </span>→ 5，k=2<br><br>第1层：检查1,2存在<br>       翻转1,2 得到<span class="hljs-number"> 2 </span>→ 1<br>       递归处理3 →<span class="hljs-number"> 4 </span>→ 5<br>       <br>第2层：检查3,4存在<br>       翻转3,4 得到<span class="hljs-number"> 4 </span>→ 3<br>       递归处理5<br>       <br>第3层：检查5后不足2个<br>       直接返回5<br><br>回溯连接：<br>第2层：4 →<span class="hljs-number"> 3 </span>→ 5，返回4<br>第1层：2 →<span class="hljs-number"> 1 </span>→ (4 →<span class="hljs-number"> 3 </span>→ 5)，返回2<br><br>最终：2 →<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 4 </span>→<span class="hljs-number"> 3 </span>→ 5<br></code></pre></td></tr></table></figure><h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul><li>先检查是否有足够的节点</li><li>翻转逻辑与普通反转链表相同</li><li>递归处理剩余部分</li><li>head变成了翻转后这组的尾节点</li></ul><hr><h2 id="高级篇二：排序链表（归并排序）"><a href="#高级篇二：排序链表（归并排序）" class="headerlink" title="高级篇二：排序链表（归并排序）"></a>高级篇二：排序链表（归并排序）</h2><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148. 排序链表</a></p><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>对链表进行排序，要求时间复杂度O(n log n)</p><h3 id="递归思路（分治法）"><a href="#递归思路（分治法）" class="headerlink" title="递归思路（分治法）"></a>递归思路（分治法）</h3><p>归并排序的经典应用：</p><ol><li>找到链表中点（快慢指针）</li><li>递归排序左半部分</li><li>递归排序右半部分</li><li>合并两个有序链表</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 找到链表中间节点</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span> =</span> head-&gt;next;<br>    <br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span> =</span> &amp;dummy;<br>    dummy.next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>            tail-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        tail = tail-&gt;next;<br>    &#125;<br>    <br>    tail-&gt;next = l1 ? l1 : l2;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">// 递归归并排序主函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">sortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：空链表或单节点</span><br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 找到中间节点并分割</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">mid</span> =</span> findMiddle(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">right</span> =</span> mid-&gt;next;<br>    mid-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 切断链表</span><br>    <br>    <span class="hljs-comment">// 2. 递归排序左右两部分</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">leftSorted</span> =</span> sortList(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rightSorted</span> =</span> sortList(right);<br>    <br>    <span class="hljs-comment">// 3. 合并有序链表</span><br>    <span class="hljs-keyword">return</span> merge(leftSorted, rightSorted);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解-2"><a href="#递归过程图解-2" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">原链表：<span class="hljs-number">4</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span> → <span class="hljs-number">3</span><br><br>分割阶段：<br>层<span class="hljs-number">1</span>：<span class="hljs-selector-attr">[4,2,1,3]</span> → <span class="hljs-selector-attr">[4,2]</span> 和 <span class="hljs-selector-attr">[1,3]</span><br>层<span class="hljs-number">2</span>：<span class="hljs-selector-attr">[4,2]</span> → <span class="hljs-selector-attr">[4]</span> 和 <span class="hljs-selector-attr">[2]</span><br>     <span class="hljs-selector-attr">[1,3]</span> → <span class="hljs-selector-attr">[1]</span> 和 <span class="hljs-selector-attr">[3]</span><br><br>合并阶段：<br>层<span class="hljs-number">2</span>：<span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[4]</span>, <span class="hljs-selector-attr">[2]</span>) → <span class="hljs-selector-attr">[2,4]</span><br>     <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[1]</span>, <span class="hljs-selector-attr">[3]</span>) → <span class="hljs-selector-attr">[1,3]</span><br>层<span class="hljs-number">1</span>：<span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[2,4]</span>, <span class="hljs-selector-attr">[1,3]</span>) → <span class="hljs-selector-attr">[1,2,3,4]</span><br><br>最终：<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul><li>分治思想：分割、递归、合并</li><li>快慢指针找中点</li><li>切断链表很重要（mid-&gt;next &#x3D; NULL）</li><li>时间复杂度：O(n log n)</li><li>空间复杂度：O(log n)（递归栈）</li></ul><hr><h2 id="高级篇三：复制带随机指针的链表"><a href="#高级篇三：复制带随机指针的链表" class="headerlink" title="高级篇三：复制带随机指针的链表"></a>高级篇三：复制带随机指针的链表</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">LeetCode 138. 随机链表的复制</a></p><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>复制一个特殊的链表，每个节点除了next指针，还有一个random指针指向链表中的任意节点或null</p><h3 id="递归思路-4"><a href="#递归思路-4" class="headerlink" title="递归思路"></a>递归思路</h3><p>使用哈希表缓存已复制的节点，递归复制next和random</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">key</span>, *<span class="hljs-title">val</span>;</span><br>    UT_hash_handle hh;<br>&#125; * cachedNode;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_PTR(cachedNode, &amp;head, tmp);<br>    <br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 创建新节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">headNew</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        headNew-&gt;val = head-&gt;val;<br>        <br>        <span class="hljs-comment">// 加入哈希表</span><br>        tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HashTable));<br>        tmp-&gt;key = head;<br>        tmp-&gt;val = headNew;<br>        HASH_ADD_PTR(cachedNode, key, tmp);<br>        <br>        <span class="hljs-comment">// 递归复制next和random</span><br>        headNew-&gt;next = deepCopy(head-&gt;next);<br>        headNew-&gt;random = deepCopy(head-&gt;random);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> tmp-&gt;val;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span> &#123;<br>    cachedNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> deepCopy(head);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><ul><li>使用哈希表避免重复复制同一个节点</li><li>先复制当前节点，再递归复制next和random</li><li>哈希表的key是原节点，value是新节点</li><li>递归可能会形成环，哈希表防止无限递归</li></ul><hr><h2 id="递归核心总结"><a href="#递归核心总结" class="headerlink" title="递归核心总结"></a>递归核心总结</h2><h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">ReturnType <span class="hljs-title function_">recursive</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-comment">// 1. 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        <span class="hljs-keyword">return</span> 终止值;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 递归调用</span><br>    ReturnType result = recursive(下一个节点);<br>    <br>    <span class="hljs-comment">// 3. 处理当前节点</span><br>    处理当前节点与递归结果;<br>    <br>    <span class="hljs-comment">// 4. 返回结果</span><br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见递归模式"><a href="#常见递归模式" class="headerlink" title="常见递归模式"></a>常见递归模式</h3><p><strong>模式一：自底向上</strong><br>先递归到底，回溯时处理<br>例如：反转链表</p><p><strong>模式二：自顶向下</strong><br>先处理当前节点，再递归<br>例如：复制链表</p><p><strong>模式三：分治合并</strong><br>分割问题，递归处理，合并结果<br>例如：归并排序</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归是解决链表问题的强大工具</p><p>掌握递归的关键：</p><ul><li>明确递归三要素：终止条件、递归逻辑、返回值</li><li>理解递归的本质：将大问题分解为小问题</li><li>学会画递归树，理解回溯过程</li><li>权衡递归与迭代的优劣</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表系列之快慢指针</title>
    <link href="/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="快慢指针核心"><a href="#快慢指针核心" class="headerlink" title="快慢指针核心"></a>快慢指针核心</h2><p>快慢指针是链表问题中最经典的算法技巧之一</p><p>核心思想是使用两个指针同时遍历链表，但移动速度不同：</p><ul><li>快指针每次移动2步</li><li>慢指针每次移动1步</li></ul><p>这个简单的速度差异，能够解决环检测、找中点、定位特定位置等一系列问题</p><hr><h2 id="应用场景一：检测链表是否有环"><a href="#应用场景一：检测链表是否有环" class="headerlink" title="应用场景一：检测链表是否有环"></a>应用场景一：检测链表是否有环</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141. 环形链表</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，判断链表中是否有环</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>如果链表有环，快慢指针最终一定会相遇</p><p>就像在操场跑步，速度快的人一定会追上速度慢的人</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head-&gt;next;<br><br>    <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针走两步前要判断 <code>fast-&gt;next</code> 是否为空</li><li>快慢指针初始位置可以不同（一个在head，一个在head-&gt;next）</li><li>循环条件是 <code>slow != fast</code></li></ul><hr><h2 id="应用场景二：找到环的入口节点"><a href="#应用场景二：找到环的入口节点" class="headerlink" title="应用场景二：找到环的入口节点"></a>应用场景二：找到环的入口节点</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>如果链表有环，找到环的起始节点</p><h3 id="核心思路（Floyd判圈算法）"><a href="#核心思路（Floyd判圈算法）" class="headerlink" title="核心思路（Floyd判圈算法）"></a>核心思路（Floyd判圈算法）</h3><p>这是快慢指针最精妙的应用，分为两个阶段：</p><p><strong>第一阶段：判断是否有环</strong></p><ul><li>快慢指针同时从head出发</li><li>快指针每次2步，慢指针每次1步</li><li>如果相遇，说明有环</li></ul><p><strong>第二阶段：寻找环起点</strong></p><ul><li>将一个指针放回链表头</li><li>两个指针都改为每次走1步</li><li>再次相遇的点就是环起点</li></ul><h3 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h3><p>设链表头到环入口距离为 <code>a</code>，环入口到相遇点距离为 <code>b</code>，相遇点到环入口距离为 <code>c</code></p><p>相遇时：</p><ul><li>慢指针走了：<code>a + b</code></li><li>快指针走了：<code>a + b + c + b</code> &#x3D; <code>a + 2b + c</code></li></ul><p>因为快指针速度是慢指针2倍，所以：</p><ul><li><code>2(a + b) = a + 2b + c</code></li><li>化简得：<code>a = c</code></li></ul><p>这就是为什么从头节点和相遇点同时出发，会在环入口相遇</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">detectCycle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 关键：slow和fast都从head开始</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br>    <br>    <span class="hljs-comment">// 第一阶段：判断是否有环</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-comment">// 第二阶段：寻找环起点</span><br>            fast = head;<br>            <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;  <span class="hljs-comment">// 环起点</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 无环</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul><li>第一阶段slow和fast必须从同一位置出发</li><li>相遇后将其中一个指针移回head</li><li>第二阶段两个指针都是每次走1步</li></ul><hr><h2 id="应用场景三：删除倒数第N个节点"><a href="#应用场景三：删除倒数第N个节点" class="headerlink" title="应用场景三：删除倒数第N个节点"></a>应用场景三：删除倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个结点</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，删除倒数第N个节点</p><h3 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h3><p>让快指针先走N步，然后快慢指针同时前进</p><p>当快指针到达末尾时，慢指针正好在倒数第N个节点的前一个位置</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">curr</span> =</span> &amp;dummy;<br>    dummy.next = head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span>=</span>curr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">low</span>=</span>curr;<br>    <br>    <span class="hljs-comment">// 快指针先走n步</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 快慢指针同时前进</span><br>    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        low=low-&gt;next;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span>=</span>low-&gt;next;<br>    low-&gt;next=low-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(tmp);<br>    <br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul><li>使用虚拟头节点，避免处理删除头节点的边界情况</li><li>快指针要先走N步</li><li>慢指针停在待删除节点的前一个位置</li></ul><hr><h2 id="应用场景四：判断回文链表"><a href="#应用场景四：判断回文链表" class="headerlink" title="应用场景四：判断回文链表"></a>应用场景四：判断回文链表</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234. 回文链表</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断一个链表是否为回文结构</p><h3 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h3><ol><li>用快慢指针找到链表中点</li><li>反转后半部分链表</li><li>比较前后两部分是否相同</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 反转链表辅助函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span>;</span><br>    <br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        next=cur-&gt;next;<br>        cur-&gt;next=prev;<br>        prev=cur;<br>        cur=next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">low</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head_behind</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head_ahead</span>;</span><br>    <br>    <span class="hljs-comment">// 快慢指针找中点</span><br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        low=low-&gt;next;<br>        fast=fast-&gt;next-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据链表奇偶判断后半段起点</span><br>    <span class="hljs-keyword">if</span>(fast)&#123;<br>        tmp=low-&gt;next;  <span class="hljs-comment">// 奇数个节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tmp=low;  <span class="hljs-comment">// 偶数个节点</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 反转后半部分</span><br>    head_behind=reverseList(tmp);<br>    head_ahead=head;<br><br>    <span class="hljs-comment">// 比较两部分</span><br>    <span class="hljs-keyword">while</span>(head_behind)&#123;<br>        <span class="hljs-keyword">if</span>(head_behind-&gt;val==head_ahead-&gt;val)&#123;<br>            head_ahead=head_ahead-&gt;next;<br>            head_behind=head_behind-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针走到末尾时，慢指针在中点</li><li>要区分链表节点个数的奇偶性</li><li>空间复杂度O(1)，优于使用栈的方案</li></ul><hr><h2 id="应用场景五：链表排序中找中点"><a href="#应用场景五：链表排序中找中点" class="headerlink" title="应用场景五：链表排序中找中点"></a>应用场景五：链表排序中找中点</h2><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148. 排序链表</a></p><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>对链表进行排序，要求时间复杂度O(n log n)</p><h3 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h3><p>使用归并排序：</p><ol><li>用快慢指针找中点，分割链表</li><li>递归排序左右两部分</li><li>合并两个有序链表</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 找到链表中间节点</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span> =</span> head-&gt;next;  <span class="hljs-comment">// fast从head-&gt;next开始</span><br>    <br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span> =</span> &amp;dummy;<br>    dummy.next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>            tail-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        tail = tail-&gt;next;<br>    &#125;<br>    <br>    tail-&gt;next = l1 ? l1 : l2;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">// 递归归并排序主函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">sortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 找到中间节点并分割</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">mid</span> =</span> findMiddle(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">right</span> =</span> mid-&gt;next;<br>    mid-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 切断链表</span><br>    <br>    <span class="hljs-comment">// 2. 递归排序左右两部分</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">leftSorted</span> =</span> sortList(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rightSorted</span> =</span> sortList(right);<br>    <br>    <span class="hljs-comment">// 3. 合并有序链表</span><br>    <span class="hljs-keyword">return</span> merge(leftSorted, rightSorted);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针从<code>head-&gt;next</code>开始，确保分割点在左半部分</li><li>分割后要将左半部分的尾节点指向NULL</li><li>归并排序是链表排序的最优解</li></ul><hr><h2 id="快慢指针核心总结"><a href="#快慢指针核心总结" class="headerlink" title="快慢指针核心总结"></a>快慢指针核心总结</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br><br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>    slow = slow-&gt;next;<br>    fast = fast-&gt;next-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>空指针判断</strong>：快指针移动前要判断<code>fast</code>和<code>fast-&gt;next</code></li><li><strong>初始位置</strong>：根据具体问题选择是否从同一位置开始</li><li><strong>奇偶处理</strong>：找中点时要注意链表长度奇偶的影响</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快慢指针是链表算法中最优雅的技巧之一</p><p>它用简单的速度差异，解决了环检测、找中点、定位等多个经典问题</p>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存算法</title>
    <link href="/2026/01/05/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/"/>
    <url>/2026/01/05/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>LRU（最近最少使用算法），是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据，以腾出空间给新的数据</p><h2 id="LRU缓存算法原理"><a href="#LRU缓存算法原理" class="headerlink" title="LRU缓存算法原理"></a>LRU缓存算法原理</h2><p>下面会重点介绍核心的数据结构和操作原理</p><h3 id="核心数据结构：双向链表-哈希表"><a href="#核心数据结构：双向链表-哈希表" class="headerlink" title="核心数据结构：双向链表 + 哈希表"></a>核心数据结构：双向链表 + 哈希表</h3><p>LRU缓存算法的核心思想是维护一个有序的数据结构，记录数据的使用顺序。当数据被访问时，将其移动到数据结构的头部，表示它是最近使用的数据。当缓存达到容量限制时，淘汰数据结构尾部的数据，即最少使用的数据</p><h3 id="核心操作原理"><a href="#核心操作原理" class="headerlink" title="核心操作原理"></a>核心操作原理</h3><p><strong>1. 读取数据 (Get)</strong>  </p><ul><li><strong>查找</strong>：在哈希表中查找该 key。  </li><li><strong>命中</strong>：如果找到，根据哈希表记录的指针直接访问链表节点，获取 value。  </li><li><strong>更新状态</strong>：因为该节点被访问了，它变成了“最新”的，所以将其从链表当前位置删除，并重新插入到链表尾部。  </li><li><strong>未命中</strong>：返回 -1。</li></ul><p><strong>2. 写入&#x2F;更新数据 (Put)</strong><br><strong>节点已存在：</strong>  </p><ul><li>修改该节点的 value。  </li><li>将该节点移到链表尾部（更新时序）。</li></ul><p><strong>节点不存在：</strong>  </p><ul><li><strong>检查容量</strong>：如果缓存已满（size &#x3D;&#x3D; capacity），则执行“淘汰”：  <ul><li>删除链表头部（Head-&gt;next）的节点，因为它最久没被使用。  </li><li>同步在哈希表中删除该节点的 key。</li></ul></li><li><strong>插入新节点</strong>：创建新节点，放入链表尾部，并在哈希表中记录映射关系。</li></ul><h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p><a href="https://leetcode.cn/problems/lru-cache/">LeetCode 146. LRU 缓存</a><br>下面是LRU缓存算法的C语言实现代码</p><h3 id="使用uthash库实现"><a href="#使用uthash库实现" class="headerlink" title="使用uthash库实现"></a>使用uthash库实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uthash.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125; LRUNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    LRUNode* cacheTable;<br>    <span class="hljs-type">int</span> capacity;<br>&#125; LRUCache;<br><br>LRUCache* <span class="hljs-title function_">lRUCacheCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    LRUCache* cache = (LRUCache*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUCache));<br>    cache-&gt;cacheTable = <span class="hljs-literal">NULL</span>;<br>    cache-&gt;capacity = capacity;<br>    <span class="hljs-keyword">return</span> cache;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lRUCacheGet</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    LRUNode* node = <span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, node);<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCachePut</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    LRUNode* node = <span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        node-&gt;val = value;<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (HASH_COUNT(obj-&gt;cacheTable) == obj-&gt;capacity) &#123;<br>            LRUNode* oldestNode = obj-&gt;cacheTable;<br>            HASH_DEL(obj-&gt;cacheTable, oldestNode);<br>            <span class="hljs-built_in">free</span>(oldestNode);<br>        &#125;<br>        LRUNode* newNode = (LRUNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUNode));<br>        newNode-&gt;key = key;<br>        newNode-&gt;val = value;<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, newNode);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCacheFree</span><span class="hljs-params">(LRUCache* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    LRUNode* node, *tmp;<br>    HASH_ITER(hh, obj-&gt;cacheTable, node, tmp) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手搓双向链表-哈希表实现"><a href="#手搓双向链表-哈希表实现" class="headerlink" title="手搓双向链表 + 哈希表实现"></a>手搓双向链表 + 哈希表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双向链表节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span>* <span class="hljs-title">prev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span>* <span class="hljs-title">next</span>;</span><br>&#125; DLinkNode;<br><br>DLinkNode* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>    DLinkNode* node = (DLinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLinkNode));<br>    node-&gt;key = key;<br>    node-&gt;val = val;<br>    node-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 简易哈希表（数组+链地址法）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_TABLE_SIZE 1009</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashBucket</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    DLinkNode* node;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashBucket</span>* <span class="hljs-title">next</span>;</span><br>&#125; HashBucket;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(key &lt; <span class="hljs-number">0</span> ? -key : key) % HASH_TABLE_SIZE;<br>&#125;<br><br><span class="hljs-comment">// LRU缓存对象</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    DLinkNode* head;<br>    DLinkNode* tail;<br>    HashBucket* hashTable[HASH_TABLE_SIZE];<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>&#125; LRUCache;<br><br><span class="hljs-comment">// 辅助函数，双向链表操作</span><br><span class="hljs-comment">// 将新节点加到双向链表尾部</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">addToTail</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    node-&gt;prev = cache-&gt;tail-&gt;prev;<br>    node-&gt;next = cache-&gt;tail;<br>    cache-&gt;tail-&gt;prev-&gt;next = node;<br>    cache-&gt;tail-&gt;prev = node;<br>&#125;<br><br><span class="hljs-comment">// 从链表中移除节点</span><br><span class="hljs-comment">// 因为有哨兵节点，所以不需要考虑边界</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    node-&gt;prev-&gt;next = node-&gt;next;<br>    node-&gt;next-&gt;prev = node-&gt;prev;<br>&#125;<br><br><span class="hljs-comment">// 将已有节点移到链表尾部（表示最近使用过）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    removeNode(cache, node);<br>    addToTail(cache, node);<br>&#125;<br><br><span class="hljs-comment">// 删除头部节点，也就是最近没使用过，并返回key</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">removeHead</span><span class="hljs-params">(LRUCache* cache)</span> &#123;<br>    DLinkNode* oldest = cache-&gt;head-&gt;next;<br>    <span class="hljs-type">int</span> key = oldest-&gt;key;<br>    removeNode(cache, oldest);<br>    <span class="hljs-built_in">free</span>(oldest);<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-comment">// 哈希表操作</span><br><span class="hljs-comment">// 查找key对应的节点指针</span><br>DLinkNode* <span class="hljs-title function_">hashFind</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket* bucket = cache-&gt;hashTable[idx];<br>    <span class="hljs-keyword">while</span> (bucket) &#123;<br>        <span class="hljs-keyword">if</span> (bucket-&gt;key == key) &#123;<br>            <span class="hljs-keyword">return</span> bucket-&gt;node;<br>        &#125;<br>        bucket = bucket-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入，key-&gt;node的映射</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hashInsert</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key, DLinkNode* node)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket* newBucket = (HashBucket*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashBucket));<br>    newBucket-&gt;key = key;<br>    newBucket-&gt;node = node;<br>    newBucket-&gt;next = cache-&gt;hashTable[idx];<br>    cache-&gt;hashTable[idx] = newBucket;<br>&#125;<br><br><span class="hljs-comment">// 删除key的映射</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hashDelete</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket** indirect = &amp;(cache-&gt;hashTable[idx]);<br>    <span class="hljs-keyword">while</span> (*indirect) &#123;<br>        <span class="hljs-keyword">if</span> ((*indirect)-&gt;key == key) &#123;<br>            HashBucket* toFree = *indirect;<br>            *indirect = toFree-&gt;next;<br>            <span class="hljs-built_in">free</span>(toFree);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// indirect本身,而不是*indirect指向的内容</span><br>        indirect = &amp;((*indirect)-&gt;next);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// LRU接口实现</span><br>LRUCache* <span class="hljs-title function_">lRUCacheCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    LRUCache* cache = (LRUCache*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUCache));<br>    cache-&gt;capacity = capacity;<br>    cache-&gt;size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化哨兵节点</span><br>    cache-&gt;head = createNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cache-&gt;tail = createNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cache-&gt;head-&gt;next = cache-&gt;tail;<br>    cache-&gt;tail-&gt;prev = cache-&gt;head;<br><br>    <span class="hljs-comment">// 初始化哈希表</span><br>    <span class="hljs-built_in">memset</span>(cache-&gt;hashTable, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cache-&gt;hashTable));<br>    <span class="hljs-keyword">return</span> cache;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lRUCacheGet</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    DLinkNode* node = hashFind(obj, key);<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    moveToTail(obj, node);<br>    <span class="hljs-keyword">return</span> node-&gt;val;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCachePut</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    DLinkNode* node = hashFind(obj, key);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        node-&gt;val = value;<br>        moveToTail(obj, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj-&gt;size &gt;= obj-&gt;capacity) &#123;<br>            <span class="hljs-type">int</span> oldestKey = removeHead(obj);<br>            hashDelete(obj, oldestKey);<br>            obj-&gt;size--;<br>        &#125;<br>        DLinkNode* newNode = createNode(key, value);<br>        addToTail(obj, newNode);<br>        hashInsert(obj, key, newNode);<br>        obj-&gt;size++;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCacheFree</span><span class="hljs-params">(LRUCache* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    DLinkNode* cur = obj-&gt;head-&gt;next;<br>    <span class="hljs-keyword">while</span> (cur != obj-&gt;tail) &#123;<br>        DLinkNode* next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj-&gt;head);<br>    <span class="hljs-built_in">free</span>(obj-&gt;tail);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; HASH_TABLE_SIZE; i++) &#123;<br>        HashBucket* bucket = obj-&gt;hashTable[i];<br>        <span class="hljs-keyword">while</span> (bucket) &#123;<br>            HashBucket* next = bucket-&gt;next;<br>            <span class="hljs-built_in">free</span>(bucket);<br>            bucket = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><ol><li><strong>DLinkNode</strong>：双向链表节点，包含 key、val、prev、next。用于维护最近使用顺序（尾部为最近使用，头部为最久未用）。</li><li><strong>HashBucket</strong>：哈希桶中的链表节点（链地址法），每个桶是一个链表，解决哈希冲突。存储 key 和对应的 DLinkNode* 指针，避免重复存储值</li><li><strong>LRUCache</strong>：缓存主体，head &#x2F; tail：哨兵节点（dummy nodes），简化边界处理。hashTable：静态数组 + 链表，快速查找。capacity &#x2F; size：容量控制</li></ol><h3 id="操作分析"><a href="#操作分析" class="headerlink" title="操作分析"></a>操作分析</h3><ol><li><strong>addToTail</strong>：将节点添加到链表尾部，表示最近使用</li><li><strong>removeNode</strong>：从链表中移除节点</li><li><strong>moveToTail</strong>：将已有节点移到链表尾部，更新使用顺序</li><li><strong>removeHead</strong>：删除链表头部节点，淘 汰最久未用数据</li><li><strong>hashFind &#x2F; hashInsert &#x2F; hashDelete</strong>：哈希表的基本操作</li><li><strong>lRUCacheGet</strong>：获取数据，更新使用顺序</li><li><strong>lRUCachePut</strong>：插入&#x2F;更新数据，处理容量限制</li></ol><h3 id="亮点学习"><a href="#亮点学习" class="headerlink" title="亮点学习"></a>亮点学习</h3><ol><li><strong>哨兵节点</strong>：使用 head &#x2F; tail 哨兵节点，简化链表边界操作，避免频繁判断 NULL</li><li><strong>链地址法哈希表</strong>：使用静态数组 + 链表解决哈希冲突，节省空间</li><li><strong>时间复杂度</strong>：所有操作均为 O(1)，满足 LRU 缓存的高效需求</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LRU缓存算法通过双向链表和哈希表实现高效的缓存管理，本文介绍了两种C语言实现方式：一种使用uthash库简化哈希操作，另一种手搓数据结构以深入理解底层原理</p>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>哈希表</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆的基本操作</title>
    <link href="/2026/01/05/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2026/01/05/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>堆是一种特殊的完全二叉树结构，常用于实现优先队列。在最大堆中，父节点的值总是大于或等于其子节点的值。本文将通过C语言代码实现一个最大堆</p><h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><p>堆是一种数据结构，具有以下特性：</p><ul><li><strong>完全二叉树</strong>：除了最后一层，其他层都是满的，且最后一层的节点都靠左排列</li><li><strong>堆序性</strong>：在最大堆中，任意节点的值大于或等于其子节点的值</li></ul><p>堆通常用数组来实现，其中：</p><ul><li>根节点索引: <code>0</code></li><li>左子节点索引：<code>2*i + 1</code></li><li>右子节点索引：<code>2*i + 2</code></li><li>父节点索引： <code>(i-1)/2</code></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是最大堆的C语言实现</p><h3 id="1-堆的结构体定义"><a href="#1-堆的结构体定义" class="headerlink" title="1. 堆的结构体定义"></a>1. 堆的结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> *data;      <span class="hljs-comment">// 动态数组，数组指针</span><br>    <span class="hljs-type">int</span> size;       <span class="hljs-comment">// 堆的元素个数</span><br>    <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">// 堆的最大容量</span><br>&#125; MaxHeap;<br></code></pre></td></tr></table></figure><h3 id="2-交换元素"><a href="#2-交换元素" class="headerlink" title="2. 交换元素"></a>2. 交换元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    <span class="hljs-type">int</span> tmp = *a;<br>    *a = *b;<br>    *b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-初始化堆"><a href="#3-初始化堆" class="headerlink" title="3. 初始化堆"></a>3. 初始化堆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap* <span class="hljs-title function_">createHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-comment">// 初始化分配空间</span><br>    MaxHeap* heap = (MaxHeap*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(MaxHeap));<br>    heap-&gt;data = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * capacity);<br>    <span class="hljs-comment">// 堆数值初始化</span><br>    heap-&gt;capacity = capacity;<br>    heap-&gt;size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-向上调整（siftUp）"><a href="#4-向上调整（siftUp）" class="headerlink" title="4. 向上调整（siftUp）"></a>4. 向上调整（siftUp）</h3><p>用于插入元素后维护堆的性质。从插入的节点开始，与父节点比较，如果大于父节点则交换，直到满足堆序性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> childIdx)</span> &#123;<br>    <span class="hljs-keyword">while</span> (childIdx &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> parentIdx = (childIdx - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (heap-&gt;data[childIdx] &gt; heap-&gt;data[parentIdx]) &#123;<br>            swap(&amp;heap-&gt;data[childIdx], &amp;heap-&gt;data[parentIdx]);<br>            childIdx = parentIdx;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-向下调整（siftDown）"><a href="#5-向下调整（siftDown）" class="headerlink" title="5. 向下调整（siftDown）"></a>5. 向下调整（siftDown）</h3><p>用于删除堆顶或建堆时维护堆的性质。从指定节点开始，与子节点比较，选择最大的子节点交换，直到满足堆序性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> parentIdx)</span> &#123;<br>    <span class="hljs-type">int</span> size = heap-&gt;size;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> leftChild = parentIdx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightChild = parentIdx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> largest = parentIdx;<br>        <br>        <span class="hljs-keyword">if</span> (leftChild &lt; size &amp;&amp; heap-&gt;data[leftChild] &gt; heap-&gt;data[largest]) &#123;<br>            largest = leftChild;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightChild &lt; size &amp;&amp; heap-&gt;data[rightChild] &gt; heap-&gt;data[largest]) &#123;<br>            largest = rightChild;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != parentIdx) &#123;<br>            swap(&amp;heap-&gt;data[largest], &amp;heap-&gt;data[parentIdx]);<br>            parentIdx = largest;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-入堆操作（push）"><a href="#6-入堆操作（push）" class="headerlink" title="6. 入堆操作（push）"></a>6. 入堆操作（push）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-comment">// 满堆的处理</span><br>    <span class="hljs-keyword">if</span> (heap-&gt;size == heap-&gt;capacity)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    heap-&gt;data[heap-&gt;size] = val;<br><br>    <span class="hljs-comment">// 这里siftUp与size无关，所以两者顺序不影响</span><br>    siftUp(heap, heap-&gt;size);<br>    heap-&gt;size++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-出堆操作（pop）"><a href="#7-出堆操作（pop）" class="headerlink" title="7. 出堆操作（pop）"></a>7. 出堆操作（pop）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(MaxHeap* heap)</span> &#123;<br>    <span class="hljs-comment">// 空堆检查</span><br>    <span class="hljs-keyword">if</span> (heap-&gt;size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> root = heap-&gt;data[<span class="hljs-number">0</span>];     <br>    <br>    <span class="hljs-comment">// 用最后一个元素覆盖堆顶</span><br>    heap-&gt;data[<span class="hljs-number">0</span>] = heap-&gt;data[heap-&gt;size - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 必须先减size再siftDown：</span><br>    <span class="hljs-comment">// 1. siftDown依赖正确的heap-&gt;size判断子节点边界</span><br>    <span class="hljs-comment">// 2. 原末尾元素已移至堆顶，该位置不再属于堆</span><br>    <span class="hljs-comment">// 3. 避免siftDown访问到逻辑上已移除的元素</span><br>    heap-&gt;size--;  <br>    siftDown(heap, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-删除任意位置的元素"><a href="#8-删除任意位置的元素" class="headerlink" title="8. 删除任意位置的元素"></a>8. 删除任意位置的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteElement</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= heap-&gt;size)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        pop(heap);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == heap-&gt;size - <span class="hljs-number">1</span>) &#123;<br>        heap-&gt;size--;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> lastVal = heap-&gt;data[heap-&gt;size - <span class="hljs-number">1</span>];<br>    heap-&gt;size--;<br>    <span class="hljs-type">int</span> oldVal = heap-&gt;data[i];<br>    heap-&gt;data[i] = lastVal;<br><br>    <span class="hljs-keyword">if</span> (lastVal &gt; oldVal) &#123;<br>        siftUp(heap, i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        siftDown(heap, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-建堆操作"><a href="#9-建堆操作" class="headerlink" title="9. 建堆操作"></a>9. 建堆操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap* <span class="hljs-title function_">makeHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 堆的初始化</span><br>    MaxHeap* heap = createHeap(numsSize);<br>    <span class="hljs-comment">// 数组拷贝到堆</span><br>    <span class="hljs-built_in">memcpy</span>(heap-&gt;data, nums, numsSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    heap-&gt;size = numsSize;<br>    <span class="hljs-comment">// 从最后一个非叶节点开始向下调整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (numsSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        siftDown(heap, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上代码，我们实现了一个完整的大根堆数据结构，堆的基本操作包括：</p><ul><li><strong>插入</strong>：使用<code>push</code>函数，时间复杂度O(log n)</li><li><strong>删除堆顶</strong>：使用<code>pop</code>函数，时间复杂度O(log n)</li><li><strong>删除任意元素</strong>：使用<code>deleteElement</code>函数，时间复杂度O(log n)</li><li><strong>建堆</strong>：使用<code>makeHeap</code>函数，时间复杂度O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>独居者</title>
    <link href="/2023/07/26/%E7%8B%AC%E5%B1%85%E8%80%85/"/>
    <url>/2023/07/26/%E7%8B%AC%E5%B1%85%E8%80%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://baike.baidu.com/item/%E9%99%86%E8%A0%A1/1945940?fr=ge_ala">陆蠡</a></p></blockquote><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p style="text-indent: 2em;">现在我很懊悔无意中发现了C君的秘密，一个人在孤独时的秘密。这是一种痛苦，他原先紧紧藏着，预备留给他自己的，我无意中知道，这痛苦乃交给了我。他自己还不知道这回事，实际上另外有个人在分担他的痛苦了。听说有一种眚神，专给人家作祟的。但作祟的工作要在秘密中进行。譬如一个人在单房暗室，独处的时候，这眚神便用各种威胁引诱，弄得他害病为止。万一这作祟的工作被一个闯入者发现了或道破了，这眚神便舍掉原先想害的人，转向闯入者纠缠，将祸害嫁给后者。我碰到的正是这种情形。当我发现了他深自掩藏着的痛苦，我也要替他分负的了。<p>　　要说我为什么把这回事放在自己心上？我不知道。只好怪我自己了。要说他有什么痛苦，为什么痛苦？我也不知道。这是一个谜。痛苦是往往说不出的。好像挨了毒打，浑身疼痛，却摸不着痛处。C君是一个奇特的人！他是属于幸福的一群呢？还是属于不幸的一群呢？我不能下断语。要论断某一个人，总得自己的见解智慧比人高出一筹，方得中肯。正如景色的眺望者，从高处往下看，方见全景；若从卑处往高看，所见结果一定不对的。我对C君的观察是从卑处往高看吧，我的叙述也许是不对的。也许他不似我所猜想的，根本没有什么痛苦，这一切倒是我自己的幻觉，这也难定。总之，说他有点奇特，不算过分吧。</p><p>　　C君是我的朋友。我们认识有许多年头了。他给我最初的印象是一个可爱的，快乐的，和蔼的青年人。他服装穿得干净，鞋帽整齐。他的头发总是剪得齐齐的，两旁梳开，披在颞颥边，中间显出一条肉路。他的脸端正，端庄的表情浮在端正的脸上，有一种没有矜伐的厚道。他有明净的眼珠，不常直视人，偶然碰到别人的眼光在他的脸上搜索的时候，总是微微一笑避开。他鼻子方正，鼻准微平。嘴也搭配得大小适宜，嘴唇略厚一点，这使他的脸减损一分秀气。他会说话，不大流利，可够表达，显然是练习出来的。他的脸颜微嫌瘦削，照他的骨架子，应当更丰满些。总之，他是一望而知的没有受过生活鞭挞的人，在一个陌生人的眼中，正如一般生活优裕的人，往往多受人们尊敬。</p><p>　　从他对人和做事的态度看来，他是一个热情的没有自私的青年。他对朋友极诚恳，做事认真负责。他的信念极坚定，在他的眼前永远闪现着美丽的希望。他不颓沮，不懊丧，脸上心里总是浮着微笑的。他从没有对任何事失去忍耐，对任何人抱怨，责备；他忙，但颇有点闲情。有一次我见他照画报上的样子在剖剔一个水仙球茎，弄了好几个钟头，似乎没失去耐性。</p><p>　　我们时常在一起，散步谈天。我们谈到粗俗的，猥亵的，平凡的，崇高的，他很坦白，很少隐藏，因此我也约略知道他的身世，他的思想，他的感情。一切都没超人或异乎常人的地方。他正是一个脚踏实地地为理想的工作者。</p><p>　　但是当我发现他有一种爱好独居的性格的时候，我渐渐觉得他有点奇特。他的工作（我想对他的工作性质的说明是不必要的。世界上，哪种工作最高贵最重要，而哪一种又不重要的，无价值的，我想没有人能够品评），使他和人们亲近，同居处，同饮食。但他总是单独住一个房间。他从不肯留一个朋友在他房里住宿。他好像是洁身自爱的女子，不让别人占用她的闺闼。当有一次一位从远道来的友人来望他，那友人找不到别的宿处而又疲倦了，打算在他房里过一夜，他陪他坐到夜深，最后，站起来说道：“我房里没留过客人，我要保持这记录，我陪你上旅馆去。”友人显然有点愠色，但他还是曳着友人上旅馆去了。这事后来那友人告诉我好多次，说他是有点不近人情的。</p><p>　　他住的房间陈设简陋，但他守住这简陋的房间，像野兽守住它的洞穴，不愿意别兽闯入。我对个人的癖爱颇能谅解。像他这样的人，也许为了工作性质的关系，也许为了读书研习的关系，不愿别人打吵他，是说得过去的。我曾有个时期和他同住在一所公共的建筑内，同处在一个屋顶下，但我们仍旧保持着各人的生活习惯。因为我们有着不同的职业。我白天出去，晚上一早就睡了。他到夜深睡，早晨起床比较迟。有时候我们是数天不见面的。</p><p>　　一天的夜里我发现了他孑身独处的原因。愿他原谅我，我是无心的。我看取了他的秘密，却无法把它交还原主，这使我时时引以为憾。我不是好奇的。这发现属于偶然，至今我还是懊悔那一次的闯入。</p><p>　　那是一个有月亮的夏季的晚上，夜深使一切喧嚣归于静寂。我这夜特别比平时睡得迟，正预备熄灯睡的时候，突然想起一件东西遗在C君的房里，想立刻得到它。我想他是已经睡了，为了不惊扰他，我悄声走过去，我蹑着脚步走近他的房间。他的房门没有锁，被午夜的风吹开，留着一条阔缝。我一脚跨进去，仿佛眼前一个异景怔住了我，我几乎不相信我自己的眼睛了。C君在做什么啦！他跪在自己床前的地上，头伏在臂里，好像在作祈祷。从窗口斜射进来的月光把室内照成一种淡淡的晖明，他虽则跪在暗里，我却清楚地能够辨别他额上流着汗，脸孔是严肃而神秘的，一种不胜苦楚之情。这使我想起耶稣基督在客西马尼亚园中的祈祷：“汗珠大如血点，流在地上。”一种在苦杯前踌躇的惶悚。C君也好像是在推开一个苦杯而又准备接受。他全神贯注地沉在默念中，好像在一种不可见的神前忏悔，又好像是一个为热情所燃烧的男子在冷若冰霜的女子面前恳求，一种祈求幸福或是向幸福辞谢的神情……我几乎失声喊了出来，一种神秘的力量使我噤住。我悄悄退出，站在外面，从门隙中望他继续的动作。约莫过了四五分钟，他慢慢地站起来，走向窗口，面朝月光把手徐徐举起，好像迎接从月光中降落的天使似的。随后又把手垂下，向后摸索着床架，扶在上面，脸仍不回过来，这样站着好久好久。我只能从他偶然偏过来的脸望见那上面的神秘似的似乎痉挛的表情。“他是被痛苦啮噬着，”我忽然想到，于是迅速地跑回我自己的房间，忘记了适才去他房里的目的，我熄了灯，躺在床上，辗转了好久，我细细分析他平时的见解和行为，一丝也没有异样。但渐渐我从他偶尔流露的片言只语里，好像发觉他是怀着什么痛苦。</p><p>　　那也是和他相识不久的时候，我们已有时常谈天的习惯，我坐在他房里，我们纵谈着各种琐事，讨论着许多问题。我们谈得很有兴趣，这时他手中揉弄着一条领带。我想到一个友人，爱把领带当作裤带束在腰间，于是我说：</p><p>　　“你知道领带还有什么别的用途么？”</p><p>　　“哈哈哈。”</p><p>　　“猜得着吗？”</p><p>　　“哈哈哈。”</p><p>　　我不耐烦地就把我的发现告诉他。说是领带当裤带是适宜的。长短阔狭都好，只是一端太宽了些。</p><p>　　“还有一个用途。”他补充说。</p><p>　　“什么？”</p><p>　　“哈哈哈。”他不说下去了。</p><p>　　但是一转想我也猜到了。那是上吊用的。当时我觉得这家伙脑筋古怪，怎会想到这上面来呢？但是他那快活的笑声，立刻把我思想的阴云打散了。</p><p>　　我从来不曾听到他悲观的论调。但有一次一个友人颂赞“生的欢喜”“生的美丽”说：</p><p>　　“生是多美丽啊！我便从来没想到自杀过。”</p><p>　　“谎话！”好像听见C君的自言自语。但他立刻用快活的声音接着道：</p><p>　　“是的。生是美丽的。”</p><p>　　谁能够解释他身上的矛盾呢？谁能够看出他极快活的表面底下潜藏着一个痛苦的灵魂？他有希望的光明，却又有失望的暗影；他有快乐的外表，却又有忧郁的内心。他好像是一池深深的潭水，表面平静光滑，反射着美丽的阳光，底里却翻涌着涡卷的伏流。有人留心到海面么？涡流最急的地方往往表面上显得异常光滑。C君的心境便是这样子。令人费于索解了。</p><p>　　我想从他自己的口中和别人的口中探听，他是否受过什么大刺激，譬如失恋等情事，答案都是否定的。受过良好的教育，正如有着进步思想的人，他是自由主义者，他反对宗教，反对权力，反对加在人类身上的经济的和思想的一切桎梏，那么他为什么那样苦苦地祈祷呢？简直像一个虔诚的教徒！为什么他想到“死”呢？想到人们认为罪恶而自己也认为罪恶的“自杀”呢？这一切都是谜。他是在割舍一种人性上离不开的东西呢？他是不是凭他那严刻的内省，在替他自己的信念和理想觅取一种道德上的支持？好像他发现了一种理想，而又怀疑着，又给自己的怀疑解释，而这解释又不能使自己满意，他想抓住无定形的理想，而又抓不住，因而显得痛苦呢？这一些，也许连他自己也不会明白。</p><p>　　于是我发现他平时乐观的态度倒是一种悲哀的掩饰了。嗣后每次他和我谈话的时候，我便不禁想起他夜晚苦苦跪着的样子。“他苦苦地制造了一个希望，一个理想，来扶掖自己。”我总这样地想。他是天生的有忧郁性格的人，却人为地在忧郁的底子上抹上一层愉快的色彩。这种努力是可敬的，但是这种努力，总给我以一种不可言说的悲哀。</p>]]></content>
    
    
    <categories>
      
      <category>文学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
