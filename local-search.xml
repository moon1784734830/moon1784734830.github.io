<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>哈希表之Uthash应用</title>
    <link href="/2026/01/12/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B9%8BUthash%E5%BA%94%E7%94%A8/"/>
    <url>/2026/01/12/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B9%8BUthash%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="Uthash总览"><a href="#Uthash总览" class="headerlink" title="Uthash总览"></a>Uthash总览</h2><h3 id="哈希表介绍"><a href="#哈希表介绍" class="headerlink" title="哈希表介绍"></a>哈希表介绍</h3><p>哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。在这哈希表中，每一个元素的key和它的存储位置都存在一个f(key)的映射关系，我们可以通过f(key)快速的查找到这个元素在表中的位置</p><h3 id="Uthash简介"><a href="#Uthash简介" class="headerlink" title="Uthash简介"></a>Uthash简介</h3><p>Uthash是一个用C语言编写的开源哈希表库，它提供了简单易用的接口来创建和操作哈希表。Uthash支持多种数据类型作为键，并且可以动态调整哈希表的大小以适应数据量的变化</p><hr><h2 id="hot100中Uthash的应用"><a href="#hot100中Uthash的应用" class="headerlink" title="hot100中Uthash的应用"></a>hot100中Uthash的应用</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p><a href="https://leetcode.cn/problems/two-sum/">LeetCode 1. 两数之和</a></p><p><strong>问题描述：</strong> 给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标</p><p><strong>Uthash应用：</strong> 使用Uthash存储数组元素及其索引，在遍历数组时，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br><span class="hljs-comment">//定义全局变量哈希表指针，指向表头</span><br>hashTable* table;<br><br><span class="hljs-comment">//查找功能</span><br>hashTable* <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span>&#123;<br>    hashTable* tmp;<br>    HASH_FIND_INT(table,&amp;key,tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-comment">//插入功能</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> key,<span class="hljs-type">int</span> val)</span>&#123;<br>    hashTable* node=find(key);<br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)&#123;<br>        hashTable* tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=key;<br>        tmp-&gt;val=val;<br>        HASH_ADD_INT(table,key,tmp);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        node-&gt;val=val;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span>* <span class="hljs-title function_">twoSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize)</span>&#123;<br>    table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        hashTable* tmp=find(target-nums[i]);<br>        <span class="hljs-keyword">if</span>(tmp)&#123;<br>            <span class="hljs-type">int</span>* ret=(<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)*<span class="hljs-number">2</span>);<br>            ret[<span class="hljs-number">0</span>]=tmp-&gt;val;<br>            ret[<span class="hljs-number">1</span>]=i;<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            insert(nums[i],i);<br>        &#125;<br>    &#125;<br>    *returnSize=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>遍历数组，对于每个元素，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在</li><li>如果存在，返回对应的索引；如果不存在，将当前元素及其索引插入哈希表中</li><li>最后是在O(n)的时间复杂度内解决问题</li></ol><hr><h3 id="2-字母异位词分组"><a href="#2-字母异位词分组" class="headerlink" title="2. 字母异位词分组"></a>2. 字母异位词分组</h3><p><a href="https://leetcode.cn/problems/group-anagrams/">LeetCode 49. 字母异位词分组</a></p><p><strong>问题描述：</strong> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串</p><p><strong>Uthash应用：</strong> 使用Uthash存储排序后的字符串作为键，原始字符串列表作为值，将异位词分组</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span>* key;          <span class="hljs-comment">//键：排序后的字符串</span><br>    <span class="hljs-type">char</span>** <span class="hljs-built_in">list</span>;        <span class="hljs-comment">//值：原始字符串列表</span><br>    <span class="hljs-type">int</span> cnt;            <span class="hljs-comment">//当前字符串对应的列表大小</span><br>    <span class="hljs-type">int</span> capacity;       <span class="hljs-comment">//列表容量</span><br>    UT_hash_handle hh;  <span class="hljs-comment">//哈希表句柄</span><br>&#125; hashTable;<br><br>hashTable* table;<br><br><span class="hljs-comment">//qsort比较函数需要使用的cmp函数</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a,<span class="hljs-type">const</span> <span class="hljs-type">void</span>* b)</span>&#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span>*)a-*(<span class="hljs-type">char</span>*)b);<br>&#125;<br><br>hashTable* <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span>* key)</span>&#123;<br>    hashTable* tmp;<br>    HASH_FIND_STR(table,key,tmp);<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-comment">//这里需要注意字符串的+1是为了存储字符串的结束符&#x27;\0&#x27;</span><br>hashTable* <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">char</span>* key,<span class="hljs-type">char</span>* str)</span>&#123;<br>    hashTable* node=find(key);<br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)&#123;<br>        hashTable* tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(key)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(tmp-&gt;key,key);<br>        tmp-&gt;capacity=<span class="hljs-number">10</span>;<br>        tmp-&gt;cnt=<span class="hljs-number">0</span>;<br>        tmp-&gt;<span class="hljs-built_in">list</span>=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*)*tmp-&gt;capacity);<br>        tmp-&gt;<span class="hljs-built_in">list</span>[tmp-&gt;cnt]=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(tmp-&gt;<span class="hljs-built_in">list</span>[tmp-&gt;cnt],str);<br>        tmp-&gt;cnt++;<br>        HASH_ADD_STR(table,key,tmp);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//如果容量不够则扩容</span><br>        <span class="hljs-keyword">if</span>(node-&gt;cnt&gt;=node-&gt;capacity)&#123;<br>            node-&gt;capacity*=<span class="hljs-number">2</span>;<br>            node-&gt;<span class="hljs-built_in">list</span>=<span class="hljs-built_in">realloc</span>(node-&gt;<span class="hljs-built_in">list</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*)*node-&gt;capacity);<br>        &#125;<br><br>        node-&gt;<span class="hljs-built_in">list</span>[node-&gt;cnt]=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(str)+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(node-&gt;<span class="hljs-built_in">list</span>[node-&gt;cnt],str);<br>        node-&gt;cnt++;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">char</span>*** <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(<span class="hljs-type">char</span>** strs, <span class="hljs-type">int</span> strsSize, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span>&#123;<br>    table=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//构建哈希表，插入键与值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;strsSize;i++)&#123;<br>        <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(strs[i]);<br>        <span class="hljs-type">char</span>* sortedStr=<span class="hljs-built_in">malloc</span>(len+<span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">strcpy</span>(sortedStr,strs[i]);<br>        qsort(sortedStr,len,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>),cmp);<br>        insert(sortedStr,strs[i]);<br>        <span class="hljs-built_in">free</span>(sortedStr);<br>    &#125;<br><br>    *returnSize=HASH_COUNT(table);<br>    <span class="hljs-type">char</span>*** res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>**) * (*returnSize));<br>    *returnColumnSizes = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (*returnSize));<br>    <span class="hljs-type">int</span> idx=<span class="hljs-number">0</span>;<br>    hashTable* node,*tmp;<br><br>    <span class="hljs-comment">//遍历哈希表，构建结果集</span><br>    HASH_ITER(hh,table,node,tmp)&#123;<br>        res[idx]=<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*)*node-&gt;cnt);<br>        (*returnColumnSizes)[idx]=node-&gt;cnt;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;node-&gt;cnt;j++)&#123;<br>            res[idx][j]=<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(node-&gt;<span class="hljs-built_in">list</span>[j])+<span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">strcpy</span>(res[idx][j],node-&gt;<span class="hljs-built_in">list</span>[j]);<br>        &#125;<br>        idx++;<br>    &#125;<br><br>    <span class="hljs-comment">//清理哈希表，释放内存</span><br>    HASH_ITER(hh,table,node,tmp)&#123;<br>        <span class="hljs-built_in">free</span>(node-&gt;key);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;node-&gt;cnt;j++)&#123;<br>            <span class="hljs-built_in">free</span>(node-&gt;<span class="hljs-built_in">list</span>[j]);   <br>        &#125;<br>        <span class="hljs-built_in">free</span>(node-&gt;<span class="hljs-built_in">list</span>);<br>        HASH_DEL(table,node);<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>遍历字符串数组，对于每个字符串，排序后作为键插入哈希表</li><li>如果键已存在，则将原始字符串添加到对应的值列表中</li><li>最后遍历哈希表，构建结果集</li></ol><hr><h3 id="3-最长连续序列"><a href="#3-最长连续序列" class="headerlink" title="3. 最长连续序列"></a>3. 最长连续序列</h3><p><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">LeetCode 128. 最长连续序列</a></p><p><strong>问题描述：</strong> 给定一个未排序的整数数组，找出最长连续序列的长度</p><p><strong>Uthash应用：</strong> 使用Uthash存储数组元素，遍历数组时，检查每个元素的前后连续元素是否存在，计算最长连续序列长度</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> key;<br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">longestConsecutive</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    <span class="hljs-keyword">if</span>(numsSize==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    hashTable* table=<span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">//构建哈希表,去重</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;numsSize;i++)&#123;<br>        hashTable* tmp;<br>        HASH_FIND_INT(table,&amp;nums[i],tmp);<br>        <span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)&#123;<br>            tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>            tmp-&gt;key=nums[i];<br>            HASH_ADD_INT(table,key,tmp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> longest=<span class="hljs-number">0</span>;<br>    hashTable* node,* findNode,* tmp;<br>    HASH_ITER(hh,table,node,tmp)&#123;<br>        <span class="hljs-type">int</span> cur=node-&gt;key;<br>        <span class="hljs-type">int</span> prev=cur<span class="hljs-number">-1</span>;<br>        HASH_FIND_INT(table,&amp;prev,findNode);<br>        <span class="hljs-comment">//不是序列的起点，跳过</span><br>        <span class="hljs-keyword">if</span>(findNode!=<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">continue</span>; <br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> next=cur+<span class="hljs-number">1</span>;<br>        HASH_FIND_INT(table,&amp;next,findNode);<br>        <span class="hljs-keyword">while</span>(findNode!=<span class="hljs-literal">NULL</span>)&#123;<br>            next++;<br>            cnt++;<br>            HASH_FIND_INT(table,&amp;next,findNode);<br>        &#125;<br>        longest=MAX(cnt,longest);<br>    &#125;<br><br>    <span class="hljs-comment">//释放哈希表内存</span><br>    HASH_ITER(hh,table,node,tmp)&#123;<br>        HASH_DEL(table,node);<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> longest;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>使用Uthash构建哈希表，这一步可以去重</li><li>遍历哈希表，找到每个可能连续序列的起点，这一步算是一个优化，不需要对每个数字都找到最后，只需要对序列起点开始寻找<code>cnt</code>，计算连续长度</li><li>最后比较<code>longest</code>与<code>cnt</code>，返回最长序列长度即可</li></ol><hr><h3 id="4-路径总和Ⅲ"><a href="#4-路径总和Ⅲ" class="headerlink" title="4. 路径总和Ⅲ"></a>4. 路径总和Ⅲ</h3><p><a href="https://leetcode.cn/problems/path-sum-iii/">LeetCode 437. 路径总和 III</a></p><p><strong>问题描述：</strong> 给定一个二叉树和一个整数目标和<code>targetSum</code>，找出路径总和等于目标和的路径数量。路径不需要从根节点开始或结束，但必须向下移动（只能从父节点到子节点）</p><p><strong>Uthash应用：</strong> 使用Uthash存储前缀和及其出现次数，在遍历二叉树时，计算当前路径的前缀和，并查找是否存在满足条件的前缀和</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum;<br>    <span class="hljs-type">int</span> cnt;<br>    UT_hash_handle hh;<br>&#125; PrefixSumNode;<br><br><span class="hljs-type">static</span> PrefixSumNode* prefixMap=<span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfsPathSum</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root,<span class="hljs-type">long</span> <span class="hljs-type">long</span> currSum,<span class="hljs-type">int</span> targetSum,<span class="hljs-type">int</span>* ans)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">//计算当前前缀和</span><br>    currSum+=root-&gt;val;<br>    <span class="hljs-comment">//计算还需要的前缀和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> need=currSum-targetSum;<br>    PrefixSumNode* find;<br>    <span class="hljs-comment">//如果能找到need，则说明存在满足条件的路径</span><br>    HASH_FIND(hh,prefixMap,&amp;need,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>),find);<br>    <span class="hljs-keyword">if</span>(find)&#123;<br>       *ans+=find-&gt;cnt;<br>    &#125;<br>    <span class="hljs-comment">//将当前前缀和加入哈希表</span><br>    PrefixSumNode* currNode=<span class="hljs-literal">NULL</span>;<br>    HASH_FIND(hh,prefixMap,&amp;currSum,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>),currNode);<br>    <span class="hljs-keyword">if</span>(currNode==<span class="hljs-literal">NULL</span>)&#123;<br>       currNode=(PrefixSumNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PrefixSumNode));<br>       currNode-&gt;sum=currSum;<br>       currNode-&gt;cnt=<span class="hljs-number">1</span>;<br>       HASH_ADD(hh,prefixMap,sum,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>),currNode);<br>    &#125; <span class="hljs-keyword">else</span>&#123;<br>       currNode-&gt;cnt++;<br>    &#125;<br>    <span class="hljs-comment">//递归计算左右子树</span><br>    dfsPathSum(root-&gt;left,currSum,targetSum,ans);<br>    dfsPathSum(root-&gt;right,currSum,targetSum,ans);<br>    <span class="hljs-comment">//回溯，移除当前前缀和</span><br>    currNode-&gt;cnt--;<br>    <span class="hljs-keyword">if</span>(currNode-&gt;cnt==<span class="hljs-number">0</span>)&#123;<br>        HASH_DEL(prefixMap,currNode);<br>        <span class="hljs-built_in">free</span>(currNode);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">pathSum</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> targetSum)</span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    prefixMap=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 加入初始前缀和0，1次</span><br>    PrefixSumNode* baseNode=(PrefixSumNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(PrefixSumNode));<br>    baseNode-&gt;sum=<span class="hljs-number">0</span>;<br>    baseNode-&gt;cnt=<span class="hljs-number">1</span>;<br>    HASH_ADD(hh,prefixMap,sum,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>),baseNode);<br><br>    dfsPathSum(root,<span class="hljs-number">0</span>,targetSum,&amp;ans);<br>    <span class="hljs-comment">//释放哈希表内存</span><br>    PrefixSumNode* node,*tmp;<br>    HASH_ITER(hh,prefixMap,node,tmp)&#123;<br>        HASH_DEL(prefixMap,node);<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题使用哈希表的优势如下：</p><ol><li>使用<code>Uthash</code>存储前缀和及其出现次数，可以在<code>O(1)</code>时间内查找是否存在满足条件的前缀和</li><li>通过前缀和的概念，可以高效地计算路径和，类似与两数之和的去查找<code>need</code></li><li>本题的一个重点就是<code>need=currSum-targetSum</code>，通过这个公式可以快速定位到满足条件的前缀和，从而计算路径数量</li></ol><p>解题思路如下：</p><ol><li>使用DFS遍历二叉树，使用哈希表储存当前节点的前缀和（当前路径上的），通过前缀和之差计算出其中子路径的路径之和，判断是否等于<code>targetSum</code></li><li>哈希表还要储存<code>cnt</code>，表示当前前缀和出现的次数，因为可能存在多条路径的前缀和相同</li><li>注意本题还需要回溯，在DFS返回上一层时，需要将当前前缀和的计数减一，确保哈希表中只包含当前路径上的前缀和信息</li></ol><hr><h3 id="5-从前序与中序遍历序列构造二叉树"><a href="#5-从前序与中序遍历序列构造二叉树" class="headerlink" title="5. 从前序与中序遍历序列构造二叉树"></a>5. 从前序与中序遍历序列构造二叉树</h3><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">LeetCode 105. 从前序与中序遍历序列构造二叉树</a></p><p><strong>问题描述：</strong> 给定两个整数数组<code>preorder</code>和<code>inorder</code>，其中<code>preorder</code>是二叉树的前序遍历，<code>inorder</code>是二叉树的中序遍历，请构造二叉树并返回其根节点</p><p><strong>Uthash应用：</strong> 使用Uthash存储中序遍历数组中每个元素的索引，便于在构建二叉树时快速定位根节点在中序遍历中的位置，本题使用哈希表主要在于优化查找位置</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//结构体定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br>hashTable* table;<br><br> <span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTreeHelper</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder,<span class="hljs-type">int</span> lpre,<span class="hljs-type">int</span> rpre,<span class="hljs-type">int</span>* inorder,<span class="hljs-type">int</span> lin,<span class="hljs-type">int</span> rin)</span>&#123;<br>    <span class="hljs-keyword">if</span>(lpre&gt;rpre || lin&gt;rin) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 找到根节点（先序序列当前区间的第一个节点）在中序遍历中的位置</span><br>    <span class="hljs-type">int</span> rootVal=preorder[lpre];<br>    hashTable* find;<br>    HASH_FIND_INT(table,&amp;rootVal,find);<br>    <span class="hljs-type">int</span> k=find-&gt;val;<br>    <span class="hljs-comment">// 构造二叉树</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">root</span>=</span>(<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    root-&gt;val=rootVal;<br>    <span class="hljs-type">int</span> leftSize=k-lin;<br><br>    root-&gt;left=builedTreeHelper(preorder,lpre+<span class="hljs-number">1</span>,lpre+leftSize,inorder,lin,k<span class="hljs-number">-1</span>);<br>    root-&gt;right=builedTreeHelper(preorder,lpre+leftSize+<span class="hljs-number">1</span>,rpre,inorder,k+<span class="hljs-number">1</span>,rin);<br>    <br>    <span class="hljs-keyword">return</span> root;<br> &#125;<br><br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span> preorderSize, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize)</span>&#123;<br>    table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 构建哈希表，存储中序遍历数组中每个元素的索引</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;inorderSize;i++)&#123;<br>        hashTbale* tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=inorder[i];<br>        tmp-&gt;val=i;<br>        HASH_ADD_INT(table,key,tmp);<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">root</span>=</span>buildTreeHelper(preorder,<span class="hljs-number">0</span>,preorderSize<span class="hljs-number">-1</span>,inorder,<span class="hljs-number">0</span>,inorderSize<span class="hljs-number">-1</span>);<br><br>    hashTable* tmp,* curr;<br>    HASH_ITER(hh,table,curr,tmp)&#123;<br>        HASH_DEL(table,curr);<br>        <span class="hljs-built_in">free</span>(curr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题相比如下的原始版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span>  TreeNode* <span class="hljs-title function_">Tree</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder,<span class="hljs-type">int</span> lpre,<span class="hljs-type">int</span> rpre,<span class="hljs-type">int</span> *inorder,<span class="hljs-type">int</span> lin,<span class="hljs-type">int</span> rin)</span>&#123;<br>    <span class="hljs-keyword">if</span>(lpre &gt; rpre || lin &gt; rin)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span>(k=lin;k&lt;=rin;k++)&#123;<br>        <span class="hljs-keyword">if</span>(inorder[k]==preorder[lpre])&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">root</span>=</span>(<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    root-&gt;val=preorder[lpre];<br>    <span class="hljs-type">int</span> leftSize = k - lin;<br>    root-&gt;left=Tree(preorder,lpre+<span class="hljs-number">1</span>,lpre+leftSize,inorder,lin,k<span class="hljs-number">-1</span>);<br>    root-&gt;right=Tree(preorder,lpre+leftSize+<span class="hljs-number">1</span>,rpre,inorder,k+<span class="hljs-number">1</span>,rin);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">buildTree</span><span class="hljs-params">(<span class="hljs-type">int</span>* preorder, <span class="hljs-type">int</span> preorderSize, <span class="hljs-type">int</span>* inorder, <span class="hljs-type">int</span> inorderSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> Tree(preorder,<span class="hljs-number">0</span>,preorderSize<span class="hljs-number">-1</span>,inorder,<span class="hljs-number">0</span>,inorderSize<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用哈希表的优势如下：</p><ol><li>使用<code>Uthash</code>存储中序遍历数组中每个元素的索引，可以在<code>O(1)</code>时间内查找根节点在中序遍历中的位置</li><li>避免了在每次递归中使用循环查找根节点位置，提升了整体构建二叉树的效率</li></ol><p>解题思路如下：</p><ol><li>使用<code>Uthash</code>构建哈希表，存储中序遍历数组中每个元素的索引</li><li>递归构建二叉树，利用哈希表快速定位根节点在中序遍历中的位置，划分左右子树</li><li>最后释放哈希表内存，返回构建好的二叉树根节点</li></ol><hr><h3 id="6-多数元素"><a href="#6-多数元素" class="headerlink" title="6. 多数元素"></a>6. 多数元素</h3><p><a href="https://leetcode.cn/problems/majority-element/">LeetCode 169. 多数元素</a></p><p><strong>问题描述：</strong> 给定一个大小为<code>n</code>的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于<code>⌊ n/2 ⌋</code>的元素</p><p><strong>Uthash应用：</strong> 使用Uthash存储数组元素及其出现次数，遍历数组时，更新哈希表中的计数，最后找到出现次数超过<code>n/2</code>的元素</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">majorityElement</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span>&#123;<br>    hashTable* table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// 构建哈希表，统计每个元素的出现次数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i;i&lt;numsSize;i++)&#123;<br>        hashTable* node;<br>        HASH_FIND_INT(table.&amp;nums[i],node);<br>        <span class="hljs-keyword">if</span>(node==<span class="hljs-literal">NULL</span>)&#123;<br>            node=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>            node-&gt;key=nums[i];<br>            node-&gt;val=<span class="hljs-number">1</span>;<br>            HASH_ADD_INT(table,key,node);<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            node-&gt;val++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans;<br>    <span class="hljs-type">int</span> maxCnt=<span class="hljs-number">0</span>;<br>    hashTable* node,* tmp;<br>    <span class="hljs-comment">// 遍历哈希表，找到出现次数最多的元素</span><br>    HASH_ITER(hh,table,node,tmp)&#123;<br>        <span class="hljs-keyword">if</span>(node-&gt;val&gt;maxCnt)&#123;<br>            max=node-&gt;val;<br>            ans=node-&gt;key;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题除了技巧方法，其他方法较为好想,在这里使用哈希表主要还是为了熟悉哈希表的使用</p><hr><h3 id="7-随机链表的复制"><a href="#7-随机链表的复制" class="headerlink" title="7. 随机链表的复制"></a>7. 随机链表的复制</h3><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">LeetCode 138. 随机链表的复制</a></p><p><strong>问题描述：</strong> 给定一个链表，每个节点包含一个额外的随机指针，该指针可以指向链表中的任何节点或<code>null</code>。请实现一个函数来复制这个链表</p><p><strong>Uthash应用：</strong> 使用Uthash存储原始节点与其对应的复制节点的映射关系，在遍历原始链表时，创建复制节点并更新随机指针</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">key</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">val</span>;</span><br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    hashTable* table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">curr</span>=</span>head;<br>    <span class="hljs-comment">// 构建哈希表，存储原始节点与复制节点的映射关系</span><br>    <span class="hljs-keyword">while</span>(curr)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newNode</span>=</span>(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;val=curr-&gt;val;<br>        newNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>        newNode-&gt;random=<span class="hljs-literal">NULL</span>;<br>        <br>        hashTable* tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=curr;<br>        tmp-&gt;val=newNode;<br>        HASH_ADD_PTR(table,key,tmp);<br><br>        curr=curr-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 更新复制节点的next和random指针</span><br>    curr=head;<br>    <span class="hljs-keyword">while</span>(curr)&#123;<br>        hashTable* find;<br>        HASH_FIND_PTR(table,&amp;curr,find);<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newNode</span>=</span>find-&gt;val;<br><br>        <span class="hljs-comment">// 设置next指针</span><br>        <span class="hljs-keyword">if</span>(curr-&gt;next)&#123;<br>            HASH_FIND_PTR(table,&amp;curr-&gt;next,find);<br>            newNode-&gt;next=find-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            newNode-&gt;next=<span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置random指针</span><br>        <span class="hljs-keyword">if</span>(curr-&gt;random)&#123;<br>            HASH_FIND_PTR(table,&amp;curr-&gt;random,find);<br>            newNode-&gt;random=find-&gt;val;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            newNode-&gt;random=<span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        curr=curr-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回复制链表的头节点</span><br>    hashTable* findHead;<br>    HASH_FIND_PTR(table,&amp;head,findHead);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newHead</span>=</span>findHead-&gt;val;<br><br>    hashTable* curr,* tmp;<br>    HASH_ITER(hh,table,curr,tmp)&#123;<br>        HASH_DEL(table,curr);<br>        <span class="hljs-built_in">free</span>(curr);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>遍历原始链表，使用哈希表存储每个原始节点与其对应的复制节点的映射关系</li><li>再次遍历原始链表，使用哈希表更新复制节点的<code>next</code>和<code>random</code>指针</li><li>最后返回复制链表的头节点</li></ol><p>除了上述的方法外，还有一种哈希表+递归的方法:</p><ol><li>我们用哈希表记录每一个节点对应新节点的创建情况。</li><li>遍历该链表的过程中，我们检查<code>当前节点的后继节点</code>和<code>当前节点的随机指针指向的节点</code>的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。</li><li>当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。</li><li>注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。</li></ol><p>下面我会给出代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 哈希表结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">key</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">val</span>;</span><br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br>hashTable* table;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span>&#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    hashTable* tmp;<br>    HASH_FIND_PTR(table,&amp;head,tmp);<br>    <span class="hljs-keyword">if</span>(tmp==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newNode</span>=</span>(<span class="hljs-keyword">struct</span> Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        newNode-&gt;val=head-&gt;val;<br>        tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=head;<br>        tmp-&gt;val=newNode;<br>        HASH_ADD_PTR(table,key,tmp);<br>        newNode-&gt;next=deepCopy(head-&gt;next);<br>        newNode-&gt;random=deepCopy(head-&gt;random);<br>    &#125;<br>    <span class="hljs-keyword">return</span> tmp-&gt;val;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span>&#123;<br>    table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">newHead</span>=</span>deepCopy(head);<br>    hashTable* curr,* tmp;<br>    HASH_ITER(hh,table,curr,tmp)&#123;<br>        HASH_DEL(table,curr);<br>        <span class="hljs-built_in">free</span>(curr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="8-相交链表"><a href="#8-相交链表" class="headerlink" title="8. 相交链表"></a>8. 相交链表</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LeetCode 160. 相交链表</a></p><p><strong>问题描述：</strong> 给定两个单链表的头节点<code>headA</code>和<code>headB</code>，找出并返回两个链表相交的起始节点。如果两个链表没有交点，返回<code>null</code></p><p><strong>Uthash应用：</strong> 使用Uthash存储第一个链表的节点地址，在遍历第二个链表时，检查节点是否存在于哈希表中，找到相交节点</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">key</span>;</span><br>    UT_hash_handle hh;<br>&#125; hashTable;<br><br><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">getIntersectionNode</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *headA, <span class="hljs-keyword">struct</span> ListNode *headB)</span>&#123;<br>    hashTable* table=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">curr</span>=</span>headA;<br>    <span class="hljs-comment">// 构建哈希表，存储第一个链表的节点地址</span><br>    <span class="hljs-keyword">while</span>(curr)&#123;<br>        hashTable* tmp=(hashTable*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(hashTable));<br>        tmp-&gt;key=curr;<br>        HASH_ADD_PTR(table,key,tmp);<br>        curr=curr-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历第二个链表，检查节点是否存在于哈希表中</span><br>    curr=headB;<br>    <span class="hljs-keyword">while</span>(curr)&#123;<br>        hashTable* find;<br>        HASH_FIND_PTR(table,&amp;curr,find);<br>        <span class="hljs-keyword">if</span>(find)&#123;<br>            <span class="hljs-keyword">return</span> curr;<br>        &#125;<br>        curr=curr-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>遍历第一个链表，将每个节点的地址存储在哈希表中</li><li>遍历第二个链表，检查每个节点是否存在于哈希表中</li><li>如果找到相交节点，返回该节点；如果遍历结束未找到，返回<code>null</code></li></ol><hr><h3 id="9-和为k的子数组"><a href="#9-和为k的子数组" class="headerlink" title="9. 和为k的子数组"></a>9. 和为k的子数组</h3><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">LeetCode 560. 和为k的子数组</a></p><p><strong>问题描述：</strong> 给定一个整数数组<code>nums</code>和一个整数<code>k</code>，请你统计并返回该数组中和为<code>k</code>的连续子数组的个数</p><p><strong>Uthash应用：</strong> 使用Uthash存储前缀和及其出现次数，在遍历数组时，计算当前前缀和，并查找是否存在满足条件的前缀和</p><p><strong>前缀和思想</strong> 本题与之前的路径总和Ⅲ(- <a href="#4-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C%E2%85%A2">4. 路径总和Ⅲ</a>)类似，都是利用前缀和的思想来解决问题。前缀和是指从数组开头到当前位置的元素之和。通过计算当前前缀和与目标值的差值，我们可以快速定位到满足条件的前缀和，从而计算出连续子数组的个数</p><p><strong>代码实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> sum;          <span class="hljs-comment">// 当前前缀和</span><br>    <span class="hljs-type">int</span> count;        <span class="hljs-comment">// 前缀和出现的次数</span><br>    UT_hash_handle hh; <span class="hljs-comment">// uthash 处理的哈希句柄</span><br>&#125; HashMapEntry;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">subarraySum</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> K)</span> &#123;<br>    HashMapEntry* sum_map = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 哈希表的头指针</span><br>    HashMapEntry* entry;<br>    <span class="hljs-type">int</span> current_sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始情况下，前缀和为0出现一次</span><br>    entry = (HashMapEntry*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashMapEntry));<br>    entry-&gt;sum = <span class="hljs-number">0</span>;<br>    entry-&gt;count = <span class="hljs-number">1</span>; <span class="hljs-comment">// sum=0 出现 1 次</span><br>    HASH_ADD_INT(sum_map, sum, entry);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        current_sum += nums[i];  <span class="hljs-comment">// 更新当前的前缀和</span><br>        <span class="hljs-type">int</span> target = current_sum - K;<br><br>        <span class="hljs-comment">// 查找前缀和为 target 的条目</span><br>        HASH_FIND_INT(sum_map, &amp;target, entry);<br>        <span class="hljs-keyword">if</span> (entry) &#123;<br>            count += entry-&gt;count;  <span class="hljs-comment">// 如果存在，累加计数</span><br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前前缀和在哈希表中的计数</span><br>        HASH_FIND_INT(sum_map, &amp;current_sum, entry);<br>        <span class="hljs-keyword">if</span> (entry) &#123;<br>            entry-&gt;count += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            entry = (HashMapEntry*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashMapEntry));<br>            entry-&gt;sum = current_sum;<br>            entry-&gt;count = <span class="hljs-number">1</span>;<br>            HASH_ADD_INT(sum_map, sum, entry);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 清理哈希表内存</span><br>    HashMapEntry *tmp, *current_entry;<br>    HASH_ITER(hh, sum_map, current_entry, tmp) &#123;<br>        HASH_DEL(sum_map, current_entry);<br>        <span class="hljs-built_in">free</span>(current_entry);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的解题思路是：</p><ol><li>使用<code>Uthash</code>构建哈希表，存储前缀和及其出现次数</li><li>遍历数组，计算当前前缀和，并查找是否存在满足条件的前缀和</li><li>如果存在，累加计数；如果不存在，更新当前前缀和在哈希表中的计数</li><li>最后返回计数结果</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上题目均是我在刷题过程中碰见的有关哈希表的题目，目前还在c语言，没有自带的哈希表数据结构，只能使用<code>Uthash</code>来进行实现，这些题目既可以帮助我学习哈希表的使用方法，也可以帮助我入门<code>Uthash</code>的使用，等到后面使用c++和python的时候应该就会轻松很多</p>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回溯算法</title>
    <link href="/2026/01/11/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2026/01/11/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、什么时候该想到「回溯-DFS」？"><a href="#一、什么时候该想到「回溯-DFS」？" class="headerlink" title="一、什么时候该想到「回溯 &#x2F; DFS」？"></a>一、什么时候该想到「回溯 &#x2F; DFS」？</h2><p>只要题目出现这些关键词之一，优先考虑回溯：</p><ul><li>“所有可能 &#x2F; 全部方案 &#x2F; 所有组合”</li><li>“列举 &#x2F; 返回所有”</li><li>“是否存在一种方式”</li><li>“组合 &#x2F; 排列 &#x2F; 子集”</li><li>“选择 or 不选择”</li><li>“一步一步尝试，失败就退回”</li></ul><p><strong>本质一句话：</strong></p><p>这是一个「多步决策，每一步有多个选择」的问题</p><h2 id="二、回溯题的-5-大核心题型"><a href="#二、回溯题的-5-大核心题型" class="headerlink" title="二、回溯题的 5 大核心题型"></a>二、回溯题的 5 大核心题型</h2><h3 id="①-组合类（Combination）"><a href="#①-组合类（Combination）" class="headerlink" title="① 组合类（Combination）"></a>① 组合类（Combination）</h3><h4 id="典型题目"><a href="#典型题目" class="headerlink" title="典型题目"></a>典型题目</h4><ul><li>电话号码的字母组合</li><li>组合总和</li><li>k 个数的组合</li><li>选若干个元素满足条件</li></ul><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>顺序不重要</li><li>不允许重复 &#x2F; 有条件限制</li><li>“选哪个”比”选的顺序”重要</li></ul><h4 id="抽象模型"><a href="#抽象模型" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>在一个候选集合中<br>一步一步做选择<br>最终得到一个合法组合</p><h4 id="思考套路"><a href="#思考套路" class="headerlink" title="思考套路"></a>思考套路</h4><ul><li>当前能选什么？</li><li>下一步从哪里开始选？</li><li>什么时候算完成？</li></ul><h4 id="模板（核心）"><a href="#模板（核心）" class="headerlink" title="模板（核心）"></a>模板（核心）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-keyword">if</span> (满足条件) &#123;<br>        保存结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;<br>        选择 i;<br>        dfs(i + <span class="hljs-number">1</span>);<br>        撤销选择;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在组合类问题中，通过控制起始索引避免重复选择，确保组合的唯一性。</p><h3 id="②-排列类（Permutation）"><a href="#②-排列类（Permutation）" class="headerlink" title="② 排列类（Permutation）"></a>② 排列类（Permutation）</h3><h4 id="典型题目-1"><a href="#典型题目-1" class="headerlink" title="典型题目"></a>典型题目</h4><ul><li>全排列</li><li>字符串全排列</li><li>有 &#x2F; 无重复元素的排列</li></ul><h4 id="特征-1"><a href="#特征-1" class="headerlink" title="特征"></a>特征</h4><ul><li>顺序很重要</li><li>同样的数字换顺序算不同结果</li></ul><h4 id="抽象模型-1"><a href="#抽象模型-1" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>每一位都要选一个没用过的数</p><h4 id="思考套路-1"><a href="#思考套路-1" class="headerlink" title="思考套路"></a>思考套路</h4><ul><li>当前是第几位？</li><li>哪些元素还没用？</li><li>用一个 visited[] 标记</li></ul><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> depth)</span> &#123;<br>    <span class="hljs-keyword">if</span> (depth == n) &#123;<br>        保存结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i]) <span class="hljs-keyword">continue</span>;<br>        used[i] = <span class="hljs-number">1</span>;<br>        path[depth] = nums[i];<br>        dfs(depth + <span class="hljs-number">1</span>);<br>        used[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 排列类需要使用 visited 数组来标记已使用的元素，避免重复使用同一元素。</p><h3 id="③-子集类（Subset-选或不选）"><a href="#③-子集类（Subset-选或不选）" class="headerlink" title="③ 子集类（Subset &#x2F; 选或不选）"></a>③ 子集类（Subset &#x2F; 选或不选）</h3><h4 id="典型题目-2"><a href="#典型题目-2" class="headerlink" title="典型题目"></a>典型题目</h4><ul><li>子集</li><li>子集 II（含重复）</li><li>所有子序列</li></ul><h4 id="特征-2"><a href="#特征-2" class="headerlink" title="特征"></a>特征</h4><ul><li>每个元素只有两种状态：选 &#x2F; 不选</li><li>没有顺序概念</li></ul><h4 id="抽象模型（决策树）"><a href="#抽象模型（决策树）" class="headerlink" title="抽象模型（决策树）"></a>抽象模型（决策树）</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">    []</span><br>  /    \<br>选      不选<br></code></pre></td></tr></table></figure><h4 id="思考套路-2"><a href="#思考套路-2" class="headerlink" title="思考套路"></a>思考套路</h4><ul><li>到第 i 个元素</li><li>做 2 个决定</li></ul><h4 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i == n) &#123;<br>        保存结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 不选</span><br>    dfs(i + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 选</span><br>    path.push(nums[i]);<br>    dfs(i + <span class="hljs-number">1</span>);<br>    path.pop();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 子集类通过递归遍历每个元素的选择状态，生成所有可能的子集。</p><h3 id="④-路径-棋盘-搜索类（DFS-搜索）"><a href="#④-路径-棋盘-搜索类（DFS-搜索）" class="headerlink" title="④ 路径 &#x2F; 棋盘 &#x2F; 搜索类（DFS 搜索）"></a>④ 路径 &#x2F; 棋盘 &#x2F; 搜索类（DFS 搜索）</h3><h4 id="典型题目-3"><a href="#典型题目-3" class="headerlink" title="典型题目"></a>典型题目</h4><ul><li>单词搜索</li><li>迷宫路径</li><li>N 皇后</li><li>数独</li></ul><h4 id="特征-3"><a href="#特征-3" class="headerlink" title="特征"></a>特征</h4><ul><li>在「二维 &#x2F; 多维空间」中走</li><li>有方向、边界、障碍</li><li>常有 visited 标记</li></ul><h4 id="抽象模型-2"><a href="#抽象模型-2" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>从一个点出发<br>向多个方向尝试<br>不合法就退回</p><h4 id="思考套路-3"><a href="#思考套路-3" class="headerlink" title="思考套路"></a>思考套路</h4><ul><li>当前在哪？</li><li>能往哪走？</li><li>什么时候停止？</li><li>如何标记访问？</li></ul><h4 id="模板-2"><a href="#模板-2" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> &#123;<br>    <span class="hljs-keyword">if</span> (越界 / 不合法) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (找到答案) <span class="hljs-keyword">return</span>;<br><br>    visited[x][y] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (方向) &#123;<br>        dfs(nx, ny);<br>    &#125;<br>    visited[x][y] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 在搜索类问题中，visited 数组防止重复访问同一位置，确保路径的正确性。</p><h3 id="⑤-分割-构造类（切分字符串）"><a href="#⑤-分割-构造类（切分字符串）" class="headerlink" title="⑤ 分割 &#x2F; 构造类（切分字符串）"></a>⑤ 分割 &#x2F; 构造类（切分字符串）</h3><h4 id="典型题目-4"><a href="#典型题目-4" class="headerlink" title="典型题目"></a>典型题目</h4><ul><li>回文串分割</li><li>IP 地址还原</li><li>表达式添加运算符</li></ul><h4 id="特征-4"><a href="#特征-4" class="headerlink" title="特征"></a>特征</h4><ul><li>从字符串中「切一刀」</li><li>每一段要合法</li></ul><h4 id="抽象模型-3"><a href="#抽象模型-3" class="headerlink" title="抽象模型"></a>抽象模型</h4><p>当前位置开始<br>尝试切不同长度</p><h4 id="思考套路-4"><a href="#思考套路-4" class="headerlink" title="思考套路"></a>思考套路</h4><ul><li>从哪切？</li><li>切多长？</li><li>这一段是否合法？</li></ul><h4 id="模板-3"><a href="#模板-3" class="headerlink" title="模板"></a>模板</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start == len) &#123;<br>        保存结果;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (合法(start, i)) &#123;<br>            path.push(s[start..i]);<br>            dfs(i + <span class="hljs-number">1</span>);<br>            path.pop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> 分割类需要验证每段的合法性，如回文或有效IP段。</p><h2 id="三、回溯题要素"><a href="#三、回溯题要素" class="headerlink" title="三、回溯题要素"></a>三、回溯题要素</h2><ol><li><p><strong>一步要做什么决定？</strong><br>选哪个数？<br>往哪个方向走？<br>切多长？</p></li><li><p><strong>选择列表是什么？</strong><br>当前能选的所有可能</p></li><li><p><strong>什么时候结束？</strong><br>深度到头<br>条件满足</p></li><li><p><strong>如何回退？</strong><br>覆盖<br>pop<br>visited 还原</p></li></ol><p>回溯算法的核心在于通过递归探索所有可能的解决方案，并在不满足条件时回退。实践中，要注意剪枝优化，避免不必要的计算。</p><h2 id="四、回溯算法的剪枝优化"><a href="#四、回溯算法的剪枝优化" class="headerlink" title="四、回溯算法的剪枝优化"></a>四、回溯算法的剪枝优化</h2><h3 id="剪枝的基本概念"><a href="#剪枝的基本概念" class="headerlink" title="剪枝的基本概念"></a>剪枝的基本概念</h3><p><strong>如何剪枝：</strong> 通过在递归过程中添加条件判断，提前终止不可能成功的分支，从而减少搜索空间，提高效率。</p><p><strong>什么时候剪枝：</strong> 当当前状态或路径不可能达到目标条件时，进行剪枝。例如，当前和超过目标、剩余元素不足等。</p><h3 id="常见剪枝技巧分类讨论"><a href="#常见剪枝技巧分类讨论" class="headerlink" title="常见剪枝技巧分类讨论"></a>常见剪枝技巧分类讨论</h3><h4 id="1-排序去重剪枝"><a href="#1-排序去重剪枝" class="headerlink" title="1. 排序去重剪枝"></a>1. 排序去重剪枝</h4><ul><li><strong>适用题型：</strong> 组合类（Combination）、子集类（Subset）中含有重复元素的题目，如子集 II、组合总和 II。</li><li><strong>如何剪枝：</strong> 对候选数组进行排序，在选择元素时跳过与前一个相同的元素，避免生成重复结果。</li><li><strong>代码示例：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 在组合类中</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i<span class="hljs-number">-1</span>]) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 跳过重复</span><br>    <span class="hljs-comment">// 选择 i</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><strong>什么时候使用：</strong> 当题目允许重复选择但结果不能重复时。</li></ul><h4 id="2-限制条件剪枝"><a href="#2-限制条件剪枝" class="headerlink" title="2. 限制条件剪枝"></a>2. 限制条件剪枝</h4><ul><li><strong>适用题型：</strong> 组合总和类、背包问题变体。</li><li><strong>如何剪枝：</strong> 在递归中检查当前累积值（如和、积）是否超过限制，如果超过则提前返回。</li><li><strong>代码示例：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (currentSum &gt; target) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 组合总和</span><br></code></pre></td></tr></table></figure></li><li><strong>什么时候使用：</strong> 当有数值限制（如和不能超过目标）时。</li></ul><h4 id="3-长度限制剪枝"><a href="#3-长度限制剪枝" class="headerlink" title="3. 长度限制剪枝"></a>3. 长度限制剪枝</h4><ul><li><strong>适用题型：</strong> 组合类（指定组合长度）、排列类（部分排列）。</li><li><strong>如何剪枝：</strong> 计算剩余可选元素数量，如果不足以达到所需长度，则停止递归。</li><li><strong>代码示例：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n - i &lt; k - path.size()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// k 个数的组合</span><br></code></pre></td></tr></table></figure></li><li><strong>什么时候使用：</strong> 当组合或排列有固定长度要求时。</li></ul><h4 id="4-对称性剪枝"><a href="#4-对称性剪枝" class="headerlink" title="4. 对称性剪枝"></a>4. 对称性剪枝</h4><ul><li><strong>适用题型：</strong> N 皇后、其他对称性问题。</li><li><strong>如何剪枝：</strong> 利用问题的对称性，只搜索一半或四分之一的空间，然后通过对称生成另一半。</li><li><strong>代码示例：</strong> 在 N 皇后中，只考虑皇后放在左半边。</li><li><strong>什么时候使用：</strong> 当问题具有对称性，且结果可以通过对称变换得到时。</li></ul><h4 id="5-搜索类剪枝（路径-棋盘）"><a href="#5-搜索类剪枝（路径-棋盘）" class="headerlink" title="5. 搜索类剪枝（路径 &#x2F; 棋盘）"></a>5. 搜索类剪枝（路径 &#x2F; 棋盘）</h4><ul><li><strong>适用题型：</strong> 单词搜索、迷宫路径、数独。</li><li><strong>如何剪枝：</strong> 使用 visited 数组避免重复访问同一位置；边界检查；提前判断是否可能到达目标。</li><li><strong>代码示例：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= m || y &lt; <span class="hljs-number">0</span> || y &gt;= n || visited[x][y]) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><strong>什么时候使用：</strong> 在二维或多维空间搜索时，防止循环和无效路径。</li></ul><h4 id="6-分割类剪枝"><a href="#6-分割类剪枝" class="headerlink" title="6. 分割类剪枝"></a>6. 分割类剪枝</h4><ul><li><strong>适用题型：</strong> 回文串分割、IP 地址还原。</li><li><strong>如何剪枝：</strong> 在分割时，检查当前段是否合法（如是否为回文、有效IP段），不合法则跳过。</li><li><strong>代码示例：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!isPalindrome(s, start, i)) <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 回文分割</span><br></code></pre></td></tr></table></figure></li><li><strong>什么时候使用：</strong> 当分割后的每段必须满足特定条件时。</li></ul><h2 id="五、LeetCode-回溯算法实战合集"><a href="#五、LeetCode-回溯算法实战合集" class="headerlink" title="五、LeetCode 回溯算法实战合集"></a>五、LeetCode 回溯算法实战合集</h2><h3 id="1-分割-构造类"><a href="#1-分割-构造类" class="headerlink" title="1. 分割 &#x2F; 构造类"></a>1. 分割 &#x2F; 构造类</h3><p>这些问题涉及按某些特定条件对字符串、数字等进行切割或构造特定的结构。</p><h4 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a>131. 分割回文串</h4><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">LeetCode 131. 分割回文串</a></p><p><strong>核心方向：</strong>按回文条件切割字符串，枚举所有回文切割方案。</p><p><strong>回溯技巧：</strong>递归切割，每次递归检查子串是否为回文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯算法</span><br><span class="hljs-type">char</span>*** result;<br><span class="hljs-type">char</span>** path;<br><span class="hljs-type">int</span> pathSize = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 判断s字符串中的子串是否为回文串</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span> endIndex)</span>&#123;<br>    <span class="hljs-keyword">while</span>(startIndex &lt;= endIndex)&#123;<br>        <span class="hljs-keyword">if</span>(s[endIndex--] != s[startIndex++])&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">backtracking</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span> startIndex, <span class="hljs-type">int</span>** returnColumnSizes)</span>&#123;<br>    <span class="hljs-keyword">if</span>(startIndex == <span class="hljs-built_in">strlen</span>(s))&#123;<br>        result[*returnSize] = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) * pathSize);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pathSize; i++)&#123;<br>            result[*returnSize][i] = path[i]; <br>        &#125;<br>        (*returnColumnSizes)[(*returnSize)++] = pathSize;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = startIndex; i &lt; <span class="hljs-built_in">strlen</span>(s); i++)&#123;<br>        <span class="hljs-keyword">if</span>(isPalindrome(s, startIndex, i))&#123;<br>            <span class="hljs-type">char</span>* temp = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>) * (i - startIndex + <span class="hljs-number">2</span>));<br>            <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = startIndex; j &lt;= i; j++)&#123;<br>                temp[index++] = s[j];<br>            &#125;<br>            temp[index] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            path[pathSize++] = temp;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        backtracking(s, returnSize, i + <span class="hljs-number">1</span>, returnColumnSizes);<br>        <br>        pathSize--;<br>    &#125;<br>&#125;<br><span class="hljs-type">char</span>*** <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">char</span>* s, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span> &#123;<br>    result = (<span class="hljs-type">char</span>***)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>**) * <span class="hljs-number">100000</span>);<br>    path = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) * <span class="hljs-number">100000</span>);<br>    *returnColumnSizes = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100000</span>);<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    backtracking(s, returnSize, <span class="hljs-number">0</span>, returnColumnSizes);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a>22. 括号生成</h4><p><a href="https://leetcode.cn/problems/generate-parentheses/">LeetCode 22. 括号生成</a></p><p><strong>核心方向：</strong>生成所有合法的括号组合（左括号数 &#x3D; 右括号数）。</p><p><strong>回溯技巧：</strong>递归生成括号，剪枝（如左括号数 ≤ n、右括号数 ≤ 左括号数）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span>** res, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">char</span>* path, <span class="hljs-type">int</span> pos, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> n)</span> &#123;<br><br>    <span class="hljs-comment">// 终止条件：构造完成</span><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">2</span> * n) &#123;<br>        res[*returnSize] = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memcpy</span>(res[*returnSize], path, <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<br>        (*returnSize)++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试放 &#x27;(&#x27;</span><br>    <span class="hljs-keyword">if</span> (left &lt; n) &#123;<br>        path[pos] = <span class="hljs-string">&#x27;(&#x27;</span>;<br>        dfs(res, returnSize, path, pos + <span class="hljs-number">1</span>, left + <span class="hljs-number">1</span>, right, n);<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试放 &#x27;)&#x27;</span><br>    <span class="hljs-keyword">if</span> (right &lt; left) &#123;<br>        path[pos] = <span class="hljs-string">&#x27;)&#x27;</span>;<br>        dfs(res, returnSize, path, pos + <span class="hljs-number">1</span>, left, right + <span class="hljs-number">1</span>, n);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">char</span>** <span class="hljs-title function_">generateParenthesis</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span>** res = (<span class="hljs-type">char</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*) * <span class="hljs-number">1500</span>);<br>    <span class="hljs-type">char</span>* path = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>);<br>    path[<span class="hljs-number">2</span> * n] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>    dfs(res, returnSize, path, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n);<br>    <span class="hljs-built_in">free</span>(path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-路径-棋盘-搜索类"><a href="#2-路径-棋盘-搜索类" class="headerlink" title="2. 路径 &#x2F; 棋盘 &#x2F; 搜索类"></a>2. 路径 &#x2F; 棋盘 &#x2F; 搜索类</h3><p>这些问题通常涉及在二维或多维的空间中搜索路径。</p><h4 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a>79. 单词搜索</h4><p><a href="https://leetcode.cn/problems/word-search/">LeetCode 79. 单词搜索</a></p><p><strong>核心方向：</strong>在二维网格中搜索目标字符串的路径。</p><p><strong>回溯技巧：</strong>标记访问过的格子，避免重复走，剪枝（越界或字符不匹配时终止）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">backTracking</span><span class="hljs-params">(<span class="hljs-type">char</span>** board,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n,<span class="hljs-type">char</span>* word,<span class="hljs-type">int</span> size,<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">bool</span>* flag,<span class="hljs-type">int</span>** used)</span>&#123;<br>    <span class="hljs-keyword">if</span>(*flag) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(word[size]==<span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        *flag=<span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//这里要注意对row和col的越界判断应该放在最前面，否则无法后面的数组判定无法进行</span><br>    <span class="hljs-keyword">if</span> (row &lt; <span class="hljs-number">0</span> || row &gt;= m || col &lt; <span class="hljs-number">0</span> || col &gt;= n || board[row][col] != word[size] || used[row][col] == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    used[row][col]=<span class="hljs-number">1</span>;<br>    backTracking(board,m,n,word,size+<span class="hljs-number">1</span>,row+<span class="hljs-number">1</span>,col,flag,used);<br>    backTracking(board,m,n,word,size+<span class="hljs-number">1</span>,row<span class="hljs-number">-1</span>,col,flag,used);<br>    backTracking(board,m,n,word,size+<span class="hljs-number">1</span>,row,col+<span class="hljs-number">1</span>,flag,used);<br>    backTracking(board,m,n,word,size+<span class="hljs-number">1</span>,row,col<span class="hljs-number">-1</span>,flag,used);<br>    used[row][col]=<span class="hljs-number">0</span>;<br><br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-title function_">exist</span><span class="hljs-params">(<span class="hljs-type">char</span>** board, <span class="hljs-type">int</span> boardSize, <span class="hljs-type">int</span>* boardColSize, <span class="hljs-type">char</span>* word)</span> &#123;<br>    <span class="hljs-type">int</span> m=boardSize;<br>    <span class="hljs-type">int</span> n=boardColSize[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">bool</span> flag=<span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span>** used = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>(m * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>    used[i] = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-built_in">memset</span>(used[i], <span class="hljs-number">0</span>, n * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] == word[<span class="hljs-number">0</span>]) &#123;  <span class="hljs-comment">// 如果当前字符匹配，开始回溯</span><br>                backTracking(board, m, n, word, <span class="hljs-number">0</span>, i, j, &amp;flag, used);<br>                <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 找到匹配的单词</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-built_in">free</span>(used[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(used);<br><br>    <span class="hljs-keyword">return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-子集类"><a href="#3-子集类" class="headerlink" title="3. 子集类"></a>3. 子集类</h3><p>这些问题通常是枚举所有可能的子集，包含空集。</p><h4 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a>78. 子集</h4><p><a href="https://leetcode.cn/problems/subsets/">LeetCode 78. 子集</a></p><p><strong>核心方向：</strong>枚举一个集合的所有子集（包括空集）。</p><p><strong>回溯技巧：</strong>通过 start 参数控制选择顺序，避免重复子集。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.递归法（回溯）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> start,<span class="hljs-type">int</span>* path, <span class="hljs-type">int</span> pathSize,<span class="hljs-type">int</span>** res, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>* colSizes)</span> &#123;<br>    <span class="hljs-comment">// 保存当前子集</span><br>    res[*returnSize] = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * pathSize);<br>    <span class="hljs-built_in">memcpy</span>(res[*returnSize], path, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * pathSize);<br>    colSizes[*returnSize] = pathSize;<br>    (*returnSize)++;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; numsSize; i++) &#123;<br>        path[pathSize] = nums[i];<br>        dfs(nums, numsSize, i + <span class="hljs-number">1</span>, path, pathSize + <span class="hljs-number">1</span>, res, returnSize, colSizes);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span>** <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span> &#123;<br>    <span class="hljs-type">int</span> maxSize = <span class="hljs-number">1</span> &lt;&lt; numsSize;<br>    <span class="hljs-type">int</span>** res = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*) * maxSize);<br>    *returnColumnSizes = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * maxSize);<br><br>    <span class="hljs-type">int</span>* path = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * numsSize);<br>    *returnSize = <span class="hljs-number">0</span>;<br><br>    dfs(nums, numsSize, <span class="hljs-number">0</span>, path, <span class="hljs-number">0</span>, res, returnSize, *returnColumnSizes);<br><br>    <span class="hljs-built_in">free</span>(path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-排列类"><a href="#4-排列类" class="headerlink" title="4. 排列类"></a>4. 排列类</h3><p>这些问题涉及到元素的排列，通常要求考虑元素顺序。</p><h4 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a>46. 全排列</h4><p><a href="https://leetcode.cn/problems/permutations/">LeetCode 46. 全排列</a></p><p><strong>核心方向：</strong>枚举所有元素的排列。</p><p><strong>回溯技巧：</strong>标记已使用的元素，避免重复排列。处理重复元素时需要去重。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯算法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">void backtrack(当前状态, 其他参数) &#123;</span><br><span class="hljs-comment">    if (满足结束条件) &#123;</span><br><span class="hljs-comment">        记录结果;</span><br><span class="hljs-comment">        return;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    for (每个可能的选择) &#123;</span><br><span class="hljs-comment">        做出选择;           // 修改状态</span><br><span class="hljs-comment">        backtrack(新状态, ...); // 递归</span><br><span class="hljs-comment">        撤销选择;           // 恢复状态（关键！）</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">int</span> count;<br><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(<span class="hljs-type">int</span> *nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> depth, <span class="hljs-type">int</span> *path, <span class="hljs-type">bool</span> *used, <span class="hljs-type">int</span> **res)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> (depth == numsSize) &#123;<br>        res[count] = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * numsSize);<br>        <span class="hljs-built_in">memcpy</span>(res[count++], path, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * numsSize);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numsSize; i++) &#123;<br>        <span class="hljs-keyword">if</span> (used[i] == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        path[depth] = nums[i];<br>        used[i] = <span class="hljs-literal">true</span>;<br>        DFS(nums, numsSize, depth + <span class="hljs-number">1</span>, path, used, res);<br><br>        used[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span>** <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span>&#123;<br>    (*returnSize) = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= numsSize; i++) &#123;<br>        (*returnSize) *= i;<br>    &#125;<br><br>    *returnColumnSizes = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * (*returnSize));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; (*returnSize); i++) &#123;<br>        (*returnColumnSizes)[i] = numsSize;<br>    &#125;<br><br>    <span class="hljs-type">int</span> **res = (<span class="hljs-type">int</span> **)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span> *) * (*returnSize));<br>    <span class="hljs-type">int</span> *path = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * numsSize);<br>    <span class="hljs-type">bool</span> *used = (<span class="hljs-type">bool</span> *)<span class="hljs-built_in">calloc</span>(numsSize, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">bool</span>));<br><br>    count = <span class="hljs-number">0</span>;<br>    DFS(nums, numsSize, <span class="hljs-number">0</span>, path, used, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-组合类"><a href="#5-组合类" class="headerlink" title="5. 组合类"></a>5. 组合类</h3><p>这些问题通常涉及多个集合的组合或从一个集合中选择元素，可能会有条件限制（如总和、数量等）。</p><h4 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a>17. 电话号码的字母组合</h4><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">LeetCode 17. 电话号码的字母组合</a></p><p><strong>核心方向：</strong>多个数字对应字母集合，选一个字母组合。</p><p><strong>回溯技巧：</strong>每次递归选择一个字母，并递归继续选择下一个字母。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯 / DFS</span><br><span class="hljs-type">char</span> *<span class="hljs-built_in">map</span>[<span class="hljs-number">10</span>] = &#123;<br>    <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-string">&quot;def&quot;</span>, <span class="hljs-string">&quot;ghi&quot;</span>,<br>    <span class="hljs-string">&quot;jkl&quot;</span>, <span class="hljs-string">&quot;mno&quot;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>, <span class="hljs-string">&quot;tuv&quot;</span>, <span class="hljs-string">&quot;wxyz&quot;</span><br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span> *digits, <span class="hljs-type">int</span> idx, <span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> **res, <span class="hljs-type">int</span> *returnSize)</span> &#123;<br>    <span class="hljs-keyword">if</span> (digits[idx] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(path);<br>        res[*returnSize] = <span class="hljs-built_in">malloc</span>(len + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">memcpy</span>(res[*returnSize], path, len + <span class="hljs-number">1</span>);  <br>        (*returnSize)++;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span> *letters = <span class="hljs-built_in">map</span>[digits[idx] - <span class="hljs-string">&#x27;0&#x27;</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; letters[i]; i++) &#123;<br>        path[idx] = letters[i];<br>        path[idx + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        dfs(digits, idx + <span class="hljs-number">1</span>, path, res, returnSize);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">char</span> **<span class="hljs-title function_">letterCombinations</span><span class="hljs-params">(<span class="hljs-type">char</span> *digits, <span class="hljs-type">int</span> *returnSize)</span> &#123;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (!digits || !digits[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(digits);<br>    <span class="hljs-type">char</span> **res = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span> *) * <span class="hljs-number">256</span>);<br>    <span class="hljs-type">char</span> path[len + <span class="hljs-number">1</span>];<br><br>    dfs(digits, <span class="hljs-number">0</span>, path, res, returnSize);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a>39. 组合总和</h4><p><a href="https://leetcode.cn/problems/combination-sum/">LeetCode 39. 组合总和</a></p><p><strong>核心方向：</strong>从数组中选元素，使其和为目标值，允许重复选择。</p><p><strong>回溯技巧：</strong>递归选择，控制选择范围，剪枝（如果和超过目标值，则提前停止递归）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//1.回溯递归</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>* candidates, <span class="hljs-type">int</span> candidatesSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>* path, <span class="hljs-type">int</span>* returnColumnSizes, <span class="hljs-type">int</span> pathSize, <span class="hljs-type">int</span>** res, <span class="hljs-type">int</span> start)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 找到一个满足条件的组合</span><br>        res[*returnSize] = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * pathSize);<br>        <span class="hljs-built_in">memcpy</span>(res[*returnSize], path, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * pathSize);<br>        returnColumnSizes[*returnSize] = pathSize;  <span class="hljs-comment">// 记录当前组合的大小</span><br>        (*returnSize)++;  <span class="hljs-comment">// 更新组合数量</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (target &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 剪枝：当 target 小于 0 时，当前路径无效</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i &lt; candidatesSize; i++) &#123;<br>        path[pathSize] = candidates[i];  <span class="hljs-comment">// 选择当前候选数</span><br>        <span class="hljs-comment">// 递归，允许同一个数字多次选择，因此 start 还是从 i 开始</span><br>        dfs(candidates, candidatesSize, target - candidates[i], returnSize, path, returnColumnSizes, pathSize + <span class="hljs-number">1</span>, res, i);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span>** <span class="hljs-title function_">combinationSum</span><span class="hljs-params">(<span class="hljs-type">int</span>* candidates, <span class="hljs-type">int</span> candidatesSize, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span>* returnSize, <span class="hljs-type">int</span>** returnColumnSizes)</span> &#123;<br>    *returnSize = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span>** res = (<span class="hljs-type">int</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>*) * <span class="hljs-number">150</span>);<br>    <span class="hljs-type">int</span>* path = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) *<span class="hljs-number">50</span>);<br>    *returnColumnSizes = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">150</span>);<br><br>    dfs(candidates, candidatesSize, target, returnSize, path, *returnColumnSizes, <span class="hljs-number">0</span>, res, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-built_in">free</span>(path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>回溯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树系列之递归</title>
    <link href="/2026/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <url>/2026/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>首先我们需要知道，二叉树非常适合递归处理，因为二叉树本身就是递归定义的：</p><ul><li>每个节点最多有两个子节点（左子树、右子树）</li><li>每个子树本身又是一棵二叉树</li><li>空树也是二叉树的一种情况（递归的终止条件）</li></ul><p>此外，二叉树问题可以自然地分解为处理该节点与其左右子树的问题</p><p>递归问题需要注意以下三点：</p><ul><li><strong>递归终止条件</strong>：什么时候停止递归</li><li><strong>递归逻辑</strong>：如何处理当前节点</li><li><strong>返回值</strong>：向上一层返回什么</li></ul><p>接下来我会列出一些我自己在写力扣的时候遇到的部分题目</p><hr><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">LeetCode 94. 二叉树的中序遍历</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序遍历</strong> </p><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>中序遍历的顺序是：左子树 → 根节点 → 右子树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root,<span class="hljs-type">int</span>* num,<span class="hljs-type">int</span>* ret)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span>;<br>    inorder(root-&gt;left,num,ret);<br>    ret[(*num)++]=root-&gt;val;<br>    inorder(root-&gt;right,num,ret);    <br>&#125;<br><span class="hljs-type">int</span>* <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* returnSize)</span> &#123;<br>    <span class="hljs-type">int</span> *re =(<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">501</span>);<br>    *returnSize = <span class="hljs-number">0</span>;<br>    inorder(root,returnSize,re);<br>    <span class="hljs-keyword">return</span> re;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一点我一开始没注意，就是传入的 <code>returnSize</code> 其实是一个指针，在使用<code>inorder</code>函数时不需要 &amp; 符号，直接传入 <code>returnSize</code> 即可</p><hr><h2 id="二叉搜索树中第K小的元素"><a href="#二叉搜索树中第K小的元素" class="headerlink" title="二叉搜索树中第K小的元素"></a>二叉搜索树中第K小的元素</h2><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">LeetCode 230. 二叉搜索树中第K小的元素</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小的元素</p><h3 id="递归思路-1"><a href="#递归思路-1" class="headerlink" title="递归思路"></a>递归思路</h3><p>利用BST中序遍历有序性，递减k计数，提前返回进行优化</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">kFind</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span>* k, <span class="hljs-type">int</span>* result)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span> || *k == <span class="hljs-number">0</span>)<span class="hljs-comment">//方便提前返回</span><br>        <span class="hljs-keyword">return</span>;<br>    <br>    kFind(root-&gt;left, k, result);<br>    <br>    (*k)--;<br>    <span class="hljs-keyword">if</span>(*k == <span class="hljs-number">0</span>)&#123;<br>        *result = root-&gt;val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    kFind(root-&gt;right, k, result);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">kthSmallest</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">-1</span>;<br>    kFind(root, &amp;k, &amp;result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里在<code>kFind</code>函数中增加了一个提前返回的条件，当<code>*k == 0</code>时，说明已经找到了第k小的元素，可以直接返回，避免不必要的递归调用</p><hr><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">LeetCode 101. 对称二叉树</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称</p><h3 id="递归思路-2"><a href="#递归思路-2" class="headerlink" title="递归思路"></a>递归思路</h3><p>递归判断镜像，左子树的左孩子与右子树的右孩子对比</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isMirror</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* left, <span class="hljs-keyword">struct</span> TreeNode* right)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!left&amp;&amp;!right)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span>(!left||!right)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(left-&gt;val!=right-&gt;val)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> isMirror(left-&gt;left,right-&gt;right)&amp;&amp;isMirror(left-&gt;right,right-&gt;left);<br>&#125; <br><span class="hljs-type">bool</span> <span class="hljs-title function_">isSymmetric</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span> isMirror(root-&gt;left,root-&gt;right);<br>&#125;<br></code></pre></td></tr></table></figure><p>本题的思路还与一题判断两颗二叉树是否相同类似，不过那一题在递归传递参数时传递的是<code>root1</code>的左和<code>root2</code>的左，而本题传递的是<code>root</code>的左和<code>root</code>的右</p><hr><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">LeetCode 104. 二叉树的最大深度</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回其最大深度</p><h3 id="递归思路-3"><a href="#递归思路-3" class="headerlink" title="递归思路"></a>递归思路</h3><p>自底向上递归，<code>depth = max(leftDepth, rightDepth) + 1</code></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> lmax = maxDepth(root-&gt;left);<br>    <span class="hljs-type">int</span> rmax = maxDepth(root-&gt;right);<br>    <span class="hljs-keyword">return</span>(lmax&gt;rmax?lmax:rmax)+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>本题是典型的自底向上递归，先计算左右子树的最大深度，然后取较大值加一返回</p><hr><h2 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h2><p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">LeetCode 543. 二叉树的直径</a></p><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一棵二叉树，你需要计算它的直径长度。二叉树的直径长度是任意两个节点路径长度中的最大值。这条路径可能穿过根节点</p><h3 id="递归思路-4"><a href="#递归思路-4" class="headerlink" title="递归思路"></a>递归思路</h3><p>通过递归计算二叉树的最大深度，同时更新树的直径（即任意两个节点之间的最长路径）,最大深度函数返回左右子树深度的较大值，并更新全局最大路径值</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">maxDepth</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root,<span class="hljs-type">int</span>* maxl)</span>&#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> lmax=maxDepth(root-&gt;left,maxl);<br>    <span class="hljs-type">int</span> rmax=maxDepth(root-&gt;right,maxl);<br>    *maxl=fmax(*maxl,lmax+rmax);<br>    <span class="hljs-keyword">return</span> fmax(lmax,rmax)+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">diameterOfBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxl=<span class="hljs-number">0</span>;<br>    maxDepth(root,&amp;maxl);<br>    <span class="hljs-keyword">return</span> maxl;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>maxDepth</code>函数中，我们计算左右子树的深度，并更新<code>*maxl</code>为当前的最大直径。最终在<code>diameterOfBinaryTree</code>函数中返回这个最大直径值</p><hr><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">LeetCode 226. 翻转二叉树</a></p><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点</p><h3 id="递归思路-5"><a href="#递归思路-5" class="headerlink" title="递归思路"></a>递归思路</h3><p>递归交换每个节点的左右子节点</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">invertTree</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">temp</span> =</span> root-&gt;left;<br>    root-&gt;left = root-&gt;right;<br>    root-&gt;right = temp;<br>    <br>    invertTree(root-&gt;left);<br>    invertTree(root-&gt;right);<br>    <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><p>交换当前节点的左右子节点，接着递归调用<code>invertTree</code>函数来翻转左右子树,最后返回翻转后的根节点</p><hr><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">LeetCode 236. 二叉树的最近公共祖先</a></p><h3 id="问题描述-6"><a href="#问题描述-6" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先节点</p><h3 id="递归思路-6"><a href="#递归思路-6" class="headerlink" title="递归思路"></a>递归思路</h3><p>递归遍历树，判断当前节点是否为p或q，若是则返回当前节点，否则递归左右子树，若左右子树均返回非空节点，则当前节点即为最近公共祖先</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> TreeNode* <span class="hljs-title function_">lowestCommonAncestor</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-keyword">struct</span> TreeNode* p, <span class="hljs-keyword">struct</span> TreeNode* q)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span> || root == p || root == q) &#123;<br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 找到 p 或 q 就不往下递归了</span><br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">left</span> =</span> lowestCommonAncestor(root-&gt;left, p, q);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">right</span> =</span> lowestCommonAncestor(root-&gt;right, p, q);<br>    <span class="hljs-keyword">if</span> (left &amp;&amp; right) &#123; <span class="hljs-comment">// 左右都找到</span><br>        <span class="hljs-keyword">return</span> root; <span class="hljs-comment">// 当前节点是最近公共祖先</span><br>    &#125;<br>    <span class="hljs-comment">// 如果只有左子树找到，就返回左子树的返回值</span><br>    <span class="hljs-comment">// 如果只有右子树找到，就返回右子树的返回值</span><br>    <span class="hljs-comment">// 如果左右子树都没有找到，就返回 NULL（注意此时 right = NULL）</span><br>    <span class="hljs-keyword">return</span> left ? left : right;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的关键在于递归返回值的处理，通过判断左右子树的返回值来确定当前节点是否为最近公共祖先，像本题我们就要注意是后序遍历，因为这里我们需要左右子树的结果来决定当前节点的返回值</p><hr><h2 id="二叉树展开为链表"><a href="#二叉树展开为链表" class="headerlink" title="二叉树展开为链表"></a>二叉树展开为链表</h2><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">LeetCode 114. 二叉树展开为链表</a></p><h3 id="问题描述-7"><a href="#问题描述-7" class="headerlink" title="问题描述"></a>问题描述</h3><p>给你二叉树的根节点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个节点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 先序遍历顺序相同。</li></ul><h3 id="递归思路-7"><a href="#递归思路-7" class="headerlink" title="递归思路"></a>递归思路</h3><p>本题要求与先序遍历顺序相同，这里可以采用头插法，按照先序的逆序（右-左-根）来处理节点，即先处理右子树，再处理左子树，这样在构建链表时就能保证顺序正确</p><h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* node, <span class="hljs-keyword">struct</span> TreeNode** head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(node-&gt;right, head);<br>    dfs(node-&gt;left, head);<br>    node-&gt;left = <span class="hljs-literal">NULL</span>;<br>    node-&gt;right = *head; <span class="hljs-comment">// 头插法，相当于链表的 node-&gt;next = head</span><br>    *head = node; <span class="hljs-comment">// 现在链表头节点是 node</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">flatten</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>* <span class="hljs-title">head</span> =</span> <span class="hljs-literal">NULL</span>;<br>    dfs(root, &amp;head);<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>dfs</code>函数中，我们先递归处理右子树，再处理左子树，这样可以确保我们按照先序遍历的顺序构建链表，通过头插法，我们将当前节点的右指针指向链表的头节点，并更新头节点为当前节点，最终实现了二叉树的展开为链表</p><hr><h2 id="深入理解：二叉树递归顺序的选择"><a href="#深入理解：二叉树递归顺序的选择" class="headerlink" title="深入理解：二叉树递归顺序的选择"></a>深入理解：二叉树递归顺序的选择</h2><h3 id="一、核心本质：二叉树递归-在”什么时候”处理当前节点"><a href="#一、核心本质：二叉树递归-在”什么时候”处理当前节点" class="headerlink" title="一、核心本质：二叉树递归 &#x3D; 在”什么时候”处理当前节点"></a>一、核心本质：二叉树递归 &#x3D; 在”什么时候”处理当前节点</h3><p>任何二叉树递归，本质都是这三步的排列组合：</p><ul><li><code>dfs(node-&gt;left);</code></li><li><code>处理当前节点;</code></li><li><code>dfs(node-&gt;right);</code></li></ul><p>不同的递归顺序，本质区别在于：<strong>你希望在什么时候处理当前节点</strong></p><table><thead><tr><th>递归顺序</th><th>处理节点的时机</th><th>本质含义</th></tr></thead><tbody><tr><td>前序</td><td>先处理自己，再处理子树</td><td>自顶向下</td></tr><tr><td>中序</td><td>左子树后、右子树前</td><td>与结构强相关</td></tr><tr><td>后序</td><td>子树都处理完再处理自己</td><td>自底向上</td></tr></tbody></table><hr><h3 id="二、不同递归顺序一般对应什么题目？"><a href="#二、不同递归顺序一般对应什么题目？" class="headerlink" title="二、不同递归顺序一般对应什么题目？"></a>二、不同递归顺序一般对应什么题目？</h3><h4 id="①-前序遍历（根-→-左-→-右）"><a href="#①-前序遍历（根-→-左-→-右）" class="headerlink" title="① 前序遍历（根 → 左 → 右）"></a>① 前序遍历（根 → 左 → 右）</h4><p><strong>特点</strong>：先用当前节点的信息，再递归子树</p><p><strong>适合的题目类型</strong></p><p>“当前节点会影响子节点” 的问题</p><p><strong>典型特征</strong>：</p><ul><li>父节点的信息要传递给子节点</li><li>路径类问题</li><li>从根向下的构造、记录、判断</li></ul><p><strong>常见题目</strong></p><ul><li>路径和（Path Sum）</li><li>根到叶子的路径</li><li>验证 BST（携带 min&#x2F;max）</li><li>树的序列化</li><li>建树（根据遍历）</li></ul><p><strong>思维模板</strong></p><p>“我要先知道当前节点是什么，再决定怎么走下去”</p><hr><h4 id="②-中序遍历（左-→-根-→-右）"><a href="#②-中序遍历（左-→-根-→-右）" class="headerlink" title="② 中序遍历（左 → 根 → 右）"></a>② 中序遍历（左 → 根 → 右）</h4><p><strong>特点</strong>：节点处理夹在左右之间</p><p><strong>适合的题目类型</strong></p><p>和”顺序””结构”强相关的题目，尤其是 BST（搜索二叉树）</p><p><strong>常见题目</strong></p><ul><li>验证 BST（中序是否有序）</li><li>BST 转数组</li><li>第 k 小元素</li><li>BST 相关统计</li></ul><p><strong>思维模板</strong></p><p>“左边处理完，当前节点才有意义”</p><hr><h4 id="③-后序遍历（左-→-右-→-根）"><a href="#③-后序遍历（左-→-右-→-根）" class="headerlink" title="③ 后序遍历（左 → 右 → 根）"></a>③ 后序遍历（左 → 右 → 根）</h4><p><strong>特点</strong>：先拿到子树结果，再处理当前节点</p><p><strong>适合的题目类型</strong></p><p>“当前节点的结果依赖子树”</p><p><strong>常见题目</strong></p><ul><li>最大深度 &#x2F; 最小深度</li><li>直径</li><li>是否平衡二叉树</li><li>最大路径和</li><li>翻转 &#x2F; 删除 &#x2F; 合并子树</li><li>flatten（二叉树展开）</li></ul><p><strong>思维模板</strong></p><p>“我得先知道左右子树情况，才能算我自己”</p><hr><h3 id="三、核心判断技巧：三问法"><a href="#三、核心判断技巧：三问法" class="headerlink" title="三、核心判断技巧：三问法"></a>三、核心判断技巧：三问法</h3><p>看到一个二叉树递归题，先别写代码，先问自己这三个问题：</p><h4 id="问题-1：当前节点的结果，依赖谁？"><a href="#问题-1：当前节点的结果，依赖谁？" class="headerlink" title="问题 1：当前节点的结果，依赖谁？"></a>问题 1：当前节点的结果，依赖谁？</h4><table><thead><tr><th>依赖对象</th><th>选择顺序</th></tr></thead><tbody><tr><td>依赖父节点</td><td>前序</td></tr><tr><td>依赖左右子树</td><td>后序</td></tr><tr><td>依赖结构顺序</td><td>中序</td></tr></tbody></table><h4 id="问题-2：是”向下传信息”，还是”向上汇总信息”？"><a href="#问题-2：是”向下传信息”，还是”向上汇总信息”？" class="headerlink" title="问题 2：是”向下传信息”，还是”向上汇总信息”？"></a>问题 2：是”向下传信息”，还是”向上汇总信息”？</h4><table><thead><tr><th>信息流方向</th><th>顺序</th></tr></thead><tbody><tr><td>从根到叶子</td><td>前序</td></tr><tr><td>从叶子到根</td><td>后序</td></tr></tbody></table><h4 id="问题-3：递归函数”返回值”代表什么？"><a href="#问题-3：递归函数”返回值”代表什么？" class="headerlink" title="问题 3：递归函数”返回值”代表什么？"></a>问题 3：递归函数”返回值”代表什么？</h4><p>这是决定后序遍历的最重要信号</p><p><strong>如果递归函数有明确的返回值含义，且这个返回值用于父节点计算</strong></p><p><strong>大概率是后序遍历</strong></p><hr><h3 id="四、总结要点"><a href="#四、总结要点" class="headerlink" title="四、总结要点"></a>四、总结要点</h3><ol><li><strong>前序 &#x3D; 自顶向下传递信息</strong>（父节点影响子节点）</li><li><strong>中序 &#x3D; BST 相关</strong>（利用中序遍历的有序性）</li><li><strong>后序 &#x3D; 自底向上汇总信息</strong>（子树结果影响父节点）</li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>二叉树</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表系列之递归</title>
    <link href="/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/"/>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h2 id="递归的本质"><a href="#递归的本质" class="headerlink" title="递归的本质"></a>递归的本质</h2><p>递归是一种将大问题分解为相同结构小问题的编程技巧</p><p>在链表中，递归特别适用，因为链表本身就是递归定义的：</p><ul><li>链表 &#x3D; 头节点 + 剩余链表</li><li>剩余链表 &#x3D; 头节点 + 剩余链表</li><li>…直到空节点</li></ul><p>递归解决链表问题的核心三要素：</p><ol><li><strong>递归终止条件</strong>：什么时候停止递归</li><li><strong>递归逻辑</strong>：如何处理当前节点</li><li><strong>返回值</strong>：向上一层返回什么</li></ol><hr><h2 id="入门篇：反转链表"><a href="#入门篇：反转链表" class="headerlink" title="入门篇：反转链表"></a>入门篇：反转链表</h2><p><a href="https://leetcode.cn/problems/reverse-linked-list/">LeetCode 206. 反转链表</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，反转整个链表并返回新的头节点</p><h3 id="递归思路"><a href="#递归思路" class="headerlink" title="递归思路"></a>递归思路</h3><p>假设链表为：1 → 2 → 3 → 4 → 5</p><p>递归的思考方式：</p><ol><li>先递归反转 2 → 3 → 4 → 5，得到 5 → 4 → 3 → 2</li><li>然后处理节点1，让2的next指向1</li><li>将1的next设为NULL</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">newHead</span> =</span> reverseList(head-&gt;next);<br>    head-&gt;next-&gt;next = head;<br>    head-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解"><a href="#递归过程图解" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs isbl">原链表：<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-variable"><span class="hljs-literal">NULL</span></span><br><br>递归栈：<br>第<span class="hljs-number">1</span>层：<span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-number">1</span>) </span><br><span class="hljs-function">第<span class="hljs-number">2</span>层：  <span class="hljs-title">reverseList</span>(<span class="hljs-number">2</span>)</span><br>第<span class="hljs-number">3</span>层：    <span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-number">3</span>)</span><br>第<span class="hljs-number">4</span>层：      <span class="hljs-function"><span class="hljs-title">reverseList</span>(<span class="hljs-variable"><span class="hljs-literal">NULL</span></span>) → 返回<span class="hljs-number">3</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">回溯过程：</span><br><span class="hljs-function">第<span class="hljs-number">3</span>层：<span class="hljs-number">3</span>已反转，处理<span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-number">2</span>，<span class="hljs-number">2</span>.next = <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br><span class="hljs-function">       返回<span class="hljs-number">3</span></span><br><span class="hljs-function">第<span class="hljs-number">2</span>层：<span class="hljs-number">3</span> → <span class="hljs-number">2</span>已反转，处理<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span>，<span class="hljs-number">1</span>.next = <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br><span class="hljs-function">       返回<span class="hljs-number">3</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">最终：<span class="hljs-number">3</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span> → <span class="hljs-variable"><span class="hljs-literal">NULL</span></span></span><br></code></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：head为空或head-&gt;next为空</li><li>核心操作：<code>head-&gt;next-&gt;next = head</code>（让下一个节点指向当前节点）</li><li>断开原连接：<code>head-&gt;next = NULL</code>（避免成环）</li><li>返回值：新的头节点（始终是原链表的尾节点）</li></ul><hr><h2 id="进阶篇一：合并两个有序链表"><a href="#进阶篇一：合并两个有序链表" class="headerlink" title="进阶篇一：合并两个有序链表"></a>进阶篇一：合并两个有序链表</h2><p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">LeetCode 21. 合并两个有序链表</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>将两个升序链表合并为一个新的升序链表</p><h3 id="递归思路-1"><a href="#递归思路-1" class="headerlink" title="递归思路"></a>递归思路</h3><p>每次选择两个链表中较小的头节点，然后递归处理剩余部分</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* list1, <span class="hljs-keyword">struct</span> ListNode* list2)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!list1) <span class="hljs-keyword">return</span> list2;<br>    <span class="hljs-keyword">if</span> (!list2) <span class="hljs-keyword">return</span> list1;<br>    <br>    <span class="hljs-keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;<br>        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程示例"><a href="#递归过程示例" class="headerlink" title="递归过程示例"></a>递归过程示例</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">list1:<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 3 </span>→ 5<br>list2:<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 4 </span>→ 6<br><br>第1层：比较1和2，选1，递归merge(3→5, 2→4→6)<br>第2层：比较3和2，选2，递归merge(3→5, 4→6)<br>第3层：比较3和4，选3，递归merge(5, 4→6)<br>第4层：比较5和4，选4，递归merge(5, 6)<br>第5层：比较5和6，选5，递归merge(NULL, 6)<br>第6层：返回6<br><br>回溯构建：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→<span class="hljs-number"> 4 </span>→<span class="hljs-number"> 5 </span>→ 6<br></code></pre></td></tr></table></figure><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：任一链表为空，返回另一个链表</li><li>递归逻辑：选择较小的节点，将其next指向递归结果</li><li>时间复杂度：O(m+n)</li><li>空间复杂度：O(m+n)（递归栈深度）</li></ul><hr><h2 id="进阶篇二：两两交换链表节点"><a href="#进阶篇二：两两交换链表节点" class="headerlink" title="进阶篇二：两两交换链表节点"></a>进阶篇二：两两交换链表节点</h2><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">LeetCode 24. 两两交换链表中的节点</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，两两交换其中相邻的节点</p><p>例如：1 → 2 → 3 → 4 变为 2 → 1 → 4 → 3</p><h3 id="递归思路-2"><a href="#递归思路-2" class="headerlink" title="递归思路"></a>递归思路</h3><ol><li>递归处理后续节点（从第3个节点开始）</li><li>交换当前的两个节点</li><li>返回新的头节点</li></ol><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(!head || !head-&gt;next)<br>        <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span> =</span> head-&gt;next;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span> =</span> next-&gt;next;<br>    <br>    next-&gt;next = cur;<br>    cur-&gt;next = swapPairs(tmp);<br>    <br>    <span class="hljs-keyword">return</span> next;  <span class="hljs-comment">// 新的头节点</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解-1"><a href="#递归过程图解-1" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">原链表：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→ 4<br><br>第1层：处理1和2<br>       递归处理3 → 4<br>第2层：处理3和4<br>       递归处理NULL<br>       返回4<br>       <br>回溯：<br>第2层：交换3和4，返回<span class="hljs-number"> 4 </span>→ 3<br>第1层：交换1和2，连接返回结果<br>      <span class="hljs-number"> 2 </span>→<span class="hljs-number"> 1 </span>→ (4 → 3)<br>       返回2<br><br>最终：2 →<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 4 </span>→ 3<br></code></pre></td></tr></table></figure><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul><li>终止条件：节点为空或只剩一个节点</li><li>保存三个关键指针：cur、next、tmp</li><li>返回值：交换后的新头节点（原来的第二个节点）</li></ul><hr><h2 id="高级篇一：K个一组翻转链表"><a href="#高级篇一：K个一组翻转链表" class="headerlink" title="高级篇一：K个一组翻转链表"></a>高级篇一：K个一组翻转链表</h2><p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">LeetCode 25. K 个一组翻转链表</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，每k个节点一组进行翻转</p><p>例如：1 → 2 → 3 → 4 → 5，k&#x3D;2<br>结果：2 → 1 → 4 → 3 → 5</p><h3 id="递归思路-3"><a href="#递归思路-3" class="headerlink" title="递归思路"></a>递归思路</h3><ol><li>检查是否有k个节点</li><li>如果有，翻转前k个节点</li><li>递归处理剩余部分</li><li>连接翻转后的部分和递归结果</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 检查是否有k个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">p</span> =</span> head;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!p) <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">// 不足k个，直接返回head</span><br>        p = p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 翻转前k个节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">q</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">pre</span> =</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span>(q != p) &#123;  <span class="hljs-comment">// 翻转从head到p的前k个节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">tmp</span> =</span> q-&gt;next;<br>        q-&gt;next = pre;<br>        pre = q;<br>        q = tmp;<br>    &#125;<br><br>    head-&gt;next = reverseKGroup(p, k);<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程示例-1"><a href="#递归过程示例-1" class="headerlink" title="递归过程示例"></a>递归过程示例</h3><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tap">原链表：1 →<span class="hljs-number"> 2 </span>→<span class="hljs-number"> 3 </span>→<span class="hljs-number"> 4 </span>→ 5，k=2<br><br>第1层：检查1,2存在<br>       翻转1,2 得到<span class="hljs-number"> 2 </span>→ 1<br>       递归处理3 →<span class="hljs-number"> 4 </span>→ 5<br>       <br>第2层：检查3,4存在<br>       翻转3,4 得到<span class="hljs-number"> 4 </span>→ 3<br>       递归处理5<br>       <br>第3层：检查5后不足2个<br>       直接返回5<br><br>回溯连接：<br>第2层：4 →<span class="hljs-number"> 3 </span>→ 5，返回4<br>第1层：2 →<span class="hljs-number"> 1 </span>→ (4 →<span class="hljs-number"> 3 </span>→ 5)，返回2<br><br>最终：2 →<span class="hljs-number"> 1 </span>→<span class="hljs-number"> 4 </span>→<span class="hljs-number"> 3 </span>→ 5<br></code></pre></td></tr></table></figure><h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul><li>先检查是否有足够的节点</li><li>翻转逻辑与普通反转链表相同</li><li>递归处理剩余部分</li><li>head变成了翻转后这组的尾节点</li></ul><hr><h2 id="高级篇二：排序链表（归并排序）"><a href="#高级篇二：排序链表（归并排序）" class="headerlink" title="高级篇二：排序链表（归并排序）"></a>高级篇二：排序链表（归并排序）</h2><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148. 排序链表</a></p><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>对链表进行排序，要求时间复杂度O(n log n)</p><h3 id="递归思路（分治法）"><a href="#递归思路（分治法）" class="headerlink" title="递归思路（分治法）"></a>递归思路（分治法）</h3><p>归并排序的经典应用：</p><ol><li>找到链表中点（快慢指针）</li><li>递归排序左半部分</li><li>递归排序右半部分</li><li>合并两个有序链表</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 找到链表中间节点</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span> =</span> head-&gt;next;<br>    <br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span> =</span> &amp;dummy;<br>    dummy.next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>            tail-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        tail = tail-&gt;next;<br>    &#125;<br>    <br>    tail-&gt;next = l1 ? l1 : l2;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">// 递归归并排序主函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">sortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件：空链表或单节点</span><br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 找到中间节点并分割</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">mid</span> =</span> findMiddle(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">right</span> =</span> mid-&gt;next;<br>    mid-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 切断链表</span><br>    <br>    <span class="hljs-comment">// 2. 递归排序左右两部分</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">leftSorted</span> =</span> sortList(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rightSorted</span> =</span> sortList(right);<br>    <br>    <span class="hljs-comment">// 3. 合并有序链表</span><br>    <span class="hljs-keyword">return</span> merge(leftSorted, rightSorted);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递归过程图解-2"><a href="#递归过程图解-2" class="headerlink" title="递归过程图解"></a>递归过程图解</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">原链表：<span class="hljs-number">4</span> → <span class="hljs-number">2</span> → <span class="hljs-number">1</span> → <span class="hljs-number">3</span><br><br>分割阶段：<br>层<span class="hljs-number">1</span>：<span class="hljs-selector-attr">[4,2,1,3]</span> → <span class="hljs-selector-attr">[4,2]</span> 和 <span class="hljs-selector-attr">[1,3]</span><br>层<span class="hljs-number">2</span>：<span class="hljs-selector-attr">[4,2]</span> → <span class="hljs-selector-attr">[4]</span> 和 <span class="hljs-selector-attr">[2]</span><br>     <span class="hljs-selector-attr">[1,3]</span> → <span class="hljs-selector-attr">[1]</span> 和 <span class="hljs-selector-attr">[3]</span><br><br>合并阶段：<br>层<span class="hljs-number">2</span>：<span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[4]</span>, <span class="hljs-selector-attr">[2]</span>) → <span class="hljs-selector-attr">[2,4]</span><br>     <span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[1]</span>, <span class="hljs-selector-attr">[3]</span>) → <span class="hljs-selector-attr">[1,3]</span><br>层<span class="hljs-number">1</span>：<span class="hljs-built_in">merge</span>(<span class="hljs-selector-attr">[2,4]</span>, <span class="hljs-selector-attr">[1,3]</span>) → <span class="hljs-selector-attr">[1,2,3,4]</span><br><br>最终：<span class="hljs-number">1</span> → <span class="hljs-number">2</span> → <span class="hljs-number">3</span> → <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul><li>分治思想：分割、递归、合并</li><li>快慢指针找中点</li><li>切断链表很重要（mid-&gt;next &#x3D; NULL）</li><li>时间复杂度：O(n log n)</li><li>空间复杂度：O(log n)（递归栈）</li></ul><hr><h2 id="高级篇三：复制带随机指针的链表"><a href="#高级篇三：复制带随机指针的链表" class="headerlink" title="高级篇三：复制带随机指针的链表"></a>高级篇三：复制带随机指针的链表</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">LeetCode 138. 随机链表的复制</a></p><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>复制一个特殊的链表，每个节点除了next指针，还有一个random指针指向链表中的任意节点或null</p><h3 id="递归思路-4"><a href="#递归思路-4" class="headerlink" title="递归思路"></a>递归思路</h3><p>使用哈希表缓存已复制的节点，递归复制next和random</p><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">key</span>, *<span class="hljs-title">val</span>;</span><br>    UT_hash_handle hh;<br>&#125; * cachedNode;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashTable</span>* <span class="hljs-title">tmp</span>;</span><br>    HASH_FIND_PTR(cachedNode, &amp;head, tmp);<br>    <br>    <span class="hljs-keyword">if</span> (tmp == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 创建新节点</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>* <span class="hljs-title">headNew</span> =</span> <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> Node));<br>        headNew-&gt;val = head-&gt;val;<br>        <br>        <span class="hljs-comment">// 加入哈希表</span><br>        tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> HashTable));<br>        tmp-&gt;key = head;<br>        tmp-&gt;val = headNew;<br>        HASH_ADD_PTR(cachedNode, key, tmp);<br>        <br>        <span class="hljs-comment">// 递归复制next和random</span><br>        headNew-&gt;next = deepCopy(head-&gt;next);<br>        headNew-&gt;random = deepCopy(head-&gt;random);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> tmp-&gt;val;<br>&#125;<br><br><span class="hljs-keyword">struct</span> Node* <span class="hljs-title function_">copyRandomList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Node* head)</span> &#123;<br>    cachedNode = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> deepCopy(head);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-5"><a href="#关键点-5" class="headerlink" title="关键点"></a>关键点</h3><ul><li>使用哈希表避免重复复制同一个节点</li><li>先复制当前节点，再递归复制next和random</li><li>哈希表的key是原节点，value是新节点</li><li>递归可能会形成环，哈希表防止无限递归</li></ul><hr><h2 id="递归核心总结"><a href="#递归核心总结" class="headerlink" title="递归核心总结"></a>递归核心总结</h2><h3 id="递归三要素"><a href="#递归三要素" class="headerlink" title="递归三要素"></a>递归三要素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">ReturnType <span class="hljs-title function_">recursive</span><span class="hljs-params">(Node* head)</span> &#123;<br>    <span class="hljs-comment">// 1. 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (终止条件) &#123;<br>        <span class="hljs-keyword">return</span> 终止值;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 递归调用</span><br>    ReturnType result = recursive(下一个节点);<br>    <br>    <span class="hljs-comment">// 3. 处理当前节点</span><br>    处理当前节点与递归结果;<br>    <br>    <span class="hljs-comment">// 4. 返回结果</span><br>    <span class="hljs-keyword">return</span> 返回值;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见递归模式"><a href="#常见递归模式" class="headerlink" title="常见递归模式"></a>常见递归模式</h3><p><strong>模式一：自底向上</strong><br>先递归到底，回溯时处理<br>例如：反转链表</p><p><strong>模式二：自顶向下</strong><br>先处理当前节点，再递归<br>例如：复制链表</p><p><strong>模式三：分治合并</strong><br>分割问题，递归处理，合并结果<br>例如：归并排序</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归是解决链表问题的强大工具</p><p>掌握递归的关键：</p><ul><li>明确递归三要素：终止条件、递归逻辑、返回值</li><li>理解递归的本质：将大问题分解为小问题</li><li>学会画递归树，理解回溯过程</li><li>权衡递归与迭代的优劣</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>递归</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表系列之快慢指针</title>
    <link href="/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h2 id="快慢指针核心"><a href="#快慢指针核心" class="headerlink" title="快慢指针核心"></a>快慢指针核心</h2><p>快慢指针是链表问题中最经典的算法技巧之一</p><p>核心思想是使用两个指针同时遍历链表，但移动速度不同：</p><ul><li>快指针每次移动2步</li><li>慢指针每次移动1步</li></ul><p>这个简单的速度差异，能够解决环检测、找中点、定位特定位置等一系列问题</p><hr><h2 id="应用场景一：检测链表是否有环"><a href="#应用场景一：检测链表是否有环" class="headerlink" title="应用场景一：检测链表是否有环"></a>应用场景一：检测链表是否有环</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle/">LeetCode 141. 环形链表</a></p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，判断链表中是否有环</p><h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h3><p>如果链表有环，快慢指针最终一定会相遇</p><p>就像在操场跑步，速度快的人一定会追上速度慢的人</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span>) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head-&gt;next;<br><br>    <span class="hljs-keyword">while</span>(slow != fast) &#123;<br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针走两步前要判断 <code>fast-&gt;next</code> 是否为空</li><li>快慢指针初始位置可以不同（一个在head，一个在head-&gt;next）</li><li>循环条件是 <code>slow != fast</code></li></ul><hr><h2 id="应用场景二：找到环的入口节点"><a href="#应用场景二：找到环的入口节点" class="headerlink" title="应用场景二：找到环的入口节点"></a>应用场景二：找到环的入口节点</h2><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LeetCode 142. 环形链表 II</a></p><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p>如果链表有环，找到环的起始节点</p><h3 id="核心思路（Floyd判圈算法）"><a href="#核心思路（Floyd判圈算法）" class="headerlink" title="核心思路（Floyd判圈算法）"></a>核心思路（Floyd判圈算法）</h3><p>这是快慢指针最精妙的应用，分为两个阶段：</p><p><strong>第一阶段：判断是否有环</strong></p><ul><li>快慢指针同时从head出发</li><li>快指针每次2步，慢指针每次1步</li><li>如果相遇，说明有环</li></ul><p><strong>第二阶段：寻找环起点</strong></p><ul><li>将一个指针放回链表头</li><li>两个指针都改为每次走1步</li><li>再次相遇的点就是环起点</li></ul><h3 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h3><p>设链表头到环入口距离为 <code>a</code>，环入口到相遇点距离为 <code>b</code>，相遇点到环入口距离为 <code>c</code></p><p>相遇时：</p><ul><li>慢指针走了：<code>a + b</code></li><li>快指针走了：<code>a + b + c + b</code> &#x3D; <code>a + 2b + c</code></li></ul><p>因为快指针速度是慢指针2倍，所以：</p><ul><li><code>2(a + b) = a + 2b + c</code></li><li>化简得：<code>a = c</code></li></ul><p>这就是为什么从头节点和相遇点同时出发，会在环入口相遇</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode *<span class="hljs-title function_">detectCycle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode *head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 关键：slow和fast都从head开始</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br>    <br>    <span class="hljs-comment">// 第一阶段：判断是否有环</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>        <br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-comment">// 第二阶段：寻找环起点</span><br>            fast = head;<br>            <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>                fast = fast-&gt;next;<br>                slow = slow-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;  <span class="hljs-comment">// 环起点</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 无环</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h3><ul><li>第一阶段slow和fast必须从同一位置出发</li><li>相遇后将其中一个指针移回head</li><li>第二阶段两个指针都是每次走1步</li></ul><hr><h2 id="应用场景三：删除倒数第N个节点"><a href="#应用场景三：删除倒数第N个节点" class="headerlink" title="应用场景三：删除倒数第N个节点"></a>应用场景三：删除倒数第N个节点</h2><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LeetCode 19. 删除链表的倒数第 N 个结点</a></p><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个链表，删除倒数第N个节点</p><h3 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h3><p>让快指针先走N步，然后快慢指针同时前进</p><p>当快指针到达末尾时，慢指针正好在倒数第N个节点的前一个位置</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">curr</span> =</span> &amp;dummy;<br>    dummy.next = head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span>=</span>curr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">low</span>=</span>curr;<br>    <br>    <span class="hljs-comment">// 快指针先走n步</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 快慢指针同时前进</span><br>    <span class="hljs-keyword">while</span>(fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        low=low-&gt;next;<br>        fast=fast-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span>=</span>low-&gt;next;<br>    low-&gt;next=low-&gt;next-&gt;next;<br>    <span class="hljs-built_in">free</span>(tmp);<br>    <br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h3><ul><li>使用虚拟头节点，避免处理删除头节点的边界情况</li><li>快指针要先走N步</li><li>慢指针停在待删除节点的前一个位置</li></ul><hr><h2 id="应用场景四：判断回文链表"><a href="#应用场景四：判断回文链表" class="headerlink" title="应用场景四：判断回文链表"></a>应用场景四：判断回文链表</h2><p><a href="https://leetcode.cn/problems/palindrome-linked-list/">LeetCode 234. 回文链表</a></p><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>判断一个链表是否为回文结构</p><h3 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h3><ol><li>用快慢指针找到链表中点</li><li>反转后半部分链表</li><li>比较前后两部分是否相同</li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 反转链表辅助函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head==<span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">cur</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">prev</span>=</span><span class="hljs-literal">NULL</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">next</span>;</span><br>    <br>    <span class="hljs-keyword">while</span>(cur)&#123;<br>        next=cur-&gt;next;<br>        cur-&gt;next=prev;<br>        prev=cur;<br>        cur=next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">isPalindrome</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next==<span class="hljs-literal">NULL</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">low</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span>=</span>head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tmp</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head_behind</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">head_ahead</span>;</span><br>    <br>    <span class="hljs-comment">// 快慢指针找中点</span><br>    <span class="hljs-keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;<br>        low=low-&gt;next;<br>        fast=fast-&gt;next-&gt;next;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据链表奇偶判断后半段起点</span><br>    <span class="hljs-keyword">if</span>(fast)&#123;<br>        tmp=low-&gt;next;  <span class="hljs-comment">// 奇数个节点</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        tmp=low;  <span class="hljs-comment">// 偶数个节点</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 反转后半部分</span><br>    head_behind=reverseList(tmp);<br>    head_ahead=head;<br><br>    <span class="hljs-comment">// 比较两部分</span><br>    <span class="hljs-keyword">while</span>(head_behind)&#123;<br>        <span class="hljs-keyword">if</span>(head_behind-&gt;val==head_ahead-&gt;val)&#123;<br>            head_ahead=head_ahead-&gt;next;<br>            head_behind=head_behind-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-3"><a href="#关键点-3" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针走到末尾时，慢指针在中点</li><li>要区分链表节点个数的奇偶性</li><li>空间复杂度O(1)，优于使用栈的方案</li></ul><hr><h2 id="应用场景五：链表排序中找中点"><a href="#应用场景五：链表排序中找中点" class="headerlink" title="应用场景五：链表排序中找中点"></a>应用场景五：链表排序中找中点</h2><p><a href="https://leetcode.cn/problems/sort-list/">LeetCode 148. 排序链表</a></p><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>对链表进行排序，要求时间复杂度O(n log n)</p><h3 id="核心思路-3"><a href="#核心思路-3" class="headerlink" title="核心思路"></a>核心思路</h3><p>使用归并排序：</p><ol><li>用快慢指针找中点，分割链表</li><li>递归排序左右两部分</li><li>合并两个有序链表</li></ol><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 找到链表中间节点</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">findMiddle</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) <span class="hljs-keyword">return</span> head;<br>    <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">slow</span> =</span> head;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> *<span class="hljs-title">fast</span> =</span> head-&gt;next;  <span class="hljs-comment">// fast从head-&gt;next开始</span><br>    <br>    <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序链表</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* l1, <span class="hljs-keyword">struct</span> ListNode* l2)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span> <span class="hljs-title">dummy</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">tail</span> =</span> &amp;dummy;<br>    dummy.next = <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-keyword">while</span> (l1 &amp;&amp; l2) &#123;<br>        <span class="hljs-keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;<br>            tail-&gt;next = l1;<br>            l1 = l1-&gt;next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tail-&gt;next = l2;<br>            l2 = l2-&gt;next;<br>        &#125;<br>        tail = tail-&gt;next;<br>    &#125;<br>    <br>    tail-&gt;next = l1 ? l1 : l2;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br><br><span class="hljs-comment">// 递归归并排序主函数</span><br><span class="hljs-keyword">struct</span> ListNode* <span class="hljs-title function_">sortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ListNode* head)</span> &#123;<br>    <span class="hljs-comment">// 递归终止条件</span><br>    <span class="hljs-keyword">if</span> (!head || !head-&gt;next) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 1. 找到中间节点并分割</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">mid</span> =</span> findMiddle(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">right</span> =</span> mid-&gt;next;<br>    mid-&gt;next = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 切断链表</span><br>    <br>    <span class="hljs-comment">// 2. 递归排序左右两部分</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">leftSorted</span> =</span> sortList(head);<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">rightSorted</span> =</span> sortList(right);<br>    <br>    <span class="hljs-comment">// 3. 合并有序链表</span><br>    <span class="hljs-keyword">return</span> merge(leftSorted, rightSorted);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关键点-4"><a href="#关键点-4" class="headerlink" title="关键点"></a>关键点</h3><ul><li>快指针从<code>head-&gt;next</code>开始，确保分割点在左半部分</li><li>分割后要将左半部分的尾节点指向NULL</li><li>归并排序是链表排序的最优解</li></ul><hr><h2 id="快慢指针核心总结"><a href="#快慢指针核心总结" class="headerlink" title="快慢指针核心总结"></a>快慢指针核心总结</h2><h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">slow</span> =</span> head;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ListNode</span>* <span class="hljs-title">fast</span> =</span> head;<br><br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>    slow = slow-&gt;next;<br>    fast = fast-&gt;next-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>空指针判断</strong>：快指针移动前要判断<code>fast</code>和<code>fast-&gt;next</code></li><li><strong>初始位置</strong>：根据具体问题选择是否从同一位置开始</li><li><strong>奇偶处理</strong>：找中点时要注意链表长度奇偶的影响</li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>快慢指针是链表算法中最优雅的技巧之一</p><p>它用简单的速度差异，解决了环检测、找中点、定位等多个经典问题</p>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>快慢指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>堆的基本操作</title>
    <link href="/2026/01/04/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2026/01/04/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>堆是一种特殊的完全二叉树结构，常用于实现优先队列。在最大堆中，父节点的值总是大于或等于其子节点的值。本文将通过C语言代码实现一个最大堆</p><h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><p>堆是一种数据结构，具有以下特性：</p><ul><li><strong>完全二叉树</strong>：除了最后一层，其他层都是满的，且最后一层的节点都靠左排列</li><li><strong>堆序性</strong>：在最大堆中，任意节点的值大于或等于其子节点的值</li></ul><p>堆通常用数组来实现，其中：</p><ul><li>根节点索引: <code>0</code></li><li>左子节点索引：<code>2*i + 1</code></li><li>右子节点索引：<code>2*i + 2</code></li><li>父节点索引： <code>(i-1)/2</code></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>下面是最大堆的C语言实现</p><h3 id="1-堆的结构体定义"><a href="#1-堆的结构体定义" class="headerlink" title="1. 堆的结构体定义"></a>1. 堆的结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> *data;      <span class="hljs-comment">// 动态数组，数组指针</span><br>    <span class="hljs-type">int</span> size;       <span class="hljs-comment">// 堆的元素个数</span><br>    <span class="hljs-type">int</span> capacity;   <span class="hljs-comment">// 堆的最大容量</span><br>&#125; MaxHeap;<br></code></pre></td></tr></table></figure><h3 id="2-交换元素"><a href="#2-交换元素" class="headerlink" title="2. 交换元素"></a>2. 交换元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> *b)</span> &#123;<br>    <span class="hljs-type">int</span> tmp = *a;<br>    *a = *b;<br>    *b = tmp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-初始化堆"><a href="#3-初始化堆" class="headerlink" title="3. 初始化堆"></a>3. 初始化堆</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap* <span class="hljs-title function_">createHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-comment">// 初始化分配空间</span><br>    MaxHeap* heap = (MaxHeap*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(MaxHeap));<br>    heap-&gt;data = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) * capacity);<br>    <span class="hljs-comment">// 堆数值初始化</span><br>    heap-&gt;capacity = capacity;<br>    heap-&gt;size = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-向上调整（siftUp）"><a href="#4-向上调整（siftUp）" class="headerlink" title="4. 向上调整（siftUp）"></a>4. 向上调整（siftUp）</h3><p>用于插入元素后维护堆的性质。从插入的节点开始，与父节点比较，如果大于父节点则交换，直到满足堆序性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">siftUp</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> childIdx)</span> &#123;<br>    <span class="hljs-keyword">while</span> (childIdx &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> parentIdx = (childIdx - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (heap-&gt;data[childIdx] &gt; heap-&gt;data[parentIdx]) &#123;<br>            swap(&amp;heap-&gt;data[childIdx], &amp;heap-&gt;data[parentIdx]);<br>            childIdx = parentIdx;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-向下调整（siftDown）"><a href="#5-向下调整（siftDown）" class="headerlink" title="5. 向下调整（siftDown）"></a>5. 向下调整（siftDown）</h3><p>用于删除堆顶或建堆时维护堆的性质。从指定节点开始，与子节点比较，选择最大的子节点交换，直到满足堆序性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">siftDown</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> parentIdx)</span> &#123;<br>    <span class="hljs-type">int</span> size = heap-&gt;size;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">int</span> leftChild = parentIdx * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> rightChild = parentIdx * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> largest = parentIdx;<br>        <br>        <span class="hljs-keyword">if</span> (leftChild &lt; size &amp;&amp; heap-&gt;data[leftChild] &gt; heap-&gt;data[largest]) &#123;<br>            largest = leftChild;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (rightChild &lt; size &amp;&amp; heap-&gt;data[rightChild] &gt; heap-&gt;data[largest]) &#123;<br>            largest = rightChild;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (largest != parentIdx) &#123;<br>            swap(&amp;heap-&gt;data[largest], &amp;heap-&gt;data[parentIdx]);<br>            parentIdx = largest;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-入堆操作（push）"><a href="#6-入堆操作（push）" class="headerlink" title="6. 入堆操作（push）"></a>6. 入堆操作（push）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">push</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> val)</span> &#123;<br>    <span class="hljs-comment">// 满堆的处理</span><br>    <span class="hljs-keyword">if</span> (heap-&gt;size == heap-&gt;capacity)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    heap-&gt;data[heap-&gt;size] = val;<br><br>    <span class="hljs-comment">// 这里siftUp与size无关，所以两者顺序不影响</span><br>    siftUp(heap, heap-&gt;size);<br>    heap-&gt;size++;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-出堆操作（pop）"><a href="#7-出堆操作（pop）" class="headerlink" title="7. 出堆操作（pop）"></a>7. 出堆操作（pop）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pop</span><span class="hljs-params">(MaxHeap* heap)</span> &#123;<br>    <span class="hljs-comment">// 空堆检查</span><br>    <span class="hljs-keyword">if</span> (heap-&gt;size == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> root = heap-&gt;data[<span class="hljs-number">0</span>];     <br>    <br>    <span class="hljs-comment">// 用最后一个元素覆盖堆顶</span><br>    heap-&gt;data[<span class="hljs-number">0</span>] = heap-&gt;data[heap-&gt;size - <span class="hljs-number">1</span>];<br>    <br>    <span class="hljs-comment">// 必须先减size再siftDown：</span><br>    <span class="hljs-comment">// 1. siftDown依赖正确的heap-&gt;size判断子节点边界</span><br>    <span class="hljs-comment">// 2. 原末尾元素已移至堆顶，该位置不再属于堆</span><br>    <span class="hljs-comment">// 3. 避免siftDown访问到逻辑上已移除的元素</span><br>    heap-&gt;size--;  <br>    siftDown(heap, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-删除任意位置的元素"><a href="#8-删除任意位置的元素" class="headerlink" title="8. 删除任意位置的元素"></a>8. 删除任意位置的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">deleteElement</span><span class="hljs-params">(MaxHeap* heap, <span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= heap-&gt;size)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        pop(heap);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i == heap-&gt;size - <span class="hljs-number">1</span>) &#123;<br>        heap-&gt;size--;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> lastVal = heap-&gt;data[heap-&gt;size - <span class="hljs-number">1</span>];<br>    heap-&gt;size--;<br>    <span class="hljs-type">int</span> oldVal = heap-&gt;data[i];<br>    heap-&gt;data[i] = lastVal;<br><br>    <span class="hljs-keyword">if</span> (lastVal &gt; oldVal) &#123;<br>        siftUp(heap, i);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        siftDown(heap, i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-建堆操作"><a href="#9-建堆操作" class="headerlink" title="9. 建堆操作"></a>9. 建堆操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap* <span class="hljs-title function_">makeHeap</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize)</span> &#123;<br>    <span class="hljs-comment">// 堆的初始化</span><br>    MaxHeap* heap = createHeap(numsSize);<br>    <span class="hljs-comment">// 数组拷贝到堆</span><br>    <span class="hljs-built_in">memcpy</span>(heap-&gt;data, nums, numsSize * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    heap-&gt;size = numsSize;<br>    <span class="hljs-comment">// 从最后一个非叶节点开始向下调整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = (numsSize / <span class="hljs-number">2</span>) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        siftDown(heap, i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上代码，我们实现了一个完整的大根堆数据结构，堆的基本操作包括：</p><ul><li><strong>插入</strong>：使用<code>push</code>函数，时间复杂度O(log n)</li><li><strong>删除堆顶</strong>：使用<code>pop</code>函数，时间复杂度O(log n)</li><li><strong>删除任意元素</strong>：使用<code>deleteElement</code>函数，时间复杂度O(log n)</li><li><strong>建堆</strong>：使用<code>makeHeap</code>函数，时间复杂度O(n)</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>堆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU缓存算法</title>
    <link href="/2026/01/03/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/"/>
    <url>/2026/01/03/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>LRU（最近最少使用算法），是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据，以腾出空间给新的数据</p><h2 id="LRU缓存算法原理"><a href="#LRU缓存算法原理" class="headerlink" title="LRU缓存算法原理"></a>LRU缓存算法原理</h2><p>下面会重点介绍核心的数据结构和操作原理</p><h3 id="核心数据结构：双向链表-哈希表"><a href="#核心数据结构：双向链表-哈希表" class="headerlink" title="核心数据结构：双向链表 + 哈希表"></a>核心数据结构：双向链表 + 哈希表</h3><p>LRU缓存算法的核心思想是维护一个有序的数据结构，记录数据的使用顺序。当数据被访问时，将其移动到数据结构的头部，表示它是最近使用的数据。当缓存达到容量限制时，淘汰数据结构尾部的数据，即最少使用的数据</p><h3 id="核心操作原理"><a href="#核心操作原理" class="headerlink" title="核心操作原理"></a>核心操作原理</h3><p><strong>1. 读取数据 (Get)</strong>  </p><ul><li><strong>查找</strong>：在哈希表中查找该 key。  </li><li><strong>命中</strong>：如果找到，根据哈希表记录的指针直接访问链表节点，获取 value。  </li><li><strong>更新状态</strong>：因为该节点被访问了，它变成了“最新”的，所以将其从链表当前位置删除，并重新插入到链表尾部。  </li><li><strong>未命中</strong>：返回 -1。</li></ul><p><strong>2. 写入&#x2F;更新数据 (Put)</strong><br><strong>节点已存在：</strong>  </p><ul><li>修改该节点的 value。  </li><li>将该节点移到链表尾部（更新时序）。</li></ul><p><strong>节点不存在：</strong>  </p><ul><li><strong>检查容量</strong>：如果缓存已满（size &#x3D;&#x3D; capacity），则执行“淘汰”：  <ul><li>删除链表头部（Head-&gt;next）的节点，因为它最久没被使用。  </li><li>同步在哈希表中删除该节点的 key。</li></ul></li><li><strong>插入新节点</strong>：创建新节点，放入链表尾部，并在哈希表中记录映射关系。</li></ul><h2 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h2><p><a href="https://leetcode.cn/problems/lru-cache/">LeetCode 146. LRU 缓存</a><br>下面是LRU缓存算法的C语言实现代码</p><h3 id="使用uthash库实现"><a href="#使用uthash库实现" class="headerlink" title="使用uthash库实现"></a>使用uthash库实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uthash.h&quot;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    UT_hash_handle hh;<br>&#125; LRUNode;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    LRUNode* cacheTable;<br>    <span class="hljs-type">int</span> capacity;<br>&#125; LRUCache;<br><br>LRUCache* <span class="hljs-title function_">lRUCacheCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    LRUCache* cache = (LRUCache*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUCache));<br>    cache-&gt;cacheTable = <span class="hljs-literal">NULL</span>;<br>    cache-&gt;capacity = capacity;<br>    <span class="hljs-keyword">return</span> cache;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lRUCacheGet</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    LRUNode* node = <span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, node);<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCachePut</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    LRUNode* node = <span class="hljs-literal">NULL</span>;<br>    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        node-&gt;val = value;<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (HASH_COUNT(obj-&gt;cacheTable) == obj-&gt;capacity) &#123;<br>            LRUNode* oldestNode = obj-&gt;cacheTable;<br>            HASH_DEL(obj-&gt;cacheTable, oldestNode);<br>            <span class="hljs-built_in">free</span>(oldestNode);<br>        &#125;<br>        LRUNode* newNode = (LRUNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUNode));<br>        newNode-&gt;key = key;<br>        newNode-&gt;val = value;<br>        HASH_ADD_INT(obj-&gt;cacheTable, key, newNode);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCacheFree</span><span class="hljs-params">(LRUCache* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    LRUNode* node, *tmp;<br>    HASH_ITER(hh, obj-&gt;cacheTable, node, tmp) &#123;<br>        HASH_DEL(obj-&gt;cacheTable, node);<br>        <span class="hljs-built_in">free</span>(node);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="手搓双向链表-哈希表实现"><a href="#手搓双向链表-哈希表实现" class="headerlink" title="手搓双向链表 + 哈希表实现"></a>手搓双向链表 + 哈希表实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 双向链表节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span>* <span class="hljs-title">prev</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DLinkNode</span>* <span class="hljs-title">next</span>;</span><br>&#125; DLinkNode;<br><br>DLinkNode* <span class="hljs-title function_">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> val)</span> &#123;<br>    DLinkNode* node = (DLinkNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(DLinkNode));<br>    node-&gt;key = key;<br>    node-&gt;val = val;<br>    node-&gt;prev = <span class="hljs-literal">NULL</span>;<br>    node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// 简易哈希表（数组+链地址法）</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HASH_TABLE_SIZE 1009</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashBucket</span> &#123;</span><br>    <span class="hljs-type">int</span> key;<br>    DLinkNode* node;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HashBucket</span>* <span class="hljs-title">next</span>;</span><br>&#125; HashBucket;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(key &lt; <span class="hljs-number">0</span> ? -key : key) % HASH_TABLE_SIZE;<br>&#125;<br><br><span class="hljs-comment">// LRU缓存对象</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    DLinkNode* head;<br>    DLinkNode* tail;<br>    HashBucket* hashTable[HASH_TABLE_SIZE];<br>    <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-type">int</span> size;<br>&#125; LRUCache;<br><br><span class="hljs-comment">// 辅助函数，双向链表操作</span><br><span class="hljs-comment">// 将新节点加到双向链表尾部</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">addToTail</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    node-&gt;prev = cache-&gt;tail-&gt;prev;<br>    node-&gt;next = cache-&gt;tail;<br>    cache-&gt;tail-&gt;prev-&gt;next = node;<br>    cache-&gt;tail-&gt;prev = node;<br>&#125;<br><br><span class="hljs-comment">// 从链表中移除节点</span><br><span class="hljs-comment">// 因为有哨兵节点，所以不需要考虑边界</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    node-&gt;prev-&gt;next = node-&gt;next;<br>    node-&gt;next-&gt;prev = node-&gt;prev;<br>&#125;<br><br><span class="hljs-comment">// 将已有节点移到链表尾部（表示最近使用过）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(LRUCache* cache, DLinkNode* node)</span> &#123;<br>    removeNode(cache, node);<br>    addToTail(cache, node);<br>&#125;<br><br><span class="hljs-comment">// 删除头部节点，也就是最近没使用过，并返回key</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">removeHead</span><span class="hljs-params">(LRUCache* cache)</span> &#123;<br>    DLinkNode* oldest = cache-&gt;head-&gt;next;<br>    <span class="hljs-type">int</span> key = oldest-&gt;key;<br>    removeNode(cache, oldest);<br>    <span class="hljs-built_in">free</span>(oldest);<br>    <span class="hljs-keyword">return</span> key;<br>&#125;<br><br><span class="hljs-comment">// 哈希表操作</span><br><span class="hljs-comment">// 查找key对应的节点指针</span><br>DLinkNode* <span class="hljs-title function_">hashFind</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket* bucket = cache-&gt;hashTable[idx];<br>    <span class="hljs-keyword">while</span> (bucket) &#123;<br>        <span class="hljs-keyword">if</span> (bucket-&gt;key == key) &#123;<br>            <span class="hljs-keyword">return</span> bucket-&gt;node;<br>        &#125;<br>        bucket = bucket-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 插入，key-&gt;node的映射</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hashInsert</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key, DLinkNode* node)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket* newBucket = (HashBucket*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(HashBucket));<br>    newBucket-&gt;key = key;<br>    newBucket-&gt;node = node;<br>    newBucket-&gt;next = cache-&gt;hashTable[idx];<br>    cache-&gt;hashTable[idx] = newBucket;<br>&#125;<br><br><span class="hljs-comment">// 删除key的映射</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">hashDelete</span><span class="hljs-params">(LRUCache* cache, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> idx = hashFunc(key);<br>    HashBucket** indirect = &amp;(cache-&gt;hashTable[idx]);<br>    <span class="hljs-keyword">while</span> (*indirect) &#123;<br>        <span class="hljs-keyword">if</span> ((*indirect)-&gt;key == key) &#123;<br>            HashBucket* toFree = *indirect;<br>            *indirect = toFree-&gt;next;<br>            <span class="hljs-built_in">free</span>(toFree);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// indirect本身,而不是*indirect指向的内容</span><br>        indirect = &amp;((*indirect)-&gt;next);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// LRU接口实现</span><br>LRUCache* <span class="hljs-title function_">lRUCacheCreate</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    LRUCache* cache = (LRUCache*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(LRUCache));<br>    cache-&gt;capacity = capacity;<br>    cache-&gt;size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化哨兵节点</span><br>    cache-&gt;head = createNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cache-&gt;tail = createNode(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    cache-&gt;head-&gt;next = cache-&gt;tail;<br>    cache-&gt;tail-&gt;prev = cache-&gt;head;<br><br>    <span class="hljs-comment">// 初始化哈希表</span><br>    <span class="hljs-built_in">memset</span>(cache-&gt;hashTable, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(cache-&gt;hashTable));<br>    <span class="hljs-keyword">return</span> cache;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">lRUCacheGet</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    DLinkNode* node = hashFind(obj, key);<br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    moveToTail(obj, node);<br>    <span class="hljs-keyword">return</span> node-&gt;val;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCachePut</span><span class="hljs-params">(LRUCache* obj, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    DLinkNode* node = hashFind(obj, key);<br>    <span class="hljs-keyword">if</span> (node) &#123;<br>        node-&gt;val = value;<br>        moveToTail(obj, node);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj-&gt;size &gt;= obj-&gt;capacity) &#123;<br>            <span class="hljs-type">int</span> oldestKey = removeHead(obj);<br>            hashDelete(obj, oldestKey);<br>            obj-&gt;size--;<br>        &#125;<br>        DLinkNode* newNode = createNode(key, value);<br>        addToTail(obj, newNode);<br>        hashInsert(obj, key, newNode);<br>        obj-&gt;size++;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">lRUCacheFree</span><span class="hljs-params">(LRUCache* obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span>;<br>    DLinkNode* cur = obj-&gt;head-&gt;next;<br>    <span class="hljs-keyword">while</span> (cur != obj-&gt;tail) &#123;<br>        DLinkNode* next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj-&gt;head);<br>    <span class="hljs-built_in">free</span>(obj-&gt;tail);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; HASH_TABLE_SIZE; i++) &#123;<br>        HashBucket* bucket = obj-&gt;hashTable[i];<br>        <span class="hljs-keyword">while</span> (bucket) &#123;<br>            HashBucket* next = bucket-&gt;next;<br>            <span class="hljs-built_in">free</span>(bucket);<br>            bucket = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(obj);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><h3 id="结构体分析"><a href="#结构体分析" class="headerlink" title="结构体分析"></a>结构体分析</h3><ol><li><strong>DLinkNode</strong>：双向链表节点，包含 key、val、prev、next。用于维护最近使用顺序（尾部为最近使用，头部为最久未用）。</li><li><strong>HashBucket</strong>：哈希桶中的链表节点（链地址法），每个桶是一个链表，解决哈希冲突。存储 key 和对应的 DLinkNode* 指针，避免重复存储值</li><li><strong>LRUCache</strong>：缓存主体，head &#x2F; tail：哨兵节点（dummy nodes），简化边界处理。hashTable：静态数组 + 链表，快速查找。capacity &#x2F; size：容量控制</li></ol><h3 id="操作分析"><a href="#操作分析" class="headerlink" title="操作分析"></a>操作分析</h3><ol><li><strong>addToTail</strong>：将节点添加到链表尾部，表示最近使用</li><li><strong>removeNode</strong>：从链表中移除节点</li><li><strong>moveToTail</strong>：将已有节点移到链表尾部，更新使用顺序</li><li><strong>removeHead</strong>：删除链表头部节点，淘 汰最久未用数据</li><li><strong>hashFind &#x2F; hashInsert &#x2F; hashDelete</strong>：哈希表的基本操作</li><li><strong>lRUCacheGet</strong>：获取数据，更新使用顺序</li><li><strong>lRUCachePut</strong>：插入&#x2F;更新数据，处理容量限制</li></ol><h3 id="亮点学习"><a href="#亮点学习" class="headerlink" title="亮点学习"></a>亮点学习</h3><ol><li><strong>哨兵节点</strong>：使用 head &#x2F; tail 哨兵节点，简化链表边界操作，避免频繁判断 NULL</li><li><strong>链地址法哈希表</strong>：使用静态数组 + 链表解决哈希冲突，节省空间</li><li><strong>时间复杂度</strong>：所有操作均为 O(1)，满足 LRU 缓存的高效需求</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>LRU缓存算法通过双向链表和哈希表实现高效的缓存管理，本文介绍了两种C语言实现方式：一种使用uthash库简化哈希操作，另一种手搓数据结构以深入理解底层原理</p>]]></content>
    
    
    <categories>
      
      <category>leetcode刷题笔记</category>
      
      <category>C语言</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>链表</tag>
      
      <tag>双向链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>独居者</title>
    <link href="/2023/07/26/%E7%8B%AC%E5%B1%85%E8%80%85/"/>
    <url>/2023/07/26/%E7%8B%AC%E5%B1%85%E8%80%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作者：<a href="https://baike.baidu.com/item/%E9%99%86%E8%A0%A1/1945940?fr=ge_ala">陆蠡</a></p></blockquote><span id="more"></span><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p style="text-indent: 2em;">现在我很懊悔无意中发现了C君的秘密，一个人在孤独时的秘密。这是一种痛苦，他原先紧紧藏着，预备留给他自己的，我无意中知道，这痛苦乃交给了我。他自己还不知道这回事，实际上另外有个人在分担他的痛苦了。听说有一种眚神，专给人家作祟的。但作祟的工作要在秘密中进行。譬如一个人在单房暗室，独处的时候，这眚神便用各种威胁引诱，弄得他害病为止。万一这作祟的工作被一个闯入者发现了或道破了，这眚神便舍掉原先想害的人，转向闯入者纠缠，将祸害嫁给后者。我碰到的正是这种情形。当我发现了他深自掩藏着的痛苦，我也要替他分负的了。<p>　　要说我为什么把这回事放在自己心上？我不知道。只好怪我自己了。要说他有什么痛苦，为什么痛苦？我也不知道。这是一个谜。痛苦是往往说不出的。好像挨了毒打，浑身疼痛，却摸不着痛处。C君是一个奇特的人！他是属于幸福的一群呢？还是属于不幸的一群呢？我不能下断语。要论断某一个人，总得自己的见解智慧比人高出一筹，方得中肯。正如景色的眺望者，从高处往下看，方见全景；若从卑处往高看，所见结果一定不对的。我对C君的观察是从卑处往高看吧，我的叙述也许是不对的。也许他不似我所猜想的，根本没有什么痛苦，这一切倒是我自己的幻觉，这也难定。总之，说他有点奇特，不算过分吧。</p><p>　　C君是我的朋友。我们认识有许多年头了。他给我最初的印象是一个可爱的，快乐的，和蔼的青年人。他服装穿得干净，鞋帽整齐。他的头发总是剪得齐齐的，两旁梳开，披在颞颥边，中间显出一条肉路。他的脸端正，端庄的表情浮在端正的脸上，有一种没有矜伐的厚道。他有明净的眼珠，不常直视人，偶然碰到别人的眼光在他的脸上搜索的时候，总是微微一笑避开。他鼻子方正，鼻准微平。嘴也搭配得大小适宜，嘴唇略厚一点，这使他的脸减损一分秀气。他会说话，不大流利，可够表达，显然是练习出来的。他的脸颜微嫌瘦削，照他的骨架子，应当更丰满些。总之，他是一望而知的没有受过生活鞭挞的人，在一个陌生人的眼中，正如一般生活优裕的人，往往多受人们尊敬。</p><p>　　从他对人和做事的态度看来，他是一个热情的没有自私的青年。他对朋友极诚恳，做事认真负责。他的信念极坚定，在他的眼前永远闪现着美丽的希望。他不颓沮，不懊丧，脸上心里总是浮着微笑的。他从没有对任何事失去忍耐，对任何人抱怨，责备；他忙，但颇有点闲情。有一次我见他照画报上的样子在剖剔一个水仙球茎，弄了好几个钟头，似乎没失去耐性。</p><p>　　我们时常在一起，散步谈天。我们谈到粗俗的，猥亵的，平凡的，崇高的，他很坦白，很少隐藏，因此我也约略知道他的身世，他的思想，他的感情。一切都没超人或异乎常人的地方。他正是一个脚踏实地地为理想的工作者。</p><p>　　但是当我发现他有一种爱好独居的性格的时候，我渐渐觉得他有点奇特。他的工作（我想对他的工作性质的说明是不必要的。世界上，哪种工作最高贵最重要，而哪一种又不重要的，无价值的，我想没有人能够品评），使他和人们亲近，同居处，同饮食。但他总是单独住一个房间。他从不肯留一个朋友在他房里住宿。他好像是洁身自爱的女子，不让别人占用她的闺闼。当有一次一位从远道来的友人来望他，那友人找不到别的宿处而又疲倦了，打算在他房里过一夜，他陪他坐到夜深，最后，站起来说道：“我房里没留过客人，我要保持这记录，我陪你上旅馆去。”友人显然有点愠色，但他还是曳着友人上旅馆去了。这事后来那友人告诉我好多次，说他是有点不近人情的。</p><p>　　他住的房间陈设简陋，但他守住这简陋的房间，像野兽守住它的洞穴，不愿意别兽闯入。我对个人的癖爱颇能谅解。像他这样的人，也许为了工作性质的关系，也许为了读书研习的关系，不愿别人打吵他，是说得过去的。我曾有个时期和他同住在一所公共的建筑内，同处在一个屋顶下，但我们仍旧保持着各人的生活习惯。因为我们有着不同的职业。我白天出去，晚上一早就睡了。他到夜深睡，早晨起床比较迟。有时候我们是数天不见面的。</p><p>　　一天的夜里我发现了他孑身独处的原因。愿他原谅我，我是无心的。我看取了他的秘密，却无法把它交还原主，这使我时时引以为憾。我不是好奇的。这发现属于偶然，至今我还是懊悔那一次的闯入。</p><p>　　那是一个有月亮的夏季的晚上，夜深使一切喧嚣归于静寂。我这夜特别比平时睡得迟，正预备熄灯睡的时候，突然想起一件东西遗在C君的房里，想立刻得到它。我想他是已经睡了，为了不惊扰他，我悄声走过去，我蹑着脚步走近他的房间。他的房门没有锁，被午夜的风吹开，留着一条阔缝。我一脚跨进去，仿佛眼前一个异景怔住了我，我几乎不相信我自己的眼睛了。C君在做什么啦！他跪在自己床前的地上，头伏在臂里，好像在作祈祷。从窗口斜射进来的月光把室内照成一种淡淡的晖明，他虽则跪在暗里，我却清楚地能够辨别他额上流着汗，脸孔是严肃而神秘的，一种不胜苦楚之情。这使我想起耶稣基督在客西马尼亚园中的祈祷：“汗珠大如血点，流在地上。”一种在苦杯前踌躇的惶悚。C君也好像是在推开一个苦杯而又准备接受。他全神贯注地沉在默念中，好像在一种不可见的神前忏悔，又好像是一个为热情所燃烧的男子在冷若冰霜的女子面前恳求，一种祈求幸福或是向幸福辞谢的神情……我几乎失声喊了出来，一种神秘的力量使我噤住。我悄悄退出，站在外面，从门隙中望他继续的动作。约莫过了四五分钟，他慢慢地站起来，走向窗口，面朝月光把手徐徐举起，好像迎接从月光中降落的天使似的。随后又把手垂下，向后摸索着床架，扶在上面，脸仍不回过来，这样站着好久好久。我只能从他偶然偏过来的脸望见那上面的神秘似的似乎痉挛的表情。“他是被痛苦啮噬着，”我忽然想到，于是迅速地跑回我自己的房间，忘记了适才去他房里的目的，我熄了灯，躺在床上，辗转了好久，我细细分析他平时的见解和行为，一丝也没有异样。但渐渐我从他偶尔流露的片言只语里，好像发觉他是怀着什么痛苦。</p><p>　　那也是和他相识不久的时候，我们已有时常谈天的习惯，我坐在他房里，我们纵谈着各种琐事，讨论着许多问题。我们谈得很有兴趣，这时他手中揉弄着一条领带。我想到一个友人，爱把领带当作裤带束在腰间，于是我说：</p><p>　　“你知道领带还有什么别的用途么？”</p><p>　　“哈哈哈。”</p><p>　　“猜得着吗？”</p><p>　　“哈哈哈。”</p><p>　　我不耐烦地就把我的发现告诉他。说是领带当裤带是适宜的。长短阔狭都好，只是一端太宽了些。</p><p>　　“还有一个用途。”他补充说。</p><p>　　“什么？”</p><p>　　“哈哈哈。”他不说下去了。</p><p>　　但是一转想我也猜到了。那是上吊用的。当时我觉得这家伙脑筋古怪，怎会想到这上面来呢？但是他那快活的笑声，立刻把我思想的阴云打散了。</p><p>　　我从来不曾听到他悲观的论调。但有一次一个友人颂赞“生的欢喜”“生的美丽”说：</p><p>　　“生是多美丽啊！我便从来没想到自杀过。”</p><p>　　“谎话！”好像听见C君的自言自语。但他立刻用快活的声音接着道：</p><p>　　“是的。生是美丽的。”</p><p>　　谁能够解释他身上的矛盾呢？谁能够看出他极快活的表面底下潜藏着一个痛苦的灵魂？他有希望的光明，却又有失望的暗影；他有快乐的外表，却又有忧郁的内心。他好像是一池深深的潭水，表面平静光滑，反射着美丽的阳光，底里却翻涌着涡卷的伏流。有人留心到海面么？涡流最急的地方往往表面上显得异常光滑。C君的心境便是这样子。令人费于索解了。</p><p>　　我想从他自己的口中和别人的口中探听，他是否受过什么大刺激，譬如失恋等情事，答案都是否定的。受过良好的教育，正如有着进步思想的人，他是自由主义者，他反对宗教，反对权力，反对加在人类身上的经济的和思想的一切桎梏，那么他为什么那样苦苦地祈祷呢？简直像一个虔诚的教徒！为什么他想到“死”呢？想到人们认为罪恶而自己也认为罪恶的“自杀”呢？这一切都是谜。他是在割舍一种人性上离不开的东西呢？他是不是凭他那严刻的内省，在替他自己的信念和理想觅取一种道德上的支持？好像他发现了一种理想，而又怀疑着，又给自己的怀疑解释，而这解释又不能使自己满意，他想抓住无定形的理想，而又抓不住，因而显得痛苦呢？这一些，也许连他自己也不会明白。</p><p>　　于是我发现他平时乐观的态度倒是一种悲哀的掩饰了。嗣后每次他和我谈话的时候，我便不禁想起他夜晚苦苦跪着的样子。“他苦苦地制造了一个希望，一个理想，来扶掖自己。”我总这样地想。他是天生的有忧郁性格的人，却人为地在忧郁的底子上抹上一层愉快的色彩。这种努力是可敬的，但是这种努力，总给我以一种不可言说的悲哀。</p>]]></content>
    
    
    <categories>
      
      <category>文学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>散文</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
