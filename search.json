[{"title":"二分查找","url":"/2026/01/14/二分查找/","content":"\n## 二分查找介绍\n\n### 核心思想\n- 一种在有序数组中高效定位目标元素的方法,每次将查找区间缩小一半，从而快速锁定目标位置\n- 经典的**减而治之**思想,所谓**减**，就是每一步都通过条件判断，排除掉一部分一定不包含目标元素的区间，从而缩小问题规模；**治**，则是在缩小后的区间内继续解决剩下的子问题。也就是说，二分查找的核心在于：每次查找都排除掉不可能存在目标的区间，仅在可能存在目标的区间内继续查找\n\n### 模板\n\n我喜欢的是左闭右闭的区间:\n\n1. 区间定义：使用左闭右闭区间 `[left, right]`\n2. 中间计算：`mid = (left + right)/2` 或 `mid = left + (right - left)/2`（防溢出）\n3. 边界更新：\n- 目标在右半区间：`left = mid + 1`\n- 目标在左半区间：`right = mid - 1`\n4. 终止条件：`left > right` 时查找失败\n\n---\n\n## hot100中二分查找题目实践\n\n### 1. 搜索插入位置\n\n[LeetCode 35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)\n\n**问题描述：** 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。请必须使用时间复杂度为 `O(log n)` 的算法。\n\n**二分思路** 左闭右闭区间，使用`left`和`right`，计算`mid`，每次比较中间值与`target`，再决定是左区间还是右区间\n\n**代码实现** \n```c\nint searchInsert(int* nums, int numsSize, int target){\n    int left=0,right=numsSize-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]>target){\n            right=mid-1;\n        }\n        else if(nums[mid]<target){\n            left=mid+1;\n        }\n        else{\n            return mid;\n        }\n    }\n    // 举例子发现，如果没找到mid，则就是在left指针\n    return left;\n}\n```\n\n本题中的`return left`：\n\n在二分查找过程中，`left` 始终维护的是 `target` 应该插入的最小合法位置,更准确地说：`left` 是第一个满足 `nums[i] >= target` 的下标 `i`。这正是“插入位置”的定义：把 `target` 插入后，数组仍然有序。\n\n---\n\n### 2. 搜索二维矩阵\n\n[LeetCode 74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)\n\n**问题描述：** 给出`m x n` 整数矩阵：每行中的整数从左到右按非严格递增顺序排列。每行的第一个整数大于前一行的最后一个整数。给你一个整数 `target` ，如果 `target` 在矩阵中，返回 `true` ；否则，返回 `false` \n\n**二分思路** 若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素,代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上\n\n**代码实现** \n```c\nbool searchMatrix(int** matrix, int matrixSize, int* matrixColSize, int target) {\n    int m = matrixSize, n = matrixColSize[0];\n    int low = 0, high = m * n - 1;\n    while (low <= high) {\n        int mid = (high - low) / 2 + low;\n        int x = matrix[mid / n][mid % n];\n        if (x < target) {\n            low = mid + 1;\n        } else if (x > target) {\n            high = mid - 1;\n        } else {\n            return true;\n        }\n    }\n    return false;\n}\n```\n- 时间复杂度：`O(log mn)`，其中 m 和 n 分别是矩阵的行数和列数\n- 空间复杂度：`O(1)`\n\n---\n### 3. 在排序数组中查找元素的第一个和最后一个位置\n\n[LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n**问题描述：** 给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 `target`，返回 [-1, -1]。你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题\n\n**二分思路** 使用下界`lowerBound`二分查找函数，找到第一个大于等于 `target` 的元素的下标（即插入位置），也就是 `target` 的“左边界”，之后再根据`target+1`来找到右边界\n\n**代码实现**\n```c\nint lowerBound(int* nums,int numsSize,int target){\n    int left=0,right=numsSize-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        if(nums[mid]>=target){\n            right=mid-1;\n        } else{\n            left=mid+1;\n        }\n    }\n    return left;\n}\n\nint* searchRange(int* nums, int numsSize, int target, int* returnSize){\n    int* ret=(int*)malloc(sizeof(int)*2);\n    *returnSize=2;\n\n    int start=lowerBound(nums,numsSize,target);\n    if(start==numsSize || nums[start]!=target){\n        ret[0]=-1;\n        ret[1]=-1;\n        return ret;\n    }\n    // 返回的是：第一个 ≥ target + 1 的位置，所以这里要end再减一\n    int end=lowerBound(nums,numsSize,target+1)-1;\n\n    ret[0]=start;\n    ret[1]=end;\n    return ret;\n}\n```\n本题思路巧妙在于：\n\n使用`lowerBound`函数，找到第一个大于等于`target`的元素下标，之后再根据`target+1`找到右边界+1的位置，之后再减一就可以得到右边界，这一步很巧妙\n\n---\n### 4. 搜索旋转排序数组\n\n[LeetCode 33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)\n\n**问题描述：** 整数数组 `nums` 按升序排列，数组中的值互不相同。\n\n在传递给函数之前，`nums` 在预先未知的某个下标 `k`上进行了向左旋转，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标从 0 开始计数）。\n\n给你旋转后的数组 `nums` 和一个整数 `target`，如果 `nums` 中存在这个目标值 `target`，则返回它的下标，否则返回 `-1`。\n\n你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。\n\n**二分思路** 原数组升序且无重复，经一次旋转后，**任意中点 `mid` 必使左半段 `[left, mid]` 或右半段 `[mid, right]` 之一保持有序，接下来，利用`nums[left]`与`nums[mid]`比较，判断哪边有序，之后的思路如下：\n- **左半段有序**（`nums[left] <= nums[mid]`）：\n     - 若 `target ∈ [nums[left], nums[mid])` → 搜索左半：`right = mid - 1`\n     - 否则 → 搜索右半：`left = mid + 1`\n- **右半段有序**（`nums[left] > nums[mid]`）：\n     - 若 `target ∈ (nums[mid], nums[right]]` → 搜索右半：`left = mid + 1`\n     - 否则 → 搜索左半：`right = mid - 1`\n\n**代码实现**\n```c\nint search(int* nums, int numsSize, int target){\n    int left=0,right=numsSize-1;\n    while(left<=right){\n        int mid=left+(right-left)/2;\n        \n        if(nums[mid]==target) return mid;\n\n        if(nums[left]<=nums[mid]){\n            if(nums[left]<=target && nums[mid]>target){\n                right=mid-1;\n            } else{\n                left=mid+1;\n            }\n        } else{\n            if(nums[mid]<target && nums[right]>=target){\n                left=mid+1;\n            } else{\n                right=mid-1;\n            }\n        }\n    }\n    return -1;\n}\n```\n核心思路是：\n原数组升序且无重复，经一次旋转后，**任意中点 `mid` 必使左半段 `[left, mid]` 或右半段 `[mid, right]` 之一保持有序\n\n---\n### 5. 寻找旋转排序数组中的最小值\n\n[LeetCode 153. 寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/)\n\n**问题描述：** 已知一个长度为n的数组，预先按照升序排列，经由1到n次旋转后，得到输入数组。注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` 旋转一次 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]`\n\n给你一个元素值互不相同的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的最小元素 。\n\n你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。\n\n**二分思路** 最小值一定位于`无序`的那一半；如果某一半有序，则最小值不在其中，一直筛选出无序的数组区间，这里循环条件注意是`while(left<right)`，这样循环结束，`left`与`right`才能指向同一个值\n\n**代码实现**\n```c\nint findMin(int* nums, int numsSize) {\n    int left = 0, right = numsSize - 1;\n    while (left < right) {\n        int mid = left + (right - left) / 2;\n        if (nums[mid] > nums[right]) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return nums[left];\n}\n```\n\n---\n### 6. 寻找两个正序数组的中位数\n\n[LeetCode 4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)\n\n**问题描述：** 给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数,算法的时间复杂度应该为 `O(log (m+n))`\n\n**二分思路** \n\n在两个正序数组中找中位数的核心思想是：不合并数组，而是通过二分查找在较短数组上寻找一个“分割点”，使得左右两部分满足中位数的划分条件。\n将 `nums1` 在位置 `i` 切分、`nums2` 在位置 `j` 切分，形成左右两部分。要求：\n- 左半部分总元素数等于右半部分（或比右多 1），即 `i + j = (m + n + 1) / 2`；\n- 左半部分的最大值不超过右半部分的最小值，即 `nums1[i-1] <= nums2[j]` 且 `nums2[j-1] <= nums1[i]`。\n为优化效率，始终在较短的数组上进行二分搜索。设 `left = 0`，`right = m`（`i` 的合法范围是 `[0, m]`）。每次取 `i = left + (right - left) / 2`，并令 `j = k - i`（其中 `k = (m + n + 1) / 2`）。\n为避免边界越界，使用 `INT_MIN` 和 `INT_MAX` 处理空侧：\n- `l1 = (i == 0) ? INT_MIN : nums1[i - 1]`\n- `r1 = (i == m) ? INT_MAX : nums1[i]`\n- `l2 = (j == 0) ? INT_MIN : nums2[j - 1]`\n- `r2 = (j == n) ? INT_MAX : nums2[j]`\n若 `l1 <= r2 && l2 <= r1`，说明分割正确：\n- 若总长度为奇数，中位数为 `max(l1, l2)`；\n- 若为偶数，中位数为 `(max(l1, l2) + min(r1, r2)) / 2.0`。\n否则：\n- 若 `l1 > r2`，说明 `i` 太大，需左移：`right = i - 1`；\n- 若 `l2 > r1`，说明 `i` 太小，需右移：`left = i + 1`。\n\n\n**代码实现**\n\n```c\n// 寻找中位数的函数\ndouble findMedianSortedArrays(int* nums1, int m, int* nums2, int n) {\n    // 确保 nums1 是较短的数组\n    if (m > n) {\n        // 交换 nums1 和 nums2，确保 nums1 总是较小的数组\n        int* temp = nums1;\n        nums1 = nums2;\n        nums2 = temp;\n        int tmp = m;\n        m = n;\n        n = tmp;\n    }\n\n    // 如果 nums1 或 nums2 为空数组，直接返回结果\n    if (m == 0) {\n        if ((m + n) % 2 == 1) {\n            return nums2[(n - 1) / 2]; // 中位数\n        } else {\n            return (nums2[(n / 2) - 1] + nums2[n / 2]) / 2.0;\n        }\n    }\n\n    // 设置 k 为合并后的中位数所在的位置\n    int k = (m + n + 1) / 2;  // 求中位数位置\n\n    int left = 0, right = m;\n    while (left <= right) {\n        int i = left + (right - left) / 2;  // nums1 的分割点\n        int j = k - i;                      // nums2 的分割点\n\n        // 获取 nums1 和 nums2 的边界元素\n        int l1 = (i == 0) ? INT_MIN : nums1[i - 1]; // nums1 左边的最大值\n        int r1 = (i == m) ? INT_MAX : nums1[i];     // nums1 右边的最小值\n        int l2 = (j == 0) ? INT_MIN : nums2[j - 1]; // nums2 左边的最大值\n        int r2 = (j == n) ? INT_MAX : nums2[j];     // nums2 右边的最小值\n\n        if (l1 <= r2 && l2 <= r1) {\n            // 如果分割点正确，找到中位数\n            int lmax = (l1 > l2) ? l1 : l2;\n            int rmin = (r1 < r2) ? r1 : r2;\n\n            // 如果总数是奇数，返回左半部分的最大值\n            if ((m + n) % 2 == 1) {\n                return lmax;\n            } else {\n                // 如果总数是偶数，返回左右两边的平均值\n                return (lmax + rmin) / 2.0;\n            }\n        } else if (l1 > r2) {\n            // 如果 l1 > r2，则减少 nums1 的分割点，增加 nums2 的分割点\n            right = i - 1;\n        } else {\n            // 如果 l2 > r1，则增加 nums1 的分割点，减少 nums2 的分割点\n            left = i + 1;\n        }\n    }\n\n    return -1;  // 如果没有找到合适的分割点，返回 -1\n}\n```\n---\n## 总结\n\n本文围绕 LeetCode Hot100 中六道典型题目，系统梳理了二分查找在一维与二维场景下的多种变体应用：\n1. 基础形式（如搜索插入位置）：直接在单调数组中查找目标或确定插入点，使用标准左闭右闭模板即可\n2. 二维扩展（如搜索二维矩阵）：将二维结构逻辑上展平为一维升序序列，通过下标映射实现二分\n3. 边界查找（如查找元素首尾位置）：借助下界（lower bound）思想，两次调用二分分别定位左右边界\n4. 旋转数组处理（如搜索旋转排序数组、寻找最小值）：利用旋转后“至少一半有序”的性质，通过判断哪一侧有序来决定搜索方向；找最小值时则聚焦于“无序侧必含最小值”的特性\n5. 跨数组二分（如寻找两个正序数组的中位数）：不合并数组，而是在较短数组上二分“分割点”，使得左右两部分满足中位数划分条件，体现了二分思想在更复杂结构中的灵活运用\n   \n**核心思想：**  明确搜索空间、设计合理的判断条件以排除无效区间、正确更新边界并处理边界情况","tags":["二分查找"],"categories":["leetcode刷题笔记","C语言"]},{"title":"哈希表之Uthash应用","url":"/2026/01/12/哈希表之Uthash应用/","content":"\n## Uthash总览\n\n### 哈希表介绍\n哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。在这哈希表中，每一个元素的key和它的存储位置都存在一个f(key)的映射关系，我们可以通过f(key)快速的查找到这个元素在表中的位置\n\n### Uthash简介\nUthash是一个用C语言编写的开源哈希表库，它提供了简单易用的接口来创建和操作哈希表。Uthash支持多种数据类型作为键，并且可以动态调整哈希表的大小以适应数据量的变化\n\n---\n## hot100中Uthash的应用\n\n### 1. 两数之和\n\n[LeetCode 1. 两数之和](https://leetcode.cn/problems/two-sum/)\n\n**问题描述：** 给定一个整数数组`nums`和一个目标值`target`，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标\n\n**Uthash应用：** 使用Uthash存储数组元素及其索引，在遍历数组时，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在\n\n**代码实现**\n```c\n\n//哈希表结构体\ntypedef struct{\n    int key;\n    int val;\n    UT_hash_handle hh;\n} hashTable;\n\n//定义全局变量哈希表指针，指向表头\nhashTable* table;\n\n//查找功能\nhashTable* find(int key){\n    hashTable* tmp;\n    HASH_FIND_INT(table,&key,tmp);\n    return tmp;\n}\n\n//插入功能\nvoid insert(int key,int val){\n    hashTable* node=find(key);\n    if(node==NULL){\n        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=key;\n        tmp->val=val;\n        HASH_ADD_INT(table,key,tmp);\n    }\n    else{\n        node->val=val;\n    }\n}\n\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    table=NULL;\n    for(int i=0;i<numsSize;i++){\n        hashTable* tmp=find(target-nums[i]);\n        if(tmp){\n            int* ret=(int*)malloc(sizeof(int)*2);\n            ret[0]=tmp->val;\n            ret[1]=i;\n            return ret;\n        }\n        else{\n            insert(nums[i],i);\n        }\n    }\n    *returnSize=0;\n    return NULL;\n}\n```\n本题的解题思路是：\n1. 遍历数组，对于每个元素，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在\n2. 如果存在，返回对应的索引；如果不存在，将当前元素及其索引插入哈希表中\n3. 最后是在O(n)的时间复杂度内解决问题\n\n---\n### 2. 字母异位词分组\n\n[LeetCode 49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)\n\n**问题描述：** 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串\n\n**Uthash应用：** 使用Uthash存储排序后的字符串作为键，原始字符串列表作为值，将异位词分组\n\n**代码实现**\n```c\n\n//结构体定义\ntypedef struct{\n    char* key;          //键：排序后的字符串\n    char** list;        //值：原始字符串列表\n    int cnt;            //当前字符串对应的列表大小\n    int capacity;       //列表容量\n    UT_hash_handle hh;  //哈希表句柄\n} hashTable;\n\nhashTable* table;\n\n//qsort比较函数需要使用的cmp函数\nint cmp(const void* a,const void* b){\n    return (*(char*)a-*(char*)b);\n}\n\nhashTable* find(char* key){\n    hashTable* tmp;\n    HASH_FIND_STR(table,key,tmp);\n    return tmp;\n}\n\n//这里需要注意字符串的+1是为了存储字符串的结束符'\\0'\nhashTable* insert(char* key,char* str){\n    hashTable* node=find(key);\n    if(node==NULL){\n        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=malloc(strlen(key)+1);\n        strcpy(tmp->key,key);\n        tmp->capacity=10;\n        tmp->cnt=0;\n        tmp->list=malloc(sizeof(char*)*tmp->capacity);\n        tmp->list[tmp->cnt]=malloc(strlen(str)+1);\n        strcpy(tmp->list[tmp->cnt],str);\n        tmp->cnt++;\n        HASH_ADD_STR(table,key,tmp);\n    }\n    else{\n        //如果容量不够则扩容\n        if(node->cnt>=node->capacity){\n            node->capacity*=2;\n            node->list=realloc(node->list,sizeof(char*)*node->capacity);\n        }\n\n        node->list[node->cnt]=malloc(strlen(str)+1);\n        strcpy(node->list[node->cnt],str);\n        node->cnt++;\n    }\n}\n\nchar*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes){\n    table=NULL;\n\n    //构建哈希表，插入键与值\n    for(int i=0;i<strsSize;i++){\n        int len=strlen(strs[i]);\n        char* sortedStr=malloc(len+1);\n        strcpy(sortedStr,strs[i]);\n        qsort(sortedStr,len,sizeof(char),cmp);\n        insert(sortedStr,strs[i]);\n        free(sortedStr);\n    }\n\n    *returnSize=HASH_COUNT(table);\n    char*** res = malloc(sizeof(char**) * (*returnSize));\n    *returnColumnSizes = malloc(sizeof(int) * (*returnSize));\n    int idx=0;\n    hashTable* node,*tmp;\n\n    //遍历哈希表，构建结果集\n    HASH_ITER(hh,table,node,tmp){\n        res[idx]=malloc(sizeof(char*)*node->cnt);\n        (*returnColumnSizes)[idx]=node->cnt;\n        for(int j=0;j<node->cnt;j++){\n            res[idx][j]=malloc(strlen(node->list[j])+1);\n            strcpy(res[idx][j],node->list[j]);\n        }\n        idx++;\n    }\n\n    //清理哈希表，释放内存\n    HASH_ITER(hh,table,node,tmp){\n        free(node->key);\n        for(int j=0;j<node->cnt;j++){\n            free(node->list[j]);   \n        }\n        free(node->list);\n        HASH_DEL(table,node);\n        free(node);\n    }\n    return res;\n}\n```\n本题的解题思路是：\n1. 遍历字符串数组，对于每个字符串，排序后作为键插入哈希表\n2. 如果键已存在，则将原始字符串添加到对应的值列表中\n3. 最后遍历哈希表，构建结果集\n\n---\n### 3. 最长连续序列\n\n[LeetCode 128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)\n\n**问题描述：** 给定一个未排序的整数数组，找出最长连续序列的长度\n\n**Uthash应用：** 使用Uthash存储数组元素，遍历数组时，检查每个元素的前后连续元素是否存在，计算最长连续序列长度\n\n**代码实现**\n```c\n#define MAX(a,b) ((a)>(b)?(a):(b))\n//哈希表结构体\ntypedef struct{\n    int key;\n    UT_hash_handle hh;\n} hashTable;\n\nint longestConsecutive(int* nums, int numsSize){\n    if(numsSize==0) return 0;\n    hashTable* table=NULL;\n\n    //构建哈希表,去重\n    for(int i=0;i<numsSize;i++){\n        hashTable* tmp;\n        HASH_FIND_INT(table,&nums[i],tmp);\n        if(tmp==NULL){\n            tmp=(hashTable*)malloc(sizeof(hashTable));\n            tmp->key=nums[i];\n            HASH_ADD_INT(table,key,tmp);\n        }\n    }\n\n    int longest=0;\n    hashTable* node,* findNode,* tmp;\n    HASH_ITER(hh,table,node,tmp){\n        int cur=node->key;\n        int prev=cur-1;\n        HASH_FIND_INT(table,&prev,findNode);\n        //不是序列的起点，跳过\n        if(findNode!=NULL) continue; \n        int cnt=1;\n        int next=cur+1;\n        HASH_FIND_INT(table,&next,findNode);\n        while(findNode!=NULL){\n            next++;\n            cnt++;\n            HASH_FIND_INT(table,&next,findNode);\n        }\n        longest=MAX(cnt,longest);\n    }\n\n    //释放哈希表内存\n    HASH_ITER(hh,table,node,tmp){\n        HASH_DEL(table,node);\n        free(node);\n    }\n    return longest;\n}\n```\n本题的解题思路是：\n1. 使用Uthash构建哈希表，这一步可以去重\n2. 遍历哈希表，找到每个可能连续序列的起点，这一步算是一个优化，不需要对每个数字都找到最后，只需要对序列起点开始寻找`cnt`，计算连续长度\n3. 最后比较`longest`与`cnt`，返回最长序列长度即可\n\n---\n### 4. 路径总和Ⅲ\n\n[LeetCode 437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)\n\n**问题描述：** 给定一个二叉树和一个整数目标和`targetSum`，找出路径总和等于目标和的路径数量。路径不需要从根节点开始或结束，但必须向下移动（只能从父节点到子节点）\n\n**Uthash应用：** 使用Uthash存储前缀和及其出现次数，在遍历二叉树时，计算当前路径的前缀和，并查找是否存在满足条件的前缀和\n\n**代码实现**\n```c\n//哈希表结构体\ntypedef struct{\n    long long sum;\n    int cnt;\n    UT_hash_handle hh;\n} PrefixSumNode;\n\nstatic PrefixSumNode* prefixMap=NULL;\n\nvoid dfsPathSum(struct TreeNode* root,long long currSum,int targetSum,int* ans){\n    if(root==NULL) return;\n    //计算当前前缀和\n    currSum+=root->val;\n    //计算还需要的前缀和\n    long long need=currSum-targetSum;\n    PrefixSumNode* find;\n    //如果能找到need，则说明存在满足条件的路径\n    HASH_FIND(hh,prefixMap,&need,sizeof(long long),find);\n    if(find){\n       *ans+=find->cnt;\n    }\n    //将当前前缀和加入哈希表\n    PrefixSumNode* currNode=NULL;\n    HASH_FIND(hh,prefixMap,&currSum,sizeof(long long),currNode);\n    if(currNode==NULL){\n       currNode=(PrefixSumNode*)malloc(sizeof(PrefixSumNode));\n       currNode->sum=currSum;\n       currNode->cnt=1;\n       HASH_ADD(hh,prefixMap,sum,sizeof(long long),currNode);\n    } else{\n       currNode->cnt++;\n    }\n    //递归计算左右子树\n    dfsPathSum(root->left,currSum,targetSum,ans);\n    dfsPathSum(root->right,currSum,targetSum,ans);\n    //回溯，移除当前前缀和\n    currNode->cnt--;\n    if(currNode->cnt==0){\n        HASH_DEL(prefixMap,currNode);\n        free(currNode);\n    }\n}\n\nint pathSum(struct TreeNode* root, int targetSum){\n    int ans=0;\n    prefixMap=NULL;\n    // 加入初始前缀和0，1次\n    PrefixSumNode* baseNode=(PrefixSumNode*)malloc(sizeof(PrefixSumNode));\n    baseNode->sum=0;\n    baseNode->cnt=1;\n    HASH_ADD(hh,prefixMap,sum,sizeof(long long),baseNode);\n\n    dfsPathSum(root,0,targetSum,&ans);\n    //释放哈希表内存\n    PrefixSumNode* node,*tmp;\n    HASH_ITER(hh,prefixMap,node,tmp){\n        HASH_DEL(prefixMap,node);\n        free(node);\n    }\n    return ans;\n}\n```\n本题使用哈希表的优势如下：\n1. 使用`Uthash`存储前缀和及其出现次数，可以在`O(1)`时间内查找是否存在满足条件的前缀和\n2. 通过前缀和的概念，可以高效地计算路径和，类似与两数之和的去查找`need`\n3. 本题的一个重点就是`need=currSum-targetSum`，通过这个公式可以快速定位到满足条件的前缀和，从而计算路径数量\n\n解题思路如下：\n1. 使用DFS遍历二叉树，使用哈希表储存当前节点的前缀和（当前路径上的），通过前缀和之差计算出其中子路径的路径之和，判断是否等于`targetSum`\n2. 哈希表还要储存`cnt`，表示当前前缀和出现的次数，因为可能存在多条路径的前缀和相同\n3. 注意本题还需要回溯，在DFS返回上一层时，需要将当前前缀和的计数减一，确保哈希表中只包含当前路径上的前缀和信息\n\n---\n### 5. 从前序与中序遍历序列构造二叉树\n\n[LeetCode 105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n**问题描述：** 给定两个整数数组`preorder`和`inorder`，其中`preorder`是二叉树的前序遍历，`inorder`是二叉树的中序遍历，请构造二叉树并返回其根节点\n\n**Uthash应用：** 使用Uthash存储中序遍历数组中每个元素的索引，便于在构建二叉树时快速定位根节点在中序遍历中的位置，本题使用哈希表主要在于优化查找位置\n\n**代码实现**\n```c\n//结构体定义\ntypedef struct{\n    int key;\n    int val;\n    UT_hash_handle hh;\n} hashTable;\n\nhashTable* table;\n\n struct TreeNode* buildTreeHelper(int* preorder,int lpre,int rpre,int* inorder,int lin,int rin){\n    if(lpre>rpre || lin>rin) return NULL;\n    // 找到根节点（先序序列当前区间的第一个节点）在中序遍历中的位置\n    int rootVal=preorder[lpre];\n    hashTable* find;\n    HASH_FIND_INT(table,&rootVal,find);\n    int k=find->val;\n    // 构造二叉树\n    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val=rootVal;\n    int leftSize=k-lin;\n\n    root->left=builedTreeHelper(preorder,lpre+1,lpre+leftSize,inorder,lin,k-1);\n    root->right=builedTreeHelper(preorder,lpre+leftSize+1,rpre,inorder,k+1,rin);\n    \n    return root;\n }\n\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize){\n    table=NULL;\n    // 构建哈希表，存储中序遍历数组中每个元素的索引\n    for(int i=0;i<inorderSize;i++){\n        hashTbale* tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=inorder[i];\n        tmp->val=i;\n        HASH_ADD_INT(table,key,tmp);\n    }\n    struct TreeNode* root=buildTreeHelper(preorder,0,preorderSize-1,inorder,0,inorderSize-1);\n\n    hashTable* tmp,* curr;\n    HASH_ITER(hh,table,curr,tmp){\n        HASH_DEL(table,curr);\n        free(curr);\n    }\n    return root;\n}\n```\n\n本题相比如下的原始版本：\n\n```c\nstruct  TreeNode* Tree(int* preorder,int lpre,int rpre,int *inorder,int lin,int rin){\n    if(lpre > rpre || lin > rin)\n        return NULL;\n    int k;\n    for(k=lin;k<=rin;k++){\n        if(inorder[k]==preorder[lpre]){\n            break;\n        }\n    }\n    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));\n    root->val=preorder[lpre];\n    int leftSize = k - lin;\n    root->left=Tree(preorder,lpre+1,lpre+leftSize,inorder,lin,k-1);\n    root->right=Tree(preorder,lpre+leftSize+1,rpre,inorder,k+1,rin);\n    return root;\n}\nstruct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) {\n    return Tree(preorder,0,preorderSize-1,inorder,0,inorderSize-1);\n}\n```\n\n使用哈希表的优势如下：\n1. 使用`Uthash`存储中序遍历数组中每个元素的索引，可以在`O(1)`时间内查找根节点在中序遍历中的位置\n2. 避免了在每次递归中使用循环查找根节点位置，提升了整体构建二叉树的效率\n\n解题思路如下：\n1. 使用`Uthash`构建哈希表，存储中序遍历数组中每个元素的索引\n2. 递归构建二叉树，利用哈希表快速定位根节点在中序遍历中的位置，划分左右子树\n3. 最后释放哈希表内存，返回构建好的二叉树根节点\n\n---\n\n### 6. 多数元素\n\n[LeetCode 169. 多数元素](https://leetcode.cn/problems/majority-element/)\n\n**问题描述：** 给定一个大小为`n`的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于`⌊ n/2 ⌋`的元素\n\n**Uthash应用：** 使用Uthash存储数组元素及其出现次数，遍历数组时，更新哈希表中的计数，最后找到出现次数超过`n/2`的元素\n\n**代码实现**\n```c\n//哈希表结构体\ntypedef struct{\n    int key;\n    int val;\n    UT_hash_handle hh;\n} hashTable;\n\nint majorityElement(int* nums, int numsSize){\n    hashTable* table=NULL;\n    // 构建哈希表，统计每个元素的出现次数\n    for(int i;i<numsSize;i++){\n        hashTable* node;\n        HASH_FIND_INT(table.&nums[i],node);\n        if(node==NULL){\n            node=(hashTable*)malloc(sizeof(hashTable));\n            node->key=nums[i];\n            node->val=1;\n            HASH_ADD_INT(table,key,node);\n        } else{\n            node->val++;\n        }\n    }\n\n    int ans;\n    int maxCnt=0;\n    hashTable* node,* tmp;\n    // 遍历哈希表，找到出现次数最多的元素\n    HASH_ITER(hh,table,node,tmp){\n        if(node->val>maxCnt){\n            max=node->val;\n            ans=node->key;\n        }\n    }\n    return ans;\n}\n```\n本题除了技巧方法，其他方法较为好想,在这里使用哈希表主要还是为了熟悉哈希表的使用\n\n---\n\n### 7. 随机链表的复制\n\n[LeetCode 138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)\n\n**问题描述：** 给定一个链表，每个节点包含一个额外的随机指针，该指针可以指向链表中的任何节点或`null`。请实现一个函数来复制这个链表\n\n**Uthash应用：** 使用Uthash存储原始节点与其对应的复制节点的映射关系，在遍历原始链表时，创建复制节点并更新随机指针\n\n**代码实现**\n```c\n// 哈希表结构体\ntypedef struct{\n    struct Node* key;\n    struct Node* val;\n    UT_hash_handle hh;\n} hashTable;\n\nstruct Node* copyRandomList(struct Node* head){\n    if(!head) return NULL;\n    hashTable* table=NULL;\n    struct Node* curr=head;\n    // 构建哈希表，存储原始节点与复制节点的映射关系\n    while(curr){\n        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));\n        newNode->val=curr->val;\n        newNode->next=NULL;\n        newNode->random=NULL;\n        \n        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=curr;\n        tmp->val=newNode;\n        HASH_ADD_PTR(table,key,tmp);\n\n        curr=curr->next;\n    }\n\n    // 更新复制节点的next和random指针\n    curr=head;\n    while(curr){\n        hashTable* find;\n        HASH_FIND_PTR(table,&curr,find);\n        struct Node* newNode=find->val;\n\n        // 设置next指针\n        if(curr->next){\n            HASH_FIND_PTR(table,&curr->next,find);\n            newNode->next=find->val;\n        } else{\n            newNode->next=NULL;\n        }\n\n        // 设置random指针\n        if(curr->random){\n            HASH_FIND_PTR(table,&curr->random,find);\n            newNode->random=find->val;\n        } else{\n            newNode->random=NULL;\n        }\n\n        curr=curr->next;\n    }\n\n    // 返回复制链表的头节点\n    hashTable* findHead;\n    HASH_FIND_PTR(table,&head,findHead);\n    struct Node* newHead=findHead->val;\n\n    hashTable* curr,* tmp;\n    HASH_ITER(hh,table,curr,tmp){\n        HASH_DEL(table,curr);\n        free(curr);\n    }\n\n    return newHead;\n}\n```\n本题的解题思路是：\n1. 遍历原始链表，使用哈希表存储每个原始节点与其对应的复制节点的映射关系\n2. 再次遍历原始链表，使用哈希表更新复制节点的`next`和`random`指针\n3. 最后返回复制链表的头节点\n\n\n除了上述的方法外，还有一种哈希表+递归的方法:\n1. 我们用哈希表记录每一个节点对应新节点的创建情况。\n2. 遍历该链表的过程中，我们检查`当前节点的后继节点`和`当前节点的随机指针指向的节点`的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。\n3. 当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。\n4. 注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。\n\n下面我会给出代码实现：\n\n```c\n// 哈希表结构体\ntypedef struct{\n    struct Node* key;\n    struct Node* val;\n    UT_hash_handle hh;\n} hashTable;\n\nhashTable* table;\n\nstruct Node* deepCopy(struct Node* head){\n    if(head==NULL) return NULL;\n    hashTable* tmp;\n    HASH_FIND_PTR(table,&head,tmp);\n    if(tmp==NULL){\n        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));\n        newNode->val=head->val;\n        tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=head;\n        tmp->val=newNode;\n        HASH_ADD_PTR(table,key,tmp);\n        newNode->next=deepCopy(head->next);\n        newNode->random=deepCopy(head->random);\n    }\n    return tmp->val;\n}\n\nstruct Node* copyRandomList(struct Node* head){\n    table=NULL;\n    struct Node* newHead=deepCopy(head);\n    hashTable* curr,* tmp;\n    HASH_ITER(hh,table,curr,tmp){\n        HASH_DEL(table,curr);\n        free(curr);\n    }\n    return newHead;\n}\n```\n\n---\n\n### 8. 相交链表\n\n[LeetCode 160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n**问题描述：** 给定两个单链表的头节点`headA`和`headB`，找出并返回两个链表相交的起始节点。如果两个链表没有交点，返回`null`\n\n**Uthash应用：** 使用Uthash存储第一个链表的节点地址，在遍历第二个链表时，检查节点是否存在于哈希表中，找到相交节点\n\n**代码实现**\n```c\ntypedef struct{\n    struct ListNode* key;\n    UT_hash_handle hh;\n} hashTable;\n\nstruct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB){\n    hashTable* table=NULL;\n    struct ListNode* curr=headA;\n    // 构建哈希表，存储第一个链表的节点地址\n    while(curr){\n        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));\n        tmp->key=curr;\n        HASH_ADD_PTR(table,key,tmp);\n        curr=curr->next;\n    }\n\n    // 遍历第二个链表，检查节点是否存在于哈希表中\n    curr=headB;\n    while(curr){\n        hashTable* find;\n        HASH_FIND_PTR(table,&curr,find);\n        if(find){\n            return curr;\n        }\n        curr=curr->next;\n    }\n\n    return NULL;\n}\n```\n本题的解题思路是：\n1. 遍历第一个链表，将每个节点的地址存储在哈希表中\n2. 遍历第二个链表，检查每个节点是否存在于哈希表中\n3. 如果找到相交节点，返回该节点；如果遍历结束未找到，返回`null`\n\n---\n\n### 9. 和为k的子数组\n\n[LeetCode 560. 和为k的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)\n\n**问题描述：** 给定一个整数数组`nums`和一个整数`k`，请你统计并返回该数组中和为`k`的连续子数组的个数\n\n**Uthash应用：** 使用Uthash存储前缀和及其出现次数，在遍历数组时，计算当前前缀和，并查找是否存在满足条件的前缀和\n\n**前缀和思想** 本题与之前的路径总和Ⅲ(- [4. 路径总和Ⅲ](#4-路径总和Ⅲ))类似，都是利用前缀和的思想来解决问题。前缀和是指从数组开头到当前位置的元素之和。通过计算当前前缀和与目标值的差值，我们可以快速定位到满足条件的前缀和，从而计算出连续子数组的个数\n\n**代码实现**\n```c\ntypedef struct {\n    int sum;          // 当前前缀和\n    int count;        // 前缀和出现的次数\n    UT_hash_handle hh; // uthash 处理的哈希句柄\n} HashMapEntry;\n\nint subarraySum(int* nums, int numsSize, int K) {\n    HashMapEntry* sum_map = NULL;  // 哈希表的头指针\n    HashMapEntry* entry;\n    int current_sum = 0;\n    int count = 0;\n\n    // 初始情况下，前缀和为0出现一次\n    entry = (HashMapEntry*)malloc(sizeof(HashMapEntry));\n    entry->sum = 0;\n    entry->count = 1; // sum=0 出现 1 次\n    HASH_ADD_INT(sum_map, sum, entry);\n\n    for (int i = 0; i < numsSize; i++) {\n        current_sum += nums[i];  // 更新当前的前缀和\n        int target = current_sum - K;\n\n        // 查找前缀和为 target 的条目\n        HASH_FIND_INT(sum_map, &target, entry);\n        if (entry) {\n            count += entry->count;  // 如果存在，累加计数\n        }\n\n        // 更新当前前缀和在哈希表中的计数\n        HASH_FIND_INT(sum_map, &current_sum, entry);\n        if (entry) {\n            entry->count += 1;\n        } else {\n            entry = (HashMapEntry*)malloc(sizeof(HashMapEntry));\n            entry->sum = current_sum;\n            entry->count = 1;\n            HASH_ADD_INT(sum_map, sum, entry);\n        }\n    }\n\n    // 清理哈希表内存\n    HashMapEntry *tmp, *current_entry;\n    HASH_ITER(hh, sum_map, current_entry, tmp) {\n        HASH_DEL(sum_map, current_entry);\n        free(current_entry);\n    }\n\n    return count;\n}\n```\n\n本题的解题思路是：\n1. 使用`Uthash`构建哈希表，存储前缀和及其出现次数\n2. 遍历数组，计算当前前缀和，并查找是否存在满足条件的前缀和\n3. 如果存在，累加计数；如果不存在，更新当前前缀和在哈希表中的计数\n4. 最后返回计数结果\n\n---\n\n## 总结\n以上题目均是我在刷题过程中碰见的有关哈希表的题目，目前还在c语言，没有自带的哈希表数据结构，只能使用`Uthash`来进行实现，这些题目既可以帮助我学习哈希表的使用方法，也可以帮助我入门`Uthash`的使用，等到后面使用c++和python的时候应该就会轻松很多\n","tags":["算法","哈希表"],"categories":["leetcode刷题笔记","C语言"]},{"title":"回溯算法","url":"/2026/01/11/回溯算法/","content":"\n\n## 一、什么时候该想到「回溯 / DFS」？\n\n只要题目出现这些关键词之一，优先考虑回溯：\n\n- \"所有可能 / 全部方案 / 所有组合\"\n- \"列举 / 返回所有\"\n- \"是否存在一种方式\"\n- \"组合 / 排列 / 子集\"\n- \"选择 or 不选择\"\n- \"一步一步尝试，失败就退回\"\n\n**本质一句话：**\n\n这是一个「多步决策，每一步有多个选择」的问题\n\n## 二、回溯题的 5 大核心题型\n\n### ① 组合类（Combination）\n\n#### 典型题目\n\n- 电话号码的字母组合\n- 组合总和\n- k 个数的组合\n- 选若干个元素满足条件\n\n#### 特征\n\n- 顺序不重要\n- 不允许重复 / 有条件限制\n- \"选哪个\"比\"选的顺序\"重要\n\n#### 抽象模型\n\n在一个候选集合中  \n一步一步做选择  \n最终得到一个合法组合\n\n#### 思考套路\n\n- 当前能选什么？\n- 下一步从哪里开始选？\n- 什么时候算完成？\n \n#### 模板（核心）\n\n```c\nvoid dfs(int start) {\n    if (满足条件) {\n        保存结果;\n        return;\n    }\n    for (int i = start; i < n; i++) {\n        选择 i;\n        dfs(i + 1);\n        撤销选择;\n    }\n}\n```\n\n**注意：** 在组合类问题中，通过控制起始索引避免重复选择，确保组合的唯一性。\n\n### ② 排列类（Permutation）\n\n#### 典型题目\n\n- 全排列\n- 字符串全排列\n- 有 / 无重复元素的排列\n\n#### 特征\n\n- 顺序很重要\n- 同样的数字换顺序算不同结果\n\n#### 抽象模型\n\n每一位都要选一个没用过的数\n\n#### 思考套路\n\n- 当前是第几位？\n- 哪些元素还没用？\n- 用一个 visited[] 标记\n\n#### 模板\n\n```c\nvoid dfs(int depth) {\n    if (depth == n) {\n        保存结果;\n        return;\n    }\n    for (int i = 0; i < n; i++) {\n        if (used[i]) continue;\n        used[i] = 1;\n        path[depth] = nums[i];\n        dfs(depth + 1);\n        used[i] = 0;\n    }\n}\n```\n\n**注意：** 排列类需要使用 visited 数组来标记已使用的元素，避免重复使用同一元素。\n\n### ③ 子集类（Subset / 选或不选）\n\n#### 典型题目\n\n- 子集\n- 子集 II（含重复）\n- 所有子序列\n\n#### 特征\n\n- 每个元素只有两种状态：选 / 不选\n- 没有顺序概念\n\n#### 抽象模型（决策树）\n\n```\n          []\n        /    \\\n      选      不选\n```\n\n#### 思考套路\n\n- 到第 i 个元素\n- 做 2 个决定\n\n#### 模板\n\n```c\nvoid dfs(int i) {\n    if (i == n) {\n        保存结果;\n        return;\n    }\n    // 不选\n    dfs(i + 1);\n\n    // 选\n    path.push(nums[i]);\n    dfs(i + 1);\n    path.pop();\n}\n```\n\n**注意：** 子集类通过递归遍历每个元素的选择状态，生成所有可能的子集。\n\n### ④ 路径 / 棋盘 / 搜索类（DFS 搜索）\n\n#### 典型题目\n\n- 单词搜索\n- 迷宫路径\n- N 皇后\n- 数独\n\n#### 特征\n\n- 在「二维 / 多维空间」中走\n- 有方向、边界、障碍\n- 常有 visited 标记\n\n#### 抽象模型\n\n从一个点出发  \n向多个方向尝试  \n不合法就退回\n\n#### 思考套路\n\n- 当前在哪？\n- 能往哪走？\n- 什么时候停止？\n- 如何标记访问？\n\n#### 模板\n\n```c\nvoid dfs(int x, int y) {\n    if (越界 / 不合法) return;\n    if (找到答案) return;\n\n    visited[x][y] = 1;\n    for (方向) {\n        dfs(nx, ny);\n    }\n    visited[x][y] = 0;\n}\n```\n\n**注意：** 在搜索类问题中，visited 数组防止重复访问同一位置，确保路径的正确性。\n\n### ⑤ 分割 / 构造类（切分字符串）\n\n#### 典型题目\n\n- 回文串分割\n- IP 地址还原\n- 表达式添加运算符\n\n#### 特征\n\n- 从字符串中「切一刀」\n- 每一段要合法\n\n#### 抽象模型\n\n当前位置开始  \n尝试切不同长度\n\n#### 思考套路\n\n- 从哪切？\n- 切多长？\n- 这一段是否合法？\n\n#### 模板\n\n```c\nvoid dfs(int start) {\n    if (start == len) {\n        保存结果;\n        return;\n    }\n    for (int i = start; i < len; i++) {\n        if (合法(start, i)) {\n            path.push(s[start..i]);\n            dfs(i + 1);\n            path.pop();\n        }\n    }\n}\n```\n\n**注意：** 分割类需要验证每段的合法性，如回文或有效IP段。\n\n## 三、回溯题要素\n\n\n1. **一步要做什么决定？**  \n   选哪个数？  \n   往哪个方向走？  \n   切多长？\n\n2. **选择列表是什么？**  \n   当前能选的所有可能\n\n3. **什么时候结束？**  \n   深度到头  \n   条件满足\n\n4. **如何回退？**  \n   覆盖  \n   pop  \n   visited 还原\n\n回溯算法的核心在于通过递归探索所有可能的解决方案，并在不满足条件时回退。实践中，要注意剪枝优化，避免不必要的计算。\n\n## 四、回溯算法的剪枝优化\n\n### 剪枝的基本概念\n\n**如何剪枝：** 通过在递归过程中添加条件判断，提前终止不可能成功的分支，从而减少搜索空间，提高效率。\n\n**什么时候剪枝：** 当当前状态或路径不可能达到目标条件时，进行剪枝。例如，当前和超过目标、剩余元素不足等。\n\n### 常见剪枝技巧分类讨论\n\n#### 1. 排序去重剪枝\n\n- **适用题型：** 组合类（Combination）、子集类（Subset）中含有重复元素的题目，如子集 II、组合总和 II。\n- **如何剪枝：** 对候选数组进行排序，在选择元素时跳过与前一个相同的元素，避免生成重复结果。\n- **代码示例：**\n  ```c\n  // 在组合类中\n  for (int i = start; i < n; i++) {\n      if (i > start && nums[i] == nums[i-1]) continue;  // 跳过重复\n      // 选择 i\n  }\n  ```\n- **什么时候使用：** 当题目允许重复选择但结果不能重复时。\n\n#### 2. 限制条件剪枝\n\n- **适用题型：** 组合总和类、背包问题变体。\n- **如何剪枝：** 在递归中检查当前累积值（如和、积）是否超过限制，如果超过则提前返回。\n- **代码示例：**\n  ```c\n  if (currentSum > target) return;  // 组合总和\n  ```\n- **什么时候使用：** 当有数值限制（如和不能超过目标）时。\n\n#### 3. 长度限制剪枝\n\n- **适用题型：** 组合类（指定组合长度）、排列类（部分排列）。\n- **如何剪枝：** 计算剩余可选元素数量，如果不足以达到所需长度，则停止递归。\n- **代码示例：**\n  ```c\n  if (n - i < k - path.size()) return;  // k 个数的组合\n  ```\n- **什么时候使用：** 当组合或排列有固定长度要求时。\n\n#### 4. 对称性剪枝\n\n- **适用题型：** N 皇后、其他对称性问题。\n- **如何剪枝：** 利用问题的对称性，只搜索一半或四分之一的空间，然后通过对称生成另一半。\n- **代码示例：** 在 N 皇后中，只考虑皇后放在左半边。\n- **什么时候使用：** 当问题具有对称性，且结果可以通过对称变换得到时。\n\n#### 5. 搜索类剪枝（路径 / 棋盘）\n\n- **适用题型：** 单词搜索、迷宫路径、数独。\n- **如何剪枝：** 使用 visited 数组避免重复访问同一位置；边界检查；提前判断是否可能到达目标。\n- **代码示例：**\n  ```c\n  if (x < 0 || x >= m || y < 0 || y >= n || visited[x][y]) return;\n  ```\n- **什么时候使用：** 在二维或多维空间搜索时，防止循环和无效路径。\n\n#### 6. 分割类剪枝\n\n- **适用题型：** 回文串分割、IP 地址还原。\n- **如何剪枝：** 在分割时，检查当前段是否合法（如是否为回文、有效IP段），不合法则跳过。\n- **代码示例：**\n  ```c\n  if (!isPalindrome(s, start, i)) continue;  // 回文分割\n  ```\n- **什么时候使用：** 当分割后的每段必须满足特定条件时。\n\n## 五、LeetCode 回溯算法实战合集\n\n### 1. 分割 / 构造类\n\n这些问题涉及按某些特定条件对字符串、数字等进行切割或构造特定的结构。\n\n#### 131. 分割回文串\n\n[LeetCode 131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)\n\n**核心方向：**按回文条件切割字符串，枚举所有回文切割方案。\n\n**回溯技巧：**递归切割，每次递归检查子串是否为回文。\n\n```c\n//1.回溯算法\nchar*** result;\nchar** path;\nint pathSize = 0;\n\n// 判断s字符串中的子串是否为回文串\nbool isPalindrome(char* s, int startIndex, int endIndex){\n    while(startIndex <= endIndex){\n        if(s[endIndex--] != s[startIndex++]){\n            return false;\n        }\n    }\n    return true;\n}\n\nvoid backtracking(char* s, int* returnSize, int startIndex, int** returnColumnSizes){\n    if(startIndex == strlen(s)){\n        result[*returnSize] = (char**)malloc(sizeof(char*) * pathSize);\n        for(int i = 0; i < pathSize; i++){\n            result[*returnSize][i] = path[i]; \n        }\n        (*returnColumnSizes)[(*returnSize)++] = pathSize;\n        return;\n    }\n\n    for(int i = startIndex; i < strlen(s); i++){\n        if(isPalindrome(s, startIndex, i)){\n            char* temp = (char*)malloc(sizeof(char) * (i - startIndex + 2));\n            int index = 0;\n            for(int j = startIndex; j <= i; j++){\n                temp[index++] = s[j];\n            }\n            temp[index] = '\\0';\n            path[pathSize++] = temp;\n        }\n        else{\n            continue;\n        }\n        backtracking(s, returnSize, i + 1, returnColumnSizes);\n        \n        pathSize--;\n    }\n}\nchar*** partition(char* s, int* returnSize, int** returnColumnSizes) {\n    result = (char***)malloc(sizeof(char**) * 100000);\n    path = (char**)malloc(sizeof(char*) * 100000);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 100000);\n    *returnSize = 0;\n\n    backtracking(s, returnSize, 0, returnColumnSizes);\n    return result;\n}\n```\n\n#### 22. 括号生成\n\n[LeetCode 22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)\n\n**核心方向：**生成所有合法的括号组合（左括号数 = 右括号数）。\n\n**回溯技巧：**递归生成括号，剪枝（如左括号数 ≤ n、右括号数 ≤ 左括号数）。\n\n```c\n//1.回溯算法\nvoid dfs(char** res, int* returnSize, char* path, int pos, int left, int right, int n) {\n\n    // 终止条件：构造完成\n    if (pos == 2 * n) {\n        res[*returnSize] = (char*)malloc(2 * n + 1);\n        memcpy(res[*returnSize], path, 2 * n + 1);\n        (*returnSize)++;\n        return;\n    }\n\n    // 尝试放 '('\n    if (left < n) {\n        path[pos] = '(';\n        dfs(res, returnSize, path, pos + 1, left + 1, right, n);\n    }\n\n    // 尝试放 ')'\n    if (right < left) {\n        path[pos] = ')';\n        dfs(res, returnSize, path, pos + 1, left, right + 1, n);\n    }\n}\n\nchar** generateParenthesis(int n, int* returnSize) {\n    *returnSize = 0;\n    char** res = (char**)malloc(sizeof(char*) * 1500);\n    char* path = (char*)malloc(2 * n + 1);\n    path[2 * n] = '\\0';\n\n    dfs(res, returnSize, path, 0, 0, 0, n);\n    free(path);\n    return res;\n}\n```\n\n### 2. 路径 / 棋盘 / 搜索类\n\n这些问题通常涉及在二维或多维的空间中搜索路径。\n\n#### 79. 单词搜索\n\n[LeetCode 79. 单词搜索](https://leetcode.cn/problems/word-search/)\n\n**核心方向：**在二维网格中搜索目标字符串的路径。\n\n**回溯技巧：**标记访问过的格子，避免重复走，剪枝（越界或字符不匹配时终止）。\n\n```c\n//1.回溯算法\nvoid backTracking(char** board,int m,int n,char* word,int size,int row,int col,bool* flag,int** used){\n    if(*flag) return;\n    if(word[size]=='\\0'){\n        *flag=true;\n        return;\n    }\n    //这里要注意对row和col的越界判断应该放在最前面，否则无法后面的数组判定无法进行\n    if (row < 0 || row >= m || col < 0 || col >= n || board[row][col] != word[size] || used[row][col] == 1) {\n        return;\n    }\n    used[row][col]=1;\n    backTracking(board,m,n,word,size+1,row+1,col,flag,used);\n    backTracking(board,m,n,word,size+1,row-1,col,flag,used);\n    backTracking(board,m,n,word,size+1,row,col+1,flag,used);\n    backTracking(board,m,n,word,size+1,row,col-1,flag,used);\n    used[row][col]=0;\n\n}\nbool exist(char** board, int boardSize, int* boardColSize, char* word) {\n    int m=boardSize;\n    int n=boardColSize[0];\n    bool flag=false;\n    int** used = (int**)malloc(m * sizeof(int*));\n    for (int i = 0; i < m; i++) {\n    used[i] = (int*)malloc(n * sizeof(int));\n    memset(used[i], 0, n * sizeof(int));\n    }\n\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            if (board[i][j] == word[0]) {  // 如果当前字符匹配，开始回溯\n                backTracking(board, m, n, word, 0, i, j, &flag, used);\n                if (flag) return true;  // 找到匹配的单词\n            }\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        free(used[i]);\n    }\n    free(used);\n\n    return flag;\n}\n```\n\n### 3. 子集类\n\n这些问题通常是枚举所有可能的子集，包含空集。\n\n#### 78. 子集\n\n[LeetCode 78. 子集](https://leetcode.cn/problems/subsets/)\n\n**核心方向：**枚举一个集合的所有子集（包括空集）。\n\n**回溯技巧：**通过 start 参数控制选择顺序，避免重复子集。\n\n```c\n//1.递归法（回溯）\nvoid dfs(int* nums, int numsSize, int start,int* path, int pathSize,int** res, int* returnSize, int* colSizes) {\n    // 保存当前子集\n    res[*returnSize] = (int*)malloc(sizeof(int) * pathSize);\n    memcpy(res[*returnSize], path, sizeof(int) * pathSize);\n    colSizes[*returnSize] = pathSize;\n    (*returnSize)++;\n\n    for (int i = start; i < numsSize; i++) {\n        path[pathSize] = nums[i];\n        dfs(nums, numsSize, i + 1, path, pathSize + 1, res, returnSize, colSizes);\n    }\n}\n\nint** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {\n    int maxSize = 1 << numsSize;\n    int** res = (int**)malloc(sizeof(int*) * maxSize);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * maxSize);\n\n    int* path = (int*)malloc(sizeof(int) * numsSize);\n    *returnSize = 0;\n\n    dfs(nums, numsSize, 0, path, 0, res, returnSize, *returnColumnSizes);\n\n    free(path);\n    return res;\n}\n```\n\n### 4. 排列类\n\n这些问题涉及到元素的排列，通常要求考虑元素顺序。\n\n#### 46. 全排列\n\n[LeetCode 46. 全排列](https://leetcode.cn/problems/permutations/)\n\n**核心方向：**枚举所有元素的排列。\n\n**回溯技巧：**标记已使用的元素，避免重复排列。处理重复元素时需要去重。\n\n```c\n//1.回溯算法\n/*\nvoid backtrack(当前状态, 其他参数) {\n    if (满足结束条件) {\n        记录结果;\n        return;\n    }\n\n    for (每个可能的选择) {\n        做出选择;           // 修改状态\n        backtrack(新状态, ...); // 递归\n        撤销选择;           // 恢复状态（关键！）\n    }\n}\n*/\n\nint count;\nvoid DFS(int *nums, int numsSize, int depth, int *path, bool *used, int **res) {\n\n    if (depth == numsSize) {\n        res[count] = (int *)malloc(sizeof(int) * numsSize);\n        memcpy(res[count++], path, sizeof(int) * numsSize);\n        return;\n    }\n\n    for (int i = 0; i < numsSize; i++) {\n        if (used[i] == true) {\n            continue;\n        }\n        path[depth] = nums[i];\n        used[i] = true;\n        DFS(nums, numsSize, depth + 1, path, used, res);\n\n        used[i] = false;\n    }\n}\nint** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){\n    (*returnSize) = 1;\n    for (int i = 1; i <= numsSize; i++) {\n        (*returnSize) *= i;\n    }\n\n    *returnColumnSizes = (int *)malloc(sizeof(int) * (*returnSize));\n    for (int i = 0; i < (*returnSize); i++) {\n        (*returnColumnSizes)[i] = numsSize;\n    }\n\n    int **res = (int **)malloc(sizeof(int *) * (*returnSize));\n    int *path = (int *)malloc(sizeof(int) * numsSize);\n    bool *used = (bool *)calloc(numsSize, sizeof(bool));\n\n    count = 0;\n    DFS(nums, numsSize, 0, path, used, res);\n    return res;\n}\n```\n\n### 5. 组合类\n\n这些问题通常涉及多个集合的组合或从一个集合中选择元素，可能会有条件限制（如总和、数量等）。\n\n#### 17. 电话号码的字母组合\n\n[LeetCode 17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)\n\n**核心方向：**多个数字对应字母集合，选一个字母组合。\n\n**回溯技巧：**每次递归选择一个字母，并递归继续选择下一个字母。\n\n```c\n//1.回溯 / DFS\nchar *map[10] = {\n    \"\", \"\", \"abc\", \"def\", \"ghi\",\n    \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"\n};\n\nvoid dfs(char *digits, int idx, char *path, char **res, int *returnSize) {\n    if (digits[idx] == '\\0') {\n        int len = strlen(path);\n        res[*returnSize] = malloc(len + 1);\n        memcpy(res[*returnSize], path, len + 1);  \n        (*returnSize)++;\n        return;\n    }\n\n    char *letters = map[digits[idx] - '0'];\n    for (int i = 0; letters[i]; i++) {\n        path[idx] = letters[i];\n        path[idx + 1] = '\\0';\n        dfs(digits, idx + 1, path, res, returnSize);\n    }\n}\n\nchar **letterCombinations(char *digits, int *returnSize) {\n    *returnSize = 0;\n    if (!digits || !digits[0]) return NULL;\n\n    int len = strlen(digits);\n    char **res = malloc(sizeof(char *) * 256);\n    char path[len + 1];\n\n    dfs(digits, 0, path, res, returnSize);\n    return res;\n}\n```\n\n#### 39. 组合总和\n\n[LeetCode 39. 组合总和](https://leetcode.cn/problems/combination-sum/)\n\n**核心方向：**从数组中选元素，使其和为目标值，允许重复选择。\n\n**回溯技巧：**递归选择，控制选择范围，剪枝（如果和超过目标值，则提前停止递归）。\n\n```c\n//1.回溯递归\nvoid dfs(int* candidates, int candidatesSize, int target, int* returnSize, int* path, int* returnColumnSizes, int pathSize, int** res, int start) {\n    if (target == 0) {\n        // 找到一个满足条件的组合\n        res[*returnSize] = (int*)malloc(sizeof(int) * pathSize);\n        memcpy(res[*returnSize], path, sizeof(int) * pathSize);\n        returnColumnSizes[*returnSize] = pathSize;  // 记录当前组合的大小\n        (*returnSize)++;  // 更新组合数量\n        return;\n    }\n    \n    if (target < 0) {\n        return;  // 剪枝：当 target 小于 0 时，当前路径无效\n    }\n\n    for (int i = start; i < candidatesSize; i++) {\n        path[pathSize] = candidates[i];  // 选择当前候选数\n        // 递归，允许同一个数字多次选择，因此 start 还是从 i 开始\n        dfs(candidates, candidatesSize, target - candidates[i], returnSize, path, returnColumnSizes, pathSize + 1, res, i);\n    }\n}\n\nint** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) {\n    *returnSize = 0;\n    int** res = (int**)malloc(sizeof(int*) * 150);\n    int* path = (int*)malloc(sizeof(int) *50);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * 150);\n\n    dfs(candidates, candidatesSize, target, returnSize, path, *returnColumnSizes, 0, res, 0);\n\n    free(path);\n    return res;\n}\n```","tags":["算法","回溯"],"categories":["leetcode刷题笔记","C语言"]},{"title":"二叉树系列之递归","url":"/2026/01/06/二叉树系列之递归/","content":"## 引言\n\n首先我们需要知道，二叉树非常适合递归处理，因为二叉树本身就是递归定义的：\n- 每个节点最多有两个子节点（左子树、右子树）\n- 每个子树本身又是一棵二叉树\n- 空树也是二叉树的一种情况（递归的终止条件）\n\n此外，二叉树问题可以自然地分解为处理该节点与其左右子树的问题\n\n递归问题需要注意以下三点：\n- **递归终止条件**：什么时候停止递归\n- **递归逻辑**：如何处理当前节点\n- **返回值**：向上一层返回什么\n\n接下来我会列出一些我自己在写力扣的时候遇到的部分题目\n\n---\n## 二叉树的中序遍历\n\n[LeetCode 94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n\n### 问题描述\n给定一个二叉树的根节点 `root` ，返回它的 **中序遍历** \n\n### 递归思路\n中序遍历的顺序是：左子树 → 根节点 → 右子树\n\n```c\nvoid inorder(struct TreeNode* root,int* num,int* ret){\n    if(root==NULL)\n    return;\n    inorder(root->left,num,ret);\n    ret[(*num)++]=root->val;\n    inorder(root->right,num,ret);    \n}\nint* inorderTraversal(struct TreeNode* root, int* returnSize) {\n    int *re =(int *)malloc(sizeof(int) * 501);\n    *returnSize = 0;\n    inorder(root,returnSize,re);\n    return re;\n}\n```\n这里有一点我一开始没注意，就是传入的 `returnSize` 其实是一个指针，在使用`inorder`函数时不需要 & 符号，直接传入 `returnSize` 即可\n\n---\n\n## 二叉搜索树中第K小的元素\n\n[LeetCode 230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)\n\n### 问题描述\n给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小的元素\n\n### 递归思路\n利用BST中序遍历有序性，递减k计数，提前返回进行优化\n\n### 代码实现\n\n```c\nvoid kFind(struct TreeNode* root, int* k, int* result){\n    if(root == NULL || *k == 0)//方便提前返回\n        return;\n    \n    kFind(root->left, k, result);\n    \n    (*k)--;\n    if(*k == 0){\n        *result = root->val;\n        return;\n    }\n    \n    kFind(root->right, k, result);\n}\n\nint kthSmallest(struct TreeNode* root, int k) {\n    int result = -1;\n    kFind(root, &k, &result);\n    return result;\n}\n```\n这里在`kFind`函数中增加了一个提前返回的条件，当`*k == 0`时，说明已经找到了第k小的元素，可以直接返回，避免不必要的递归调用\n\n---\n## 对称二叉树\n[LeetCode 101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)\n### 问题描述\n给你一个二叉树的根节点 `root` ， 检查它是否轴对称\n### 递归思路\n递归判断镜像，左子树的左孩子与右子树的右孩子对比\n### 代码实现\n```c\nbool isMirror(struct TreeNode* left, struct TreeNode* right){\n    if(!left&&!right)\n    return true;\n    if(!left||!right)\n    return false;\n    if(left->val!=right->val)\n    return false;\n    return isMirror(left->left,right->right)&&isMirror(left->right,right->left);\n} \nbool isSymmetric(struct TreeNode* root) {\n    if(root==NULL)\n    return true;\n    return isMirror(root->left,root->right);\n}\n```\n本题的思路还与一题判断两颗二叉树是否相同类似，不过那一题在递归传递参数时传递的是`root1`的左和`root2`的左，而本题传递的是`root`的左和`root`的右\n\n---\n## 二叉树的最大深度\n[LeetCode 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n### 问题描述\n给定一个二叉树的根节点 `root` ，返回其最大深度\n### 递归思路\n自底向上递归，`depth = max(leftDepth, rightDepth) + 1`\n### 代码实现\n```c\nint maxDepth(struct TreeNode* root) {\n    if(root==NULL)\n    return 0;\n    int lmax = maxDepth(root->left);\n    int rmax = maxDepth(root->right);\n    return(lmax>rmax?lmax:rmax)+1;\n}\n```\n本题是典型的自底向上递归，先计算左右子树的最大深度，然后取较大值加一返回\n\n---\n## 二叉树的直径\n[LeetCode 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)\n### 问题描述\n给定一棵二叉树，你需要计算它的直径长度。二叉树的直径长度是任意两个节点路径长度中的最大值。这条路径可能穿过根节点\n### 递归思路\n通过递归计算二叉树的最大深度，同时更新树的直径（即任意两个节点之间的最长路径）,最大深度函数返回左右子树深度的较大值，并更新全局最大路径值\n### 代码实现\n```c\nint maxDepth(struct TreeNode* root,int* maxl){\n    if(root==NULL)\n    return 0;\n    int lmax=maxDepth(root->left,maxl);\n    int rmax=maxDepth(root->right,maxl);\n    *maxl=fmax(*maxl,lmax+rmax);\n    return fmax(lmax,rmax)+1;\n}\nint diameterOfBinaryTree(struct TreeNode* root) {\n    if(root==NULL)\n    return 0;\n    int maxl=0;\n    maxDepth(root,&maxl);\n    return maxl;\n}\n```\n在`maxDepth`函数中，我们计算左右子树的深度，并更新`*maxl`为当前的最大直径。最终在`diameterOfBinaryTree`函数中返回这个最大直径值\n\n---\n## 翻转二叉树\n[LeetCode 226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)\n### 问题描述\n给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点\n### 递归思路\n递归交换每个节点的左右子节点\n### 代码实现\n```c\nstruct TreeNode* invertTree(struct TreeNode* root) {\n    if (root == NULL) {\n        return NULL;\n    }\n    \n    struct TreeNode* temp = root->left;\n    root->left = root->right;\n    root->right = temp;\n    \n    invertTree(root->left);\n    invertTree(root->right);\n    \n    return root;\n}\n```\n交换当前节点的左右子节点，接着递归调用`invertTree`函数来翻转左右子树,最后返回翻转后的根节点\n\n---\n## 二叉树的最近公共祖先\n[LeetCode 236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)\n### 问题描述\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先节点\n### 递归思路\n递归遍历树，判断当前节点是否为p或q，若是则返回当前节点，否则递归左右子树，若左右子树均返回非空节点，则当前节点即为最近公共祖先\n### 代码实现\n```c\nstruct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {\n    if (root == NULL || root == p || root == q) {\n        return root; // 找到 p 或 q 就不往下递归了\n    }\n    struct TreeNode* left = lowestCommonAncestor(root->left, p, q);\n    struct TreeNode* right = lowestCommonAncestor(root->right, p, q);\n    if (left && right) { // 左右都找到\n        return root; // 当前节点是最近公共祖先\n    }\n    // 如果只有左子树找到，就返回左子树的返回值\n    // 如果只有右子树找到，就返回右子树的返回值\n    // 如果左右子树都没有找到，就返回 NULL（注意此时 right = NULL）\n    return left ? left : right;\n}\n```\n这里的关键在于递归返回值的处理，通过判断左右子树的返回值来确定当前节点是否为最近公共祖先，像本题我们就要注意是后序遍历，因为这里我们需要左右子树的结果来决定当前节点的返回值\n\n---\n## 二叉树展开为链表\n[LeetCode 114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)\n### 问题描述\n给你二叉树的根节点 `root` ，请你将它展开为一个单链表：\n- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个节点，而左子指针始终为 `null` 。\n- 展开后的单链表应该与二叉树 先序遍历顺序相同。\n### 递归思路\n本题要求与先序遍历顺序相同，这里可以采用头插法，按照先序的逆序（右-左-根）来处理节点，即先处理右子树，再处理左子树，这样在构建链表时就能保证顺序正确\n### 代码实现\n```c\nvoid dfs(struct TreeNode* node, struct TreeNode** head) {\n    if (node == NULL) {\n        return;\n    }\n    dfs(node->right, head);\n    dfs(node->left, head);\n    node->left = NULL;\n    node->right = *head; // 头插法，相当于链表的 node->next = head\n    *head = node; // 现在链表头节点是 node\n}\n\nvoid flatten(struct TreeNode* root) {\n    struct TreeNode* head = NULL;\n    dfs(root, &head);\n}\n```\n在`dfs`函数中，我们先递归处理右子树，再处理左子树，这样可以确保我们按照先序遍历的顺序构建链表，通过头插法，我们将当前节点的右指针指向链表的头节点，并更新头节点为当前节点，最终实现了二叉树的展开为链表\n\n\n\n---\n\n## 深入理解：二叉树递归顺序的选择\n\n### 一、核心本质：二叉树递归 = 在\"什么时候\"处理当前节点\n\n任何二叉树递归，本质都是这三步的排列组合：\n- `dfs(node->left);`\n- `处理当前节点;`\n- `dfs(node->right);`\n\n不同的递归顺序，本质区别在于：**你希望在什么时候处理当前节点**\n\n| 递归顺序 | 处理节点的时机 | 本质含义 |\n|---------|--------------|---------|\n| 前序 | 先处理自己，再处理子树 | 自顶向下 |\n| 中序 | 左子树后、右子树前 | 与结构强相关 |\n| 后序 | 子树都处理完再处理自己 | 自底向上 |\n\n---\n\n### 二、不同递归顺序一般对应什么题目？\n\n#### ① 前序遍历（根 → 左 → 右）\n\n**特点**：先用当前节点的信息，再递归子树\n\n**适合的题目类型**\n\n\"当前节点会影响子节点\" 的问题\n\n**典型特征**：\n- 父节点的信息要传递给子节点\n- 路径类问题\n- 从根向下的构造、记录、判断\n\n**常见题目**\n- 路径和（Path Sum）\n- 根到叶子的路径\n- 验证 BST（携带 min/max）\n- 树的序列化\n- 建树（根据遍历）\n\n**思维模板**\n\n\"我要先知道当前节点是什么，再决定怎么走下去\"\n\n---\n\n#### ② 中序遍历（左 → 根 → 右）\n\n**特点**：节点处理夹在左右之间\n\n**适合的题目类型**\n\n和\"顺序\"\"结构\"强相关的题目，尤其是 BST（搜索二叉树）\n\n**常见题目**\n- 验证 BST（中序是否有序）\n- BST 转数组\n- 第 k 小元素\n- BST 相关统计\n\n**思维模板**\n\n\"左边处理完，当前节点才有意义\"\n\n---\n\n#### ③ 后序遍历（左 → 右 → 根）\n\n**特点**：先拿到子树结果，再处理当前节点\n\n**适合的题目类型**\n\n\"当前节点的结果依赖子树\"\n\n\n**常见题目**\n- 最大深度 / 最小深度\n- 直径\n- 是否平衡二叉树\n- 最大路径和\n- 翻转 / 删除 / 合并子树\n- flatten（二叉树展开）\n\n**思维模板**\n\n\"我得先知道左右子树情况，才能算我自己\"\n\n---\n\n### 三、核心判断技巧：三问法\n\n看到一个二叉树递归题，先别写代码，先问自己这三个问题：\n\n#### 问题 1：当前节点的结果，依赖谁？\n\n| 依赖对象 | 选择顺序 |\n|---------|---------|\n| 依赖父节点 | 前序 |\n| 依赖左右子树 | 后序 |\n| 依赖结构顺序 | 中序 |\n\n#### 问题 2：是\"向下传信息\"，还是\"向上汇总信息\"？\n\n| 信息流方向 | 顺序 |\n|-----------|-----|\n| 从根到叶子 | 前序 |\n| 从叶子到根 | 后序 |\n\n#### 问题 3：递归函数\"返回值\"代表什么？\n\n这是决定后序遍历的最重要信号\n\n**如果递归函数有明确的返回值含义，且这个返回值用于父节点计算**\n\n**大概率是后序遍历**\n\n\n---\n\n### 四、总结要点\n\n1. **前序 = 自顶向下传递信息**（父节点影响子节点）\n2. **中序 = BST 相关**（利用中序遍历的有序性）\n3. **后序 = 自底向上汇总信息**（子树结果影响父节点）\n\n\n","tags":["算法","二叉树","递归"],"categories":["leetcode刷题笔记","C语言"]},{"title":"链表系列之递归","url":"/2026/01/05/链表系列之递归/","content":"\n## 递归的本质\n\n递归是一种将大问题分解为相同结构小问题的编程技巧\n\n在链表中，递归特别适用，因为链表本身就是递归定义的：\n- 链表 = 头节点 + 剩余链表\n- 剩余链表 = 头节点 + 剩余链表\n- ...直到空节点\n\n递归解决链表问题的核心三要素：\n1. **递归终止条件**：什么时候停止递归\n2. **递归逻辑**：如何处理当前节点\n3. **返回值**：向上一层返回什么\n\n---\n\n## 入门篇：反转链表\n\n[LeetCode 206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n### 问题描述\n\n给定一个链表，反转整个链表并返回新的头节点\n\n### 递归思路\n\n假设链表为：1 → 2 → 3 → 4 → 5\n\n递归的思考方式：\n1. 先递归反转 2 → 3 → 4 → 5，得到 5 → 4 → 3 → 2\n2. 然后处理节点1，让2的next指向1\n3. 将1的next设为NULL\n\n### 代码实现\n\n```c\nstruct ListNode* reverseList(struct ListNode* head) {\n    if (head == NULL || head->next == NULL) {\n        return head;\n    }\n    struct ListNode* newHead = reverseList(head->next);\n    head->next->next = head;\n    head->next = NULL;\n    return newHead;\n}\n```\n\n### 递归过程图解\n\n```\n原链表：1 → 2 → 3 → NULL\n\n递归栈：\n第1层：reverseList(1) \n第2层：  reverseList(2)\n第3层：    reverseList(3)\n第4层：      reverseList(NULL) → 返回3\n\n回溯过程：\n第3层：3已反转，处理2 → 3 → 2，2.next = NULL\n       返回3\n第2层：3 → 2已反转，处理1 → 2 → 1，1.next = NULL\n       返回3\n\n最终：3 → 2 → 1 → NULL\n```\n\n### 关键点\n\n- 终止条件：head为空或head->next为空\n- 核心操作：`head->next->next = head`（让下一个节点指向当前节点）\n- 断开原连接：`head->next = NULL`（避免成环）\n- 返回值：新的头节点（始终是原链表的尾节点）\n\n---\n\n## 进阶篇一：合并两个有序链表\n\n[LeetCode 21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)\n\n### 问题描述\n\n将两个升序链表合并为一个新的升序链表\n\n### 递归思路\n\n每次选择两个链表中较小的头节点，然后递归处理剩余部分\n\n### 代码实现\n\n```c\nstruct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {\n    if (!list1) return list2;\n    if (!list2) return list1;\n    \n    if (list1->val < list2->val) {\n        list1->next = mergeTwoLists(list1->next, list2);\n        return list1;\n    } else {\n        list2->next = mergeTwoLists(list1, list2->next);\n        return list2;\n    }\n}\n```\n\n### 递归过程示例\n\n```\nlist1: 1 → 3 → 5\nlist2: 2 → 4 → 6\n\n第1层：比较1和2，选1，递归merge(3→5, 2→4→6)\n第2层：比较3和2，选2，递归merge(3→5, 4→6)\n第3层：比较3和4，选3，递归merge(5, 4→6)\n第4层：比较5和4，选4，递归merge(5, 6)\n第5层：比较5和6，选5，递归merge(NULL, 6)\n第6层：返回6\n\n回溯构建：1 → 2 → 3 → 4 → 5 → 6\n```\n\n### 关键点\n\n- 终止条件：任一链表为空，返回另一个链表\n- 递归逻辑：选择较小的节点，将其next指向递归结果\n- 时间复杂度：O(m+n)\n- 空间复杂度：O(m+n)（递归栈深度）\n\n---\n\n## 进阶篇二：两两交换链表节点\n\n[LeetCode 24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n\n### 问题描述\n\n给定一个链表，两两交换其中相邻的节点\n\n例如：1 → 2 → 3 → 4 变为 2 → 1 → 4 → 3\n\n### 递归思路\n\n1. 递归处理后续节点（从第3个节点开始）\n2. 交换当前的两个节点\n3. 返回新的头节点\n\n### 代码实现\n\n```c\nstruct ListNode* swapPairs(struct ListNode* head) {\n    if(!head || !head->next)\n        return head;\n    \n    struct ListNode* cur = head;\n    struct ListNode* next = head->next;\n    struct ListNode* tmp = next->next;\n    \n    next->next = cur;\n    cur->next = swapPairs(tmp);\n    \n    return next;  // 新的头节点\n}\n```\n\n### 递归过程图解\n\n```\n原链表：1 → 2 → 3 → 4\n\n第1层：处理1和2\n       递归处理3 → 4\n第2层：处理3和4\n       递归处理NULL\n       返回4\n       \n回溯：\n第2层：交换3和4，返回 4 → 3\n第1层：交换1和2，连接返回结果\n       2 → 1 → (4 → 3)\n       返回2\n\n最终：2 → 1 → 4 → 3\n```\n\n### 关键点\n\n- 终止条件：节点为空或只剩一个节点\n- 保存三个关键指针：cur、next、tmp\n- 返回值：交换后的新头节点（原来的第二个节点）\n\n---\n\n## 高级篇一：K个一组翻转链表\n\n[LeetCode 25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)\n\n### 问题描述\n\n给定一个链表，每k个节点一组进行翻转\n\n例如：1 → 2 → 3 → 4 → 5，k=2\n结果：2 → 1 → 4 → 3 → 5\n\n### 递归思路\n\n1. 检查是否有k个节点\n2. 如果有，翻转前k个节点\n3. 递归处理剩余部分\n4. 连接翻转后的部分和递归结果\n\n### 代码实现\n\n```c\nstruct ListNode* reverseKGroup(struct ListNode* head, int k) {\n    // 检查是否有k个节点\n    struct ListNode *p = head;\n    for(int i = 0; i < k; i++) {\n        if(!p) return head;  // 不足k个，直接返回head\n        p = p->next;\n    }\n    \n    // 翻转前k个节点\n    struct ListNode *q = head;\n    struct ListNode *pre = NULL;\n    \n    while(q != p) {  // 翻转从head到p的前k个节点\n        struct ListNode *tmp = q->next;\n        q->next = pre;\n        pre = q;\n        q = tmp;\n    }\n\n    head->next = reverseKGroup(p, k);\n    return pre;\n}\n```\n\n### 递归过程示例\n\n```\n原链表：1 → 2 → 3 → 4 → 5，k=2\n\n第1层：检查1,2存在\n       翻转1,2 得到 2 → 1\n       递归处理3 → 4 → 5\n       \n第2层：检查3,4存在\n       翻转3,4 得到 4 → 3\n       递归处理5\n       \n第3层：检查5后不足2个\n       直接返回5\n\n回溯连接：\n第2层：4 → 3 → 5，返回4\n第1层：2 → 1 → (4 → 3 → 5)，返回2\n\n最终：2 → 1 → 4 → 3 → 5\n```\n\n### 关键点\n\n- 先检查是否有足够的节点\n- 翻转逻辑与普通反转链表相同\n- 递归处理剩余部分\n- head变成了翻转后这组的尾节点\n\n---\n\n## 高级篇二：排序链表（归并排序）\n\n[LeetCode 148. 排序链表](https://leetcode.cn/problems/sort-list/)\n\n### 问题描述\n\n对链表进行排序，要求时间复杂度O(n log n)\n\n### 递归思路（分治法）\n\n归并排序的经典应用：\n1. 找到链表中点（快慢指针）\n2. 递归排序左半部分\n3. 递归排序右半部分\n4. 合并两个有序链表\n\n### 代码实现\n\n```c\n// 找到链表中间节点\nstruct ListNode* findMiddle(struct ListNode* head) {\n    if (!head || !head->next) return head;\n    \n    struct ListNode *slow = head;\n    struct ListNode *fast = head->next;\n    \n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n\n// 合并两个有序链表\nstruct ListNode* merge(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode dummy;\n    struct ListNode* tail = &dummy;\n    dummy.next = NULL;\n    \n    while (l1 && l2) {\n        if (l1->val <= l2->val) {\n            tail->next = l1;\n            l1 = l1->next;\n        } else {\n            tail->next = l2;\n            l2 = l2->next;\n        }\n        tail = tail->next;\n    }\n    \n    tail->next = l1 ? l1 : l2;\n    return dummy.next;\n}\n\n// 递归归并排序主函数\nstruct ListNode* sortList(struct ListNode* head) {\n    // 递归终止条件：空链表或单节点\n    if (!head || !head->next) {\n        return head;\n    }\n    \n    // 1. 找到中间节点并分割\n    struct ListNode* mid = findMiddle(head);\n    struct ListNode* right = mid->next;\n    mid->next = NULL;  // 切断链表\n    \n    // 2. 递归排序左右两部分\n    struct ListNode* leftSorted = sortList(head);\n    struct ListNode* rightSorted = sortList(right);\n    \n    // 3. 合并有序链表\n    return merge(leftSorted, rightSorted);\n}\n```\n\n### 递归过程图解\n\n```\n原链表：4 → 2 → 1 → 3\n\n分割阶段：\n层1：[4,2,1,3] → [4,2] 和 [1,3]\n层2：[4,2] → [4] 和 [2]\n     [1,3] → [1] 和 [3]\n\n合并阶段：\n层2：merge([4], [2]) → [2,4]\n     merge([1], [3]) → [1,3]\n层1：merge([2,4], [1,3]) → [1,2,3,4]\n\n最终：1 → 2 → 3 → 4\n```\n\n### 关键点\n\n- 分治思想：分割、递归、合并\n- 快慢指针找中点\n- 切断链表很重要（mid->next = NULL）\n- 时间复杂度：O(n log n)\n- 空间复杂度：O(log n)（递归栈）\n\n---\n\n## 高级篇三：复制带随机指针的链表\n\n[LeetCode 138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)\n\n### 问题描述\n\n复制一个特殊的链表，每个节点除了next指针，还有一个random指针指向链表中的任意节点或null\n\n### 递归思路\n\n使用哈希表缓存已复制的节点，递归复制next和random\n\n### 代码实现\n\n```c\nstruct HashTable {\n    struct Node *key, *val;\n    UT_hash_handle hh;\n} * cachedNode;\n\nstruct Node* deepCopy(struct Node* head) {\n    if (head == NULL) {\n        return NULL;\n    }\n    \n    struct HashTable* tmp;\n    HASH_FIND_PTR(cachedNode, &head, tmp);\n    \n    if (tmp == NULL) {\n        // 创建新节点\n        struct Node* headNew = malloc(sizeof(struct Node));\n        headNew->val = head->val;\n        \n        // 加入哈希表\n        tmp = malloc(sizeof(struct HashTable));\n        tmp->key = head;\n        tmp->val = headNew;\n        HASH_ADD_PTR(cachedNode, key, tmp);\n        \n        // 递归复制next和random\n        headNew->next = deepCopy(head->next);\n        headNew->random = deepCopy(head->random);\n    }\n    \n    return tmp->val;\n}\n\nstruct Node* copyRandomList(struct Node* head) {\n    cachedNode = NULL;\n    return deepCopy(head);\n}\n```\n\n### 关键点\n\n- 使用哈希表避免重复复制同一个节点\n- 先复制当前节点，再递归复制next和random\n- 哈希表的key是原节点，value是新节点\n- 递归可能会形成环，哈希表防止无限递归\n\n---\n\n\n## 递归核心总结\n\n### 递归三要素\n\n```c\nReturnType recursive(Node* head) {\n    // 1. 递归终止条件\n    if (终止条件) {\n        return 终止值;\n    }\n    \n    // 2. 递归调用\n    ReturnType result = recursive(下一个节点);\n    \n    // 3. 处理当前节点\n    处理当前节点与递归结果;\n    \n    // 4. 返回结果\n    return 返回值;\n}\n```\n\n### 常见递归模式\n\n**模式一：自底向上**\n先递归到底，回溯时处理\n例如：反转链表\n\n**模式二：自顶向下**\n先处理当前节点，再递归\n例如：复制链表\n\n**模式三：分治合并**\n分割问题，递归处理，合并结果\n例如：归并排序\n\n\n---\n\n## 总结\n\n递归是解决链表问题的强大工具\n\n掌握递归的关键：\n- 明确递归三要素：终止条件、递归逻辑、返回值\n- 理解递归的本质：将大问题分解为小问题\n- 学会画递归树，理解回溯过程\n- 权衡递归与迭代的优劣\n\n\n","tags":["算法","链表","递归"],"categories":["leetcode刷题笔记","C语言"]},{"title":"链表系列之快慢指针","url":"/2026/01/05/链表系列之快慢指针/","content":"\n## 快慢指针核心\n\n快慢指针是链表问题中最经典的算法技巧之一\n\n核心思想是使用两个指针同时遍历链表，但移动速度不同：\n- 快指针每次移动2步\n- 慢指针每次移动1步\n\n这个简单的速度差异，能够解决环检测、找中点、定位特定位置等一系列问题\n\n---\n\n## 应用场景一：检测链表是否有环\n\n[LeetCode 141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)\n\n### 问题描述\n\n给定一个链表，判断链表中是否有环\n\n### 核心思路\n\n如果链表有环，快慢指针最终一定会相遇\n\n就像在操场跑步，速度快的人一定会追上速度慢的人\n\n### 代码实现\n\n```c\nbool hasCycle(struct ListNode *head) {\n    if (head == NULL) {\n         return false;\n    }\n\n    struct ListNode* slow = head;\n    struct ListNode* fast = head->next;\n\n    while(slow != fast) {\n        if (fast == NULL || fast->next == NULL) {\n            return false;\n        }\n\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n\n    return true;\n}\n```\n\n### 关键点\n\n- 快指针走两步前要判断 `fast->next` 是否为空\n- 快慢指针初始位置可以不同（一个在head，一个在head->next）\n- 循环条件是 `slow != fast`\n\n---\n\n## 应用场景二：找到环的入口节点\n\n[LeetCode 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)\n\n### 问题描述\n\n如果链表有环，找到环的起始节点\n\n### 核心思路（Floyd判圈算法）\n\n这是快慢指针最精妙的应用，分为两个阶段：\n\n**第一阶段：判断是否有环**\n- 快慢指针同时从head出发\n- 快指针每次2步，慢指针每次1步\n- 如果相遇，说明有环\n\n**第二阶段：寻找环起点**\n- 将一个指针放回链表头\n- 两个指针都改为每次走1步\n- 再次相遇的点就是环起点\n\n### 数学证明\n\n设链表头到环入口距离为 `a`，环入口到相遇点距离为 `b`，相遇点到环入口距离为 `c`\n\n相遇时：\n- 慢指针走了：`a + b`\n- 快指针走了：`a + b + c + b` = `a + 2b + c`\n\n因为快指针速度是慢指针2倍，所以：\n- `2(a + b) = a + 2b + c`\n- 化简得：`a = c`\n\n这就是为什么从头节点和相遇点同时出发，会在环入口相遇\n\n### 代码实现\n\n```c\nstruct ListNode *detectCycle(struct ListNode *head) {\n    if (head == NULL || head->next == NULL) {\n        return NULL;\n    }\n    \n    // 关键：slow和fast都从head开始\n    struct ListNode* slow = head;\n    struct ListNode* fast = head;\n    \n    // 第一阶段：判断是否有环\n    while (fast != NULL && fast->next != NULL) {\n        slow = slow->next;\n        fast = fast->next->next;\n        \n        if (slow == fast) {\n            // 第二阶段：寻找环起点\n            fast = head;\n            while (fast != slow) {\n                fast = fast->next;\n                slow = slow->next;\n            }\n            return slow;  // 环起点\n        }\n    }\n    \n    return NULL;  // 无环\n}\n```\n\n### 关键点\n\n- 第一阶段slow和fast必须从同一位置出发\n- 相遇后将其中一个指针移回head\n- 第二阶段两个指针都是每次走1步\n\n---\n\n## 应用场景三：删除倒数第N个节点\n\n[LeetCode 19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n### 问题描述\n\n给定一个链表，删除倒数第N个节点\n\n### 核心思路\n\n让快指针先走N步，然后快慢指针同时前进\n\n当快指针到达末尾时，慢指针正好在倒数第N个节点的前一个位置\n\n### 代码实现\n\n```c\nstruct ListNode* removeNthFromEnd(struct ListNode* head, int n) {\n    if(head->next==NULL)\n        return NULL;\n    \n    struct ListNode dummy;\n    struct ListNode* curr = &dummy;\n    dummy.next = head;\n    \n    struct ListNode* fast=curr;\n    struct ListNode* low=curr;\n    \n    // 快指针先走n步\n    for(int i=0;i<n;i++){\n        fast=fast->next;\n    }\n    \n    // 快慢指针同时前进\n    while(fast->next!=NULL){\n        low=low->next;\n        fast=fast->next;\n    }\n    \n    // 删除节点\n    struct ListNode* tmp=low->next;\n    low->next=low->next->next;\n    free(tmp);\n    \n    return dummy.next;\n}\n```\n\n### 关键点\n\n- 使用虚拟头节点，避免处理删除头节点的边界情况\n- 快指针要先走N步\n- 慢指针停在待删除节点的前一个位置\n\n---\n\n## 应用场景四：判断回文链表\n\n[LeetCode 234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)\n\n### 问题描述\n\n判断一个链表是否为回文结构\n\n### 核心思路\n\n1. 用快慢指针找到链表中点\n2. 反转后半部分链表\n3. 比较前后两部分是否相同\n\n### 代码实现\n\n```c\n// 反转链表辅助函数\nstruct ListNode* reverseList(struct ListNode* head) {\n    if(head==NULL)\n        return NULL;\n    \n    struct ListNode* cur=head;\n    struct ListNode* prev=NULL;\n    struct ListNode* next;\n    \n    while(cur){\n        next=cur->next;\n        cur->next=prev;\n        prev=cur;\n        cur=next;\n    }\n    return prev;\n}\n\nbool isPalindrome(struct ListNode* head) {\n    if(head->next==NULL){\n        return true;\n    }\n\n    struct ListNode* low=head;\n    struct ListNode* fast=head;\n    struct ListNode* tmp;\n    struct ListNode* head_behind;\n    struct ListNode* head_ahead;\n    \n    // 快慢指针找中点\n    while(fast && fast->next){\n        low=low->next;\n        fast=fast->next->next;\n    }\n\n    // 根据链表奇偶判断后半段起点\n    if(fast){\n        tmp=low->next;  // 奇数个节点\n    }\n    else{\n        tmp=low;  // 偶数个节点\n    }\n    \n    // 反转后半部分\n    head_behind=reverseList(tmp);\n    head_ahead=head;\n\n    // 比较两部分\n    while(head_behind){\n        if(head_behind->val==head_ahead->val){\n            head_ahead=head_ahead->next;\n            head_behind=head_behind->next;\n        }\n        else{\n            return false;\n        }\n    }\n    return true;\n}\n```\n\n### 关键点\n\n- 快指针走到末尾时，慢指针在中点\n- 要区分链表节点个数的奇偶性\n- 空间复杂度O(1)，优于使用栈的方案\n\n---\n\n## 应用场景五：链表排序中找中点\n\n[LeetCode 148. 排序链表](https://leetcode.cn/problems/sort-list/)\n\n### 问题描述\n\n对链表进行排序，要求时间复杂度O(n log n)\n\n### 核心思路\n\n使用归并排序：\n1. 用快慢指针找中点，分割链表\n2. 递归排序左右两部分\n3. 合并两个有序链表\n\n### 代码实现\n\n```c\n// 找到链表中间节点\nstruct ListNode* findMiddle(struct ListNode* head) {\n    if (!head || !head->next) return head;\n    \n    struct ListNode *slow = head;\n    struct ListNode *fast = head->next;  // fast从head->next开始\n    \n    while (fast && fast->next) {\n        slow = slow->next;\n        fast = fast->next->next;\n    }\n    \n    return slow;\n}\n\n// 合并两个有序链表\nstruct ListNode* merge(struct ListNode* l1, struct ListNode* l2) {\n    struct ListNode dummy;\n    struct ListNode* tail = &dummy;\n    dummy.next = NULL;\n    \n    while (l1 && l2) {\n        if (l1->val <= l2->val) {\n            tail->next = l1;\n            l1 = l1->next;\n        } else {\n            tail->next = l2;\n            l2 = l2->next;\n        }\n        tail = tail->next;\n    }\n    \n    tail->next = l1 ? l1 : l2;\n    return dummy.next;\n}\n\n// 递归归并排序主函数\nstruct ListNode* sortList(struct ListNode* head) {\n    // 递归终止条件\n    if (!head || !head->next) {\n        return head;\n    }\n    \n    // 1. 找到中间节点并分割\n    struct ListNode* mid = findMiddle(head);\n    struct ListNode* right = mid->next;\n    mid->next = NULL;  // 切断链表\n    \n    // 2. 递归排序左右两部分\n    struct ListNode* leftSorted = sortList(head);\n    struct ListNode* rightSorted = sortList(right);\n    \n    // 3. 合并有序链表\n    return merge(leftSorted, rightSorted);\n}\n```\n\n### 关键点\n\n- 快指针从`head->next`开始，确保分割点在左半部分\n- 分割后要将左半部分的尾节点指向NULL\n- 归并排序是链表排序的最优解\n\n---\n\n## 快慢指针核心总结\n\n### 基本模板\n\n```c\nstruct ListNode* slow = head;\nstruct ListNode* fast = head;\n\nwhile (fast != NULL && fast->next != NULL) {\n    slow = slow->next;\n    fast = fast->next->next;\n}\n```\n\n\n### 注意事项\n\n1. **空指针判断**：快指针移动前要判断`fast`和`fast->next`\n2. **初始位置**：根据具体问题选择是否从同一位置开始\n3. **奇偶处理**：找中点时要注意链表长度奇偶的影响\n\n\n---\n\n\n\n## 总结\n\n快慢指针是链表算法中最优雅的技巧之一\n\n它用简单的速度差异，解决了环检测、找中点、定位等多个经典问题\n\n\n","tags":["算法","链表","快慢指针"],"categories":["leetcode刷题笔记","C语言"]},{"title":"堆的基本操作","url":"/2026/01/04/堆的基本操作/","content":"## 引言\n\n堆是一种特殊的完全二叉树结构，常用于实现优先队列。在最大堆中，父节点的值总是大于或等于其子节点的值。本文将通过C语言代码实现一个最大堆\n\n## 堆的基本概念\n\n堆是一种数据结构，具有以下特性：\n- **完全二叉树**：除了最后一层，其他层都是满的，且最后一层的节点都靠左排列\n- **堆序性**：在最大堆中，任意节点的值大于或等于其子节点的值\n\n堆通常用数组来实现，其中：\n- 根节点索引: `0`\n- 左子节点索引：`2*i + 1`\n- 右子节点索引：`2*i + 2`\n- 父节点索引： `(i-1)/2`\n\n## 代码实现\n\n下面是最大堆的C语言实现\n\n### 1. 堆的结构体定义\n\n```c\ntypedef struct {\n    int *data;      // 动态数组，数组指针\n    int size;       // 堆的元素个数\n    int capacity;   // 堆的最大容量\n} MaxHeap;\n```\n\n### 2. 交换元素\n\n```c\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n```\n\n### 3. 初始化堆\n\n```c\nMaxHeap* createHeap(int capacity) {\n    // 初始化分配空间\n    MaxHeap* heap = (MaxHeap*)malloc(sizeof(MaxHeap));\n    heap->data = (int*)malloc(sizeof(int) * capacity);\n    // 堆数值初始化\n    heap->capacity = capacity;\n    heap->size = 0;\n    return heap;\n}\n```\n\n### 4. 向上调整（siftUp）\n\n用于插入元素后维护堆的性质。从插入的节点开始，与父节点比较，如果大于父节点则交换，直到满足堆序性\n\n```c\nvoid siftUp(MaxHeap* heap, int childIdx) {\n    while (childIdx > 0) {\n        int parentIdx = (childIdx - 1) / 2;\n        if (heap->data[childIdx] > heap->data[parentIdx]) {\n            swap(&heap->data[childIdx], &heap->data[parentIdx]);\n            childIdx = parentIdx;\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 5. 向下调整（siftDown）\n\n用于删除堆顶或建堆时维护堆的性质。从指定节点开始，与子节点比较，选择最大的子节点交换，直到满足堆序性\n\n```c\nvoid siftDown(MaxHeap* heap, int parentIdx) {\n    int size = heap->size;\n    while (true) {\n        int leftChild = parentIdx * 2 + 1;\n        int rightChild = parentIdx * 2 + 2;\n        int largest = parentIdx;\n        \n        if (leftChild < size && heap->data[leftChild] > heap->data[largest]) {\n            largest = leftChild;\n        }\n        if (rightChild < size && heap->data[rightChild] > heap->data[largest]) {\n            largest = rightChild;\n        }\n        if (largest != parentIdx) {\n            swap(&heap->data[largest], &heap->data[parentIdx]);\n            parentIdx = largest;\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 6. 入堆操作（push）\n\n```c\nbool push(MaxHeap* heap, int val) {\n    // 满堆的处理\n    if (heap->size == heap->capacity)\n        return false;\n\n    heap->data[heap->size] = val;\n\n    // 这里siftUp与size无关，所以两者顺序不影响\n    siftUp(heap, heap->size);\n    heap->size++;\n    return true;\n}\n```\n\n### 7. 出堆操作（pop）\n\n```c\nint pop(MaxHeap* heap) {\n    // 空堆检查\n    if (heap->size == 0) return -1;\n    int root = heap->data[0];     \n    \n    // 用最后一个元素覆盖堆顶\n    heap->data[0] = heap->data[heap->size - 1];\n    \n    // 必须先减size再siftDown：\n    // 1. siftDown依赖正确的heap->size判断子节点边界\n    // 2. 原末尾元素已移至堆顶，该位置不再属于堆\n    // 3. 避免siftDown访问到逻辑上已移除的元素\n    heap->size--;  \n    siftDown(heap, 0);\n    return root;\n}\n```\n\n### 8. 删除任意位置的元素\n\n```c\nvoid deleteElement(MaxHeap* heap, int i) {\n    if (i < 0 || i >= heap->size)\n        return;\n    if (i == 0) {\n        pop(heap);\n        return;\n    }\n    if (i == heap->size - 1) {\n        heap->size--;\n        return;\n    }\n    int lastVal = heap->data[heap->size - 1];\n    heap->size--;\n    int oldVal = heap->data[i];\n    heap->data[i] = lastVal;\n\n    if (lastVal > oldVal) {\n        siftUp(heap, i);\n    } else {\n        siftDown(heap, i);\n    }\n}\n```\n\n### 9. 建堆操作\n\n```c\nMaxHeap* makeHeap(int* nums, int numsSize) {\n    // 堆的初始化\n    MaxHeap* heap = createHeap(numsSize);\n    // 数组拷贝到堆\n    memcpy(heap->data, nums, numsSize * sizeof(int));\n    heap->size = numsSize;\n    // 从最后一个非叶节点开始向下调整\n    for (int i = (numsSize / 2) - 1; i >= 0; i--) {\n        siftDown(heap, i);\n    }\n    return heap;\n}\n```\n\n## 总结\n\n通过以上代码，我们实现了一个完整的大根堆数据结构，堆的基本操作包括：\n- **插入**：使用`push`函数，时间复杂度O(log n)\n- **删除堆顶**：使用`pop`函数，时间复杂度O(log n)\n- **删除任意元素**：使用`deleteElement`函数，时间复杂度O(log n)\n- **建堆**：使用`makeHeap`函数，时间复杂度O(n)\n","tags":["算法","堆"],"categories":["leetcode刷题笔记","C语言"]},{"title":"LRU缓存算法","url":"/2026/01/03/LRU缓存算法/","content":"\n## 引言\nLRU（最近最少使用算法），是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据，以腾出空间给新的数据\n\n## LRU缓存算法原理\n下面会重点介绍核心的数据结构和操作原理\n\n### 核心数据结构：双向链表 + 哈希表\nLRU缓存算法的核心思想是维护一个有序的数据结构，记录数据的使用顺序。当数据被访问时，将其移动到数据结构的头部，表示它是最近使用的数据。当缓存达到容量限制时，淘汰数据结构尾部的数据，即最少使用的数据\n\n### 核心操作原理\n\n**1. 读取数据 (Get)**  \n- **查找**：在哈希表中查找该 key。  \n- **命中**：如果找到，根据哈希表记录的指针直接访问链表节点，获取 value。  \n- **更新状态**：因为该节点被访问了，它变成了“最新”的，所以将其从链表当前位置删除，并重新插入到链表尾部。  \n- **未命中**：返回 -1。  \n\n**2. 写入/更新数据 (Put)**  \n**节点已存在：**  \n- 修改该节点的 value。  \n- 将该节点移到链表尾部（更新时序）。  \n\n**节点不存在：**  \n- **检查容量**：如果缓存已满（size == capacity），则执行“淘汰”：  \n  - 删除链表头部（Head->next）的节点，因为它最久没被使用。  \n  - 同步在哈希表中删除该节点的 key。  \n- **插入新节点**：创建新节点，放入链表尾部，并在哈希表中记录映射关系。\n\n\n## C语言实现\n[LeetCode 146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)\n下面是LRU缓存算法的C语言实现代码\n\n### 使用uthash库实现\n```c\n#include \"uthash.h\"\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} LRUNode;\n\ntypedef struct {\n    LRUNode* cacheTable;\n    int capacity;\n} LRUCache;\n\nLRUCache* lRUCacheCreate(int capacity) {\n    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));\n    cache->cacheTable = NULL;\n    cache->capacity = capacity;\n    return cache;\n}\n\nint lRUCacheGet(LRUCache* obj, int key) {\n    if (!obj) return -1;\n    LRUNode* node = NULL;\n    HASH_FIND_INT(obj->cacheTable, &key, node);\n    if (node) {\n        HASH_DEL(obj->cacheTable, node);\n        HASH_ADD_INT(obj->cacheTable, key, node);\n        return node->val;\n    }\n    return -1;\n}\n\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\n    if (!obj) return;\n    LRUNode* node = NULL;\n    HASH_FIND_INT(obj->cacheTable, &key, node);\n    if (node) {\n        HASH_DEL(obj->cacheTable, node);\n        node->val = value;\n        HASH_ADD_INT(obj->cacheTable, key, node);\n    } else {\n        if (HASH_COUNT(obj->cacheTable) == obj->capacity) {\n            LRUNode* oldestNode = obj->cacheTable;\n            HASH_DEL(obj->cacheTable, oldestNode);\n            free(oldestNode);\n        }\n        LRUNode* newNode = (LRUNode*)malloc(sizeof(LRUNode));\n        newNode->key = key;\n        newNode->val = value;\n        HASH_ADD_INT(obj->cacheTable, key, newNode);\n    }\n}\n\nvoid lRUCacheFree(LRUCache* obj) {\n    if (!obj) return;\n    LRUNode* node, *tmp;\n    HASH_ITER(hh, obj->cacheTable, node, tmp) {\n        HASH_DEL(obj->cacheTable, node);\n        free(node);\n    }\n    free(obj);\n}\n```\n\n### 手搓双向链表 + 哈希表实现\n\n\n```c\n// 双向链表节点\ntypedef struct DLinkNode {\n    int key;\n    int val;\n    struct DLinkNode* prev;\n    struct DLinkNode* next;\n} DLinkNode;\n\nDLinkNode* createNode(int key, int val) {\n    DLinkNode* node = (DLinkNode*)malloc(sizeof(DLinkNode));\n    node->key = key;\n    node->val = val;\n    node->prev = NULL;\n    node->next = NULL;\n    return node;\n}\n\n// 简易哈希表（数组+链地址法）\n#define HASH_TABLE_SIZE 1009\n\ntypedef struct HashBucket {\n    int key;\n    DLinkNode* node;\n    struct HashBucket* next;\n} HashBucket;\n\nstatic inline unsigned int hashFunc(int key) {\n    return (unsigned int)(key < 0 ? -key : key) % HASH_TABLE_SIZE;\n}\n\n// LRU缓存对象\ntypedef struct {\n    DLinkNode* head;\n    DLinkNode* tail;\n    HashBucket* hashTable[HASH_TABLE_SIZE];\n    int capacity;\n    int size;\n} LRUCache;\n\n// 辅助函数，双向链表操作\n// 将新节点加到双向链表尾部\nvoid addToTail(LRUCache* cache, DLinkNode* node) {\n    node->prev = cache->tail->prev;\n    node->next = cache->tail;\n    cache->tail->prev->next = node;\n    cache->tail->prev = node;\n}\n\n// 从链表中移除节点\n// 因为有哨兵节点，所以不需要考虑边界\nvoid removeNode(LRUCache* cache, DLinkNode* node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n}\n\n// 将已有节点移到链表尾部（表示最近使用过）\nvoid moveToTail(LRUCache* cache, DLinkNode* node) {\n    removeNode(cache, node);\n    addToTail(cache, node);\n}\n\n// 删除头部节点，也就是最近没使用过，并返回key\nint removeHead(LRUCache* cache) {\n    DLinkNode* oldest = cache->head->next;\n    int key = oldest->key;\n    removeNode(cache, oldest);\n    free(oldest);\n    return key;\n}\n\n// 哈希表操作\n// 查找key对应的节点指针\nDLinkNode* hashFind(LRUCache* cache, int key) {\n    unsigned int idx = hashFunc(key);\n    HashBucket* bucket = cache->hashTable[idx];\n    while (bucket) {\n        if (bucket->key == key) {\n            return bucket->node;\n        }\n        bucket = bucket->next;\n    }\n    return NULL;\n}\n\n// 插入，key->node的映射\nvoid hashInsert(LRUCache* cache, int key, DLinkNode* node) {\n    unsigned int idx = hashFunc(key);\n    HashBucket* newBucket = (HashBucket*)malloc(sizeof(HashBucket));\n    newBucket->key = key;\n    newBucket->node = node;\n    newBucket->next = cache->hashTable[idx];\n    cache->hashTable[idx] = newBucket;\n}\n\n// 删除key的映射\nvoid hashDelete(LRUCache* cache, int key) {\n    unsigned int idx = hashFunc(key);\n    HashBucket** indirect = &(cache->hashTable[idx]);\n    while (*indirect) {\n        if ((*indirect)->key == key) {\n            HashBucket* toFree = *indirect;\n            *indirect = toFree->next;\n            free(toFree);\n            return;\n        }\n        // indirect本身,而不是*indirect指向的内容\n        indirect = &((*indirect)->next);\n    }\n}\n\n// LRU接口实现\nLRUCache* lRUCacheCreate(int capacity) {\n    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));\n    cache->capacity = capacity;\n    cache->size = 0;\n\n    // 初始化哨兵节点\n    cache->head = createNode(0, 0);\n    cache->tail = createNode(0, 0);\n    cache->head->next = cache->tail;\n    cache->tail->prev = cache->head;\n\n    // 初始化哈希表\n    memset(cache->hashTable, 0, sizeof(cache->hashTable));\n    return cache;\n}\n\nint lRUCacheGet(LRUCache* obj, int key) {\n    if (!obj) return -1;\n    DLinkNode* node = hashFind(obj, key);\n    if (node == NULL) return -1;\n    moveToTail(obj, node);\n    return node->val;\n}\n\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\n    if (!obj) return;\n    DLinkNode* node = hashFind(obj, key);\n    if (node) {\n        node->val = value;\n        moveToTail(obj, node);\n    } else {\n        if (obj->size >= obj->capacity) {\n            int oldestKey = removeHead(obj);\n            hashDelete(obj, oldestKey);\n            obj->size--;\n        }\n        DLinkNode* newNode = createNode(key, value);\n        addToTail(obj, newNode);\n        hashInsert(obj, key, newNode);\n        obj->size++;\n    }\n}\n\nvoid lRUCacheFree(LRUCache* obj) {\n    if (!obj) return;\n    DLinkNode* cur = obj->head->next;\n    while (cur != obj->tail) {\n        DLinkNode* next = cur->next;\n        free(cur);\n        cur = next;\n    }\n    free(obj->head);\n    free(obj->tail);\n    for (int i = 0; i < HASH_TABLE_SIZE; i++) {\n        HashBucket* bucket = obj->hashTable[i];\n        while (bucket) {\n            HashBucket* next = bucket->next;\n            free(bucket);\n            bucket = next;\n        }\n    }\n    free(obj);\n}\n```\n## 代码分析\n### 结构体分析\n1. **DLinkNode**：双向链表节点，包含 key、val、prev、next。用于维护最近使用顺序（尾部为最近使用，头部为最久未用）。\n2. **HashBucket**：哈希桶中的链表节点（链地址法），每个桶是一个链表，解决哈希冲突。存储 key 和对应的 DLinkNode* 指针，避免重复存储值\n3. **LRUCache**：缓存主体，head / tail：哨兵节点（dummy nodes），简化边界处理。hashTable：静态数组 + 链表，快速查找。capacity / size：容量控制\n\n### 操作分析\n1. **addToTail**：将节点添加到链表尾部，表示最近使用\n2. **removeNode**：从链表中移除节点\n3. **moveToTail**：将已有节点移到链表尾部，更新使用顺序\n4. **removeHead**：删除链表头部节点，淘 汰最久未用数据\n5. **hashFind / hashInsert / hashDelete**：哈希表的基本操作\n6. **lRUCacheGet**：获取数据，更新使用顺序\n7. **lRUCachePut**：插入/更新数据，处理容量限制\n\n### 亮点学习\n1. **哨兵节点**：使用 head / tail 哨兵节点，简化链表边界操作，避免频繁判断 NULL\n2. **链地址法哈希表**：使用静态数组 + 链表解决哈希冲突，节省空间\n3. **时间复杂度**：所有操作均为 O(1)，满足 LRU 缓存的高效需求\n\n## 总结\nLRU缓存算法通过双向链表和哈希表实现高效的缓存管理，本文介绍了两种C语言实现方式：一种使用uthash库简化哈希操作，另一种手搓数据结构以深入理解底层原理\n\n\n\n","tags":["算法","哈希表","链表","双向链表"],"categories":["leetcode刷题笔记","C语言"]},{"title":"独居者","url":"/2023/07/26/独居者/","content":"\n> 作者：[陆蠡](https://baike.baidu.com/item/%E9%99%86%E8%A0%A1/1945940?fr=ge_ala)\n\n<!-- more -->\n\n\n## 正文\n<p style=\"text-indent: 2em;\">\n现在我很懊悔无意中发现了C君的秘密，一个人在孤独时的秘密。这是一种痛苦，他原先紧紧藏着，预备留给他自己的，我无意中知道，这痛苦乃交给了我。他自己还不知道这回事，实际上另外有个人在分担他的痛苦了。听说有一种眚神，专给人家作祟的。但作祟的工作要在秘密中进行。譬如一个人在单房暗室，独处的时候，这眚神便用各种威胁引诱，弄得他害病为止。万一这作祟的工作被一个闯入者发现了或道破了，这眚神便舍掉原先想害的人，转向闯入者纠缠，将祸害嫁给后者。我碰到的正是这种情形。当我发现了他深自掩藏着的痛苦，我也要替他分负的了。\n\n　　要说我为什么把这回事放在自己心上？我不知道。只好怪我自己了。要说他有什么痛苦，为什么痛苦？我也不知道。这是一个谜。痛苦是往往说不出的。好像挨了毒打，浑身疼痛，却摸不着痛处。C君是一个奇特的人！他是属于幸福的一群呢？还是属于不幸的一群呢？我不能下断语。要论断某一个人，总得自己的见解智慧比人高出一筹，方得中肯。正如景色的眺望者，从高处往下看，方见全景；若从卑处往高看，所见结果一定不对的。我对C君的观察是从卑处往高看吧，我的叙述也许是不对的。也许他不似我所猜想的，根本没有什么痛苦，这一切倒是我自己的幻觉，这也难定。总之，说他有点奇特，不算过分吧。\n\n　　C君是我的朋友。我们认识有许多年头了。他给我最初的印象是一个可爱的，快乐的，和蔼的青年人。他服装穿得干净，鞋帽整齐。他的头发总是剪得齐齐的，两旁梳开，披在颞颥边，中间显出一条肉路。他的脸端正，端庄的表情浮在端正的脸上，有一种没有矜伐的厚道。他有明净的眼珠，不常直视人，偶然碰到别人的眼光在他的脸上搜索的时候，总是微微一笑避开。他鼻子方正，鼻准微平。嘴也搭配得大小适宜，嘴唇略厚一点，这使他的脸减损一分秀气。他会说话，不大流利，可够表达，显然是练习出来的。他的脸颜微嫌瘦削，照他的骨架子，应当更丰满些。总之，他是一望而知的没有受过生活鞭挞的人，在一个陌生人的眼中，正如一般生活优裕的人，往往多受人们尊敬。\n\n　　从他对人和做事的态度看来，他是一个热情的没有自私的青年。他对朋友极诚恳，做事认真负责。他的信念极坚定，在他的眼前永远闪现着美丽的希望。他不颓沮，不懊丧，脸上心里总是浮着微笑的。他从没有对任何事失去忍耐，对任何人抱怨，责备；他忙，但颇有点闲情。有一次我见他照画报上的样子在剖剔一个水仙球茎，弄了好几个钟头，似乎没失去耐性。\n\n　　我们时常在一起，散步谈天。我们谈到粗俗的，猥亵的，平凡的，崇高的，他很坦白，很少隐藏，因此我也约略知道他的身世，他的思想，他的感情。一切都没超人或异乎常人的地方。他正是一个脚踏实地地为理想的工作者。\n\n　　但是当我发现他有一种爱好独居的性格的时候，我渐渐觉得他有点奇特。他的工作（我想对他的工作性质的说明是不必要的。世界上，哪种工作最高贵最重要，而哪一种又不重要的，无价值的，我想没有人能够品评），使他和人们亲近，同居处，同饮食。但他总是单独住一个房间。他从不肯留一个朋友在他房里住宿。他好像是洁身自爱的女子，不让别人占用她的闺闼。当有一次一位从远道来的友人来望他，那友人找不到别的宿处而又疲倦了，打算在他房里过一夜，他陪他坐到夜深，最后，站起来说道：“我房里没留过客人，我要保持这记录，我陪你上旅馆去。”友人显然有点愠色，但他还是曳着友人上旅馆去了。这事后来那友人告诉我好多次，说他是有点不近人情的。\n\n　　他住的房间陈设简陋，但他守住这简陋的房间，像野兽守住它的洞穴，不愿意别兽闯入。我对个人的癖爱颇能谅解。像他这样的人，也许为了工作性质的关系，也许为了读书研习的关系，不愿别人打吵他，是说得过去的。我曾有个时期和他同住在一所公共的建筑内，同处在一个屋顶下，但我们仍旧保持着各人的生活习惯。因为我们有着不同的职业。我白天出去，晚上一早就睡了。他到夜深睡，早晨起床比较迟。有时候我们是数天不见面的。\n\n　　一天的夜里我发现了他孑身独处的原因。愿他原谅我，我是无心的。我看取了他的秘密，却无法把它交还原主，这使我时时引以为憾。我不是好奇的。这发现属于偶然，至今我还是懊悔那一次的闯入。\n\n　　那是一个有月亮的夏季的晚上，夜深使一切喧嚣归于静寂。我这夜特别比平时睡得迟，正预备熄灯睡的时候，突然想起一件东西遗在C君的房里，想立刻得到它。我想他是已经睡了，为了不惊扰他，我悄声走过去，我蹑着脚步走近他的房间。他的房门没有锁，被午夜的风吹开，留着一条阔缝。我一脚跨进去，仿佛眼前一个异景怔住了我，我几乎不相信我自己的眼睛了。C君在做什么啦！他跪在自己床前的地上，头伏在臂里，好像在作祈祷。从窗口斜射进来的月光把室内照成一种淡淡的晖明，他虽则跪在暗里，我却清楚地能够辨别他额上流着汗，脸孔是严肃而神秘的，一种不胜苦楚之情。这使我想起耶稣基督在客西马尼亚园中的祈祷：“汗珠大如血点，流在地上。”一种在苦杯前踌躇的惶悚。C君也好像是在推开一个苦杯而又准备接受。他全神贯注地沉在默念中，好像在一种不可见的神前忏悔，又好像是一个为热情所燃烧的男子在冷若冰霜的女子面前恳求，一种祈求幸福或是向幸福辞谢的神情……我几乎失声喊了出来，一种神秘的力量使我噤住。我悄悄退出，站在外面，从门隙中望他继续的动作。约莫过了四五分钟，他慢慢地站起来，走向窗口，面朝月光把手徐徐举起，好像迎接从月光中降落的天使似的。随后又把手垂下，向后摸索着床架，扶在上面，脸仍不回过来，这样站着好久好久。我只能从他偶然偏过来的脸望见那上面的神秘似的似乎痉挛的表情。“他是被痛苦啮噬着，”我忽然想到，于是迅速地跑回我自己的房间，忘记了适才去他房里的目的，我熄了灯，躺在床上，辗转了好久，我细细分析他平时的见解和行为，一丝也没有异样。但渐渐我从他偶尔流露的片言只语里，好像发觉他是怀着什么痛苦。\n\n　　那也是和他相识不久的时候，我们已有时常谈天的习惯，我坐在他房里，我们纵谈着各种琐事，讨论着许多问题。我们谈得很有兴趣，这时他手中揉弄着一条领带。我想到一个友人，爱把领带当作裤带束在腰间，于是我说：\n\n　　“你知道领带还有什么别的用途么？”\n\n　　“哈哈哈。”\n\n　　“猜得着吗？”\n\n　　“哈哈哈。”\n\n　　我不耐烦地就把我的发现告诉他。说是领带当裤带是适宜的。长短阔狭都好，只是一端太宽了些。\n\n　　“还有一个用途。”他补充说。\n\n　　“什么？”\n\n　　“哈哈哈。”他不说下去了。\n\n　　但是一转想我也猜到了。那是上吊用的。当时我觉得这家伙脑筋古怪，怎会想到这上面来呢？但是他那快活的笑声，立刻把我思想的阴云打散了。\n\n　　我从来不曾听到他悲观的论调。但有一次一个友人颂赞“生的欢喜”“生的美丽”说：\n\n　　“生是多美丽啊！我便从来没想到自杀过。”\n\n　　“谎话！”好像听见C君的自言自语。但他立刻用快活的声音接着道：\n\n　　“是的。生是美丽的。”\n\n　　谁能够解释他身上的矛盾呢？谁能够看出他极快活的表面底下潜藏着一个痛苦的灵魂？他有希望的光明，却又有失望的暗影；他有快乐的外表，却又有忧郁的内心。他好像是一池深深的潭水，表面平静光滑，反射着美丽的阳光，底里却翻涌着涡卷的伏流。有人留心到海面么？涡流最急的地方往往表面上显得异常光滑。C君的心境便是这样子。令人费于索解了。\n\n　　我想从他自己的口中和别人的口中探听，他是否受过什么大刺激，譬如失恋等情事，答案都是否定的。受过良好的教育，正如有着进步思想的人，他是自由主义者，他反对宗教，反对权力，反对加在人类身上的经济的和思想的一切桎梏，那么他为什么那样苦苦地祈祷呢？简直像一个虔诚的教徒！为什么他想到“死”呢？想到人们认为罪恶而自己也认为罪恶的“自杀”呢？这一切都是谜。他是在割舍一种人性上离不开的东西呢？他是不是凭他那严刻的内省，在替他自己的信念和理想觅取一种道德上的支持？好像他发现了一种理想，而又怀疑着，又给自己的怀疑解释，而这解释又不能使自己满意，他想抓住无定形的理想，而又抓不住，因而显得痛苦呢？这一些，也许连他自己也不会明白。\n\n　　于是我发现他平时乐观的态度倒是一种悲哀的掩饰了。嗣后每次他和我谈话的时候，我便不禁想起他夜晚苦苦跪着的样子。“他苦苦地制造了一个希望，一个理想，来扶掖自己。”我总这样地想。他是天生的有忧郁性格的人，却人为地在忧郁的底子上抹上一层愉快的色彩。这种努力是可敬的，但是这种努力，总给我以一种不可言说的悲哀。\n\n","tags":["散文"],"categories":["文学"]}]