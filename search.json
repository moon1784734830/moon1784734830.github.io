[{"title":"LRU缓存算法","url":"/2026/01/05/LRU缓存算法/","content":"\n## 引言\nLRU（最近最少使用算法），是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据，以腾出空间给新的数据\n\n## LRU缓存算法原理\n下面会重点介绍核心的数据结构和操作原理\n\n### 核心数据结构：双向链表 + 哈希表\nLRU缓存算法的核心思想是维护一个有序的数据结构，记录数据的使用顺序。当数据被访问时，将其移动到数据结构的头部，表示它是最近使用的数据。当缓存达到容量限制时，淘汰数据结构尾部的数据，即最少使用的数据\n\n### 核心操作原理\n\n**1. 读取数据 (Get)**  \n- **查找**：在哈希表中查找该 key。  \n- **命中**：如果找到，根据哈希表记录的指针直接访问链表节点，获取 value。  \n- **更新状态**：因为该节点被访问了，它变成了“最新”的，所以将其从链表当前位置删除，并重新插入到链表尾部。  \n- **未命中**：返回 -1。  \n\n**2. 写入/更新数据 (Put)**  \n**节点已存在：**  \n- 修改该节点的 value。  \n- 将该节点移到链表尾部（更新时序）。  \n\n**节点不存在：**  \n- **检查容量**：如果缓存已满（size == capacity），则执行“淘汰”：  \n  - 删除链表头部（Head->next）的节点，因为它最久没被使用。  \n  - 同步在哈希表中删除该节点的 key。  \n- **插入新节点**：创建新节点，放入链表尾部，并在哈希表中记录映射关系。\n\n\n## C语言实现\n下面是LRU缓存算法的C语言实现代码\n\n### 使用uthash库实现\n```c\n#include \"uthash.h\"\n\ntypedef struct {\n    int key;\n    int val;\n    UT_hash_handle hh;\n} LRUNode;\n\ntypedef struct {\n    LRUNode* cacheTable;\n    int capacity;\n} LRUCache;\n\nLRUCache* lRUCacheCreate(int capacity) {\n    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));\n    cache->cacheTable = NULL;\n    cache->capacity = capacity;\n    return cache;\n}\n\nint lRUCacheGet(LRUCache* obj, int key) {\n    if (!obj) return -1;\n    LRUNode* node = NULL;\n    HASH_FIND_INT(obj->cacheTable, &key, node);\n    if (node) {\n        HASH_DEL(obj->cacheTable, node);\n        HASH_ADD_INT(obj->cacheTable, key, node);\n        return node->val;\n    }\n    return -1;\n}\n\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\n    if (!obj) return;\n    LRUNode* node = NULL;\n    HASH_FIND_INT(obj->cacheTable, &key, node);\n    if (node) {\n        HASH_DEL(obj->cacheTable, node);\n        node->val = value;\n        HASH_ADD_INT(obj->cacheTable, key, node);\n    } else {\n        if (HASH_COUNT(obj->cacheTable) == obj->capacity) {\n            LRUNode* oldestNode = obj->cacheTable;\n            HASH_DEL(obj->cacheTable, oldestNode);\n            free(oldestNode);\n        }\n        LRUNode* newNode = (LRUNode*)malloc(sizeof(LRUNode));\n        newNode->key = key;\n        newNode->val = value;\n        HASH_ADD_INT(obj->cacheTable, key, newNode);\n    }\n}\n\nvoid lRUCacheFree(LRUCache* obj) {\n    if (!obj) return;\n    LRUNode* node, *tmp;\n    HASH_ITER(hh, obj->cacheTable, node, tmp) {\n        HASH_DEL(obj->cacheTable, node);\n        free(node);\n    }\n    free(obj);\n}\n```\n\n### 手搓双向链表 + 哈希表实现\n```c\n// 双向链表节点\ntypedef struct DLinkNode {\n    int key;\n    int val;\n    struct DLinkNode* prev;\n    struct DLinkNode* next;\n} DLinkNode;\n\nDLinkNode* createNode(int key, int val) {\n    DLinkNode* node = (DLinkNode*)malloc(sizeof(DLinkNode));\n    node->key = key;\n    node->val = val;\n    node->prev = NULL;\n    node->next = NULL;\n    return node;\n}\n\n// 简易哈希表（数组+链地址法）\n#define HASH_TABLE_SIZE 1009\n\ntypedef struct HashBucket {\n    int key;\n    DLinkNode* node;\n    struct HashBucket* next;\n} HashBucket;\n\nstatic inline unsigned int hashFunc(int key) {\n    return (unsigned int)(key < 0 ? -key : key) % HASH_TABLE_SIZE;\n}\n\n// LRU缓存对象\ntypedef struct {\n    DLinkNode* head;\n    DLinkNode* tail;\n    HashBucket* hashTable[HASH_TABLE_SIZE];\n    int capacity;\n    int size;\n} LRUCache;\n\n// 辅助函数，双向链表操作\n// 将新节点加到双向链表尾部\nvoid addToTail(LRUCache* cache, DLinkNode* node) {\n    node->prev = cache->tail->prev;\n    node->next = cache->tail;\n    cache->tail->prev->next = node;\n    cache->tail->prev = node;\n}\n\n// 从链表中移除节点\n// 因为有哨兵节点，所以不需要考虑边界\nvoid removeNode(LRUCache* cache, DLinkNode* node) {\n    node->prev->next = node->next;\n    node->next->prev = node->prev;\n}\n\n// 将已有节点移到链表尾部（表示最近使用过）\nvoid moveToTail(LRUCache* cache, DLinkNode* node) {\n    removeNode(cache, node);\n    addToTail(cache, node);\n}\n\n// 删除头部节点，也就是最近没使用过，并返回key\nint removeHead(LRUCache* cache) {\n    DLinkNode* oldest = cache->head->next;\n    int key = oldest->key;\n    removeNode(cache, oldest);\n    free(oldest);\n    return key;\n}\n\n// 哈希表操作\n// 查找key对应的节点指针\nDLinkNode* hashFind(LRUCache* cache, int key) {\n    unsigned int idx = hashFunc(key);\n    HashBucket* bucket = cache->hashTable[idx];\n    while (bucket) {\n        if (bucket->key == key) {\n            return bucket->node;\n        }\n        bucket = bucket->next;\n    }\n    return NULL;\n}\n\n// 插入，key->node的映射\nvoid hashInsert(LRUCache* cache, int key, DLinkNode* node) {\n    unsigned int idx = hashFunc(key);\n    HashBucket* newBucket = (HashBucket*)malloc(sizeof(HashBucket));\n    newBucket->key = key;\n    newBucket->node = node;\n    newBucket->next = cache->hashTable[idx];\n    cache->hashTable[idx] = newBucket;\n}\n\n// 删除key的映射\nvoid hashDelete(LRUCache* cache, int key) {\n    unsigned int idx = hashFunc(key);\n    HashBucket** indirect = &(cache->hashTable[idx]);\n    while (*indirect) {\n        if ((*indirect)->key == key) {\n            HashBucket* toFree = *indirect;\n            *indirect = toFree->next;\n            free(toFree);\n            return;\n        }\n        // indirect本身,而不是*indirect指向的内容\n        indirect = &((*indirect)->next);\n    }\n}\n\n// LRU接口实现\nLRUCache* lRUCacheCreate(int capacity) {\n    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));\n    cache->capacity = capacity;\n    cache->size = 0;\n\n    // 初始化哨兵节点\n    cache->head = createNode(0, 0);\n    cache->tail = createNode(0, 0);\n    cache->head->next = cache->tail;\n    cache->tail->prev = cache->head;\n\n    // 初始化哈希表\n    memset(cache->hashTable, 0, sizeof(cache->hashTable));\n    return cache;\n}\n\nint lRUCacheGet(LRUCache* obj, int key) {\n    if (!obj) return -1;\n    DLinkNode* node = hashFind(obj, key);\n    if (node == NULL) return -1;\n    moveToTail(obj, node);\n    return node->val;\n}\n\nvoid lRUCachePut(LRUCache* obj, int key, int value) {\n    if (!obj) return;\n    DLinkNode* node = hashFind(obj, key);\n    if (node) {\n        node->val = value;\n        moveToTail(obj, node);\n    } else {\n        if (obj->size >= obj->capacity) {\n            int oldestKey = removeHead(obj);\n            hashDelete(obj, oldestKey);\n            obj->size--;\n        }\n        DLinkNode* newNode = createNode(key, value);\n        addToTail(obj, newNode);\n        hashInsert(obj, key, newNode);\n        obj->size++;\n    }\n}\n\nvoid lRUCacheFree(LRUCache* obj) {\n    if (!obj) return;\n    DLinkNode* cur = obj->head->next;\n    while (cur != obj->tail) {\n        DLinkNode* next = cur->next;\n        free(cur);\n        cur = next;\n    }\n    free(obj->head);\n    free(obj->tail);\n    for (int i = 0; i < HASH_TABLE_SIZE; i++) {\n        HashBucket* bucket = obj->hashTable[i];\n        while (bucket) {\n            HashBucket* next = bucket->next;\n            free(bucket);\n            bucket = next;\n        }\n    }\n    free(obj);\n}\n```\n\n## 总结\nLRU缓存算法通过双向链表和哈希表实现高效的缓存管理，本文介绍了两种C语言实现方式：一种使用uthash库简化哈希操作，另一种手搓数据结构以深入理解底层原理\n\n\n\n","tags":["算法","哈希表","链表","双向链表"],"categories":["leetcode刷题笔记"]},{"title":"堆的基本操作","url":"/2026/01/05/堆的基本操作/","content":"## 引言\n\n堆是一种特殊的完全二叉树结构，常用于实现优先队列。在最大堆中，父节点的值总是大于或等于其子节点的值。本文将通过C语言代码实现一个最大堆\n\n## 堆的基本概念\n\n堆是一种数据结构，具有以下特性：\n- **完全二叉树**：除了最后一层，其他层都是满的，且最后一层的节点都靠左排列\n- **堆序性**：在最大堆中，任意节点的值大于或等于其子节点的值\n\n堆通常用数组来实现，其中：\n- 根节点索引: `0`\n- 左子节点索引：`2*i + 1`\n- 右子节点索引：`2*i + 2`\n- 父节点索引： `(i-1)/2`\n\n## 代码实现\n\n下面是最大堆的C语言实现\n\n### 1. 堆的结构体定义\n\n```c\ntypedef struct {\n    int *data;      // 动态数组，数组指针\n    int size;       // 堆的元素个数\n    int capacity;   // 堆的最大容量\n} MaxHeap;\n```\n\n### 2. 交换元素\n\n```c\nvoid swap(int *a, int *b) {\n    int tmp = *a;\n    *a = *b;\n    *b = tmp;\n}\n```\n\n### 3. 初始化堆\n\n```c\nMaxHeap* createHeap(int capacity) {\n    // 初始化分配空间\n    MaxHeap* heap = (MaxHeap*)malloc(sizeof(MaxHeap));\n    heap->data = (int*)malloc(sizeof(int) * capacity);\n    // 堆数值初始化\n    heap->capacity = capacity;\n    heap->size = 0;\n    return heap;\n}\n```\n\n### 4. 向上调整（siftUp）\n\n用于插入元素后维护堆的性质。从插入的节点开始，与父节点比较，如果大于父节点则交换，直到满足堆序性\n\n```c\nvoid siftUp(MaxHeap* heap, int childIdx) {\n    while (childIdx > 0) {\n        int parentIdx = (childIdx - 1) / 2;\n        if (heap->data[childIdx] > heap->data[parentIdx]) {\n            swap(&heap->data[childIdx], &heap->data[parentIdx]);\n            childIdx = parentIdx;\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 5. 向下调整（siftDown）\n\n用于删除堆顶或建堆时维护堆的性质。从指定节点开始，与子节点比较，选择最大的子节点交换，直到满足堆序性\n\n```c\nvoid siftDown(MaxHeap* heap, int parentIdx) {\n    int size = heap->size;\n    while (true) {\n        int leftChild = parentIdx * 2 + 1;\n        int rightChild = parentIdx * 2 + 2;\n        int largest = parentIdx;\n        \n        if (leftChild < size && heap->data[leftChild] > heap->data[largest]) {\n            largest = leftChild;\n        }\n        if (rightChild < size && heap->data[rightChild] > heap->data[largest]) {\n            largest = rightChild;\n        }\n        if (largest != parentIdx) {\n            swap(&heap->data[largest], &heap->data[parentIdx]);\n            parentIdx = largest;\n        } else {\n            break;\n        }\n    }\n}\n```\n\n### 6. 入堆操作（push）\n\n```c\nbool push(MaxHeap* heap, int val) {\n    // 满堆的处理\n    if (heap->size == heap->capacity)\n        return false;\n\n    heap->data[heap->size] = val;\n\n    // 这里siftUp与size无关，所以两者顺序不影响\n    siftUp(heap, heap->size);\n    heap->size++;\n    return true;\n}\n```\n\n### 7. 出堆操作（pop）\n\n```c\nint pop(MaxHeap* heap) {\n    // 空堆检查\n    if (heap->size == 0) return -1;\n    int root = heap->data[0];     \n    \n    // 用最后一个元素覆盖堆顶\n    heap->data[0] = heap->data[heap->size - 1];\n    \n    // 必须先减size再siftDown：\n    // 1. siftDown依赖正确的heap->size判断子节点边界\n    // 2. 原末尾元素已移至堆顶，该位置不再属于堆\n    // 3. 避免siftDown访问到逻辑上已移除的元素\n    heap->size--;  \n    siftDown(heap, 0);\n    return root;\n}\n```\n\n### 8. 删除任意位置的元素\n\n```c\nvoid deleteElement(MaxHeap* heap, int i) {\n    if (i < 0 || i >= heap->size)\n        return;\n    if (i == 0) {\n        pop(heap);\n        return;\n    }\n    if (i == heap->size - 1) {\n        heap->size--;\n        return;\n    }\n    int lastVal = heap->data[heap->size - 1];\n    heap->size--;\n    int oldVal = heap->data[i];\n    heap->data[i] = lastVal;\n\n    if (lastVal > oldVal) {\n        siftUp(heap, i);\n    } else {\n        siftDown(heap, i);\n    }\n}\n```\n\n### 9. 建堆操作\n\n```c\nMaxHeap* makeHeap(int* nums, int numsSize) {\n    // 堆的初始化\n    MaxHeap* heap = createHeap(numsSize);\n    // 数组拷贝到堆\n    memcpy(heap->data, nums, numsSize * sizeof(int));\n    heap->size = numsSize;\n    // 从最后一个非叶节点开始向下调整\n    for (int i = (numsSize / 2) - 1; i >= 0; i--) {\n        siftDown(heap, i);\n    }\n    return heap;\n}\n```\n\n## 总结\n\n通过以上代码，我们实现了一个完整的大根堆数据结构，堆的基本操作包括：\n- **插入**：使用`push`函数，时间复杂度O(log n)\n- **删除堆顶**：使用`pop`函数，时间复杂度O(log n)\n- **删除任意元素**：使用`deleteElement`函数，时间复杂度O(log n)\n- **建堆**：使用`makeHeap`函数，时间复杂度O(n)\n","tags":["算法","堆"],"categories":["leetcode刷题笔记"]},{"title":"独居者","url":"/2023/07/26/独居者/","content":"\n> 作者：[陆蠡](https://baike.baidu.com/item/%E9%99%86%E8%A0%A1/1945940?fr=ge_ala)\n\n<!-- more -->\n\n\n## 正文\n<p style=\"text-indent: 2em;\">\n现在我很懊悔无意中发现了C君的秘密，一个人在孤独时的秘密。这是一种痛苦，他原先紧紧藏着，预备留给他自己的，我无意中知道，这痛苦乃交给了我。他自己还不知道这回事，实际上另外有个人在分担他的痛苦了。听说有一种眚神，专给人家作祟的。但作祟的工作要在秘密中进行。譬如一个人在单房暗室，独处的时候，这眚神便用各种威胁引诱，弄得他害病为止。万一这作祟的工作被一个闯入者发现了或道破了，这眚神便舍掉原先想害的人，转向闯入者纠缠，将祸害嫁给后者。我碰到的正是这种情形。当我发现了他深自掩藏着的痛苦，我也要替他分负的了。\n\n　　要说我为什么把这回事放在自己心上？我不知道。只好怪我自己了。要说他有什么痛苦，为什么痛苦？我也不知道。这是一个谜。痛苦是往往说不出的。好像挨了毒打，浑身疼痛，却摸不着痛处。C君是一个奇特的人！他是属于幸福的一群呢？还是属于不幸的一群呢？我不能下断语。要论断某一个人，总得自己的见解智慧比人高出一筹，方得中肯。正如景色的眺望者，从高处往下看，方见全景；若从卑处往高看，所见结果一定不对的。我对C君的观察是从卑处往高看吧，我的叙述也许是不对的。也许他不似我所猜想的，根本没有什么痛苦，这一切倒是我自己的幻觉，这也难定。总之，说他有点奇特，不算过分吧。\n\n　　C君是我的朋友。我们认识有许多年头了。他给我最初的印象是一个可爱的，快乐的，和蔼的青年人。他服装穿得干净，鞋帽整齐。他的头发总是剪得齐齐的，两旁梳开，披在颞颥边，中间显出一条肉路。他的脸端正，端庄的表情浮在端正的脸上，有一种没有矜伐的厚道。他有明净的眼珠，不常直视人，偶然碰到别人的眼光在他的脸上搜索的时候，总是微微一笑避开。他鼻子方正，鼻准微平。嘴也搭配得大小适宜，嘴唇略厚一点，这使他的脸减损一分秀气。他会说话，不大流利，可够表达，显然是练习出来的。他的脸颜微嫌瘦削，照他的骨架子，应当更丰满些。总之，他是一望而知的没有受过生活鞭挞的人，在一个陌生人的眼中，正如一般生活优裕的人，往往多受人们尊敬。\n\n　　从他对人和做事的态度看来，他是一个热情的没有自私的青年。他对朋友极诚恳，做事认真负责。他的信念极坚定，在他的眼前永远闪现着美丽的希望。他不颓沮，不懊丧，脸上心里总是浮着微笑的。他从没有对任何事失去忍耐，对任何人抱怨，责备；他忙，但颇有点闲情。有一次我见他照画报上的样子在剖剔一个水仙球茎，弄了好几个钟头，似乎没失去耐性。\n\n　　我们时常在一起，散步谈天。我们谈到粗俗的，猥亵的，平凡的，崇高的，他很坦白，很少隐藏，因此我也约略知道他的身世，他的思想，他的感情。一切都没超人或异乎常人的地方。他正是一个脚踏实地地为理想的工作者。\n\n　　但是当我发现他有一种爱好独居的性格的时候，我渐渐觉得他有点奇特。他的工作（我想对他的工作性质的说明是不必要的。世界上，哪种工作最高贵最重要，而哪一种又不重要的，无价值的，我想没有人能够品评），使他和人们亲近，同居处，同饮食。但他总是单独住一个房间。他从不肯留一个朋友在他房里住宿。他好像是洁身自爱的女子，不让别人占用她的闺闼。当有一次一位从远道来的友人来望他，那友人找不到别的宿处而又疲倦了，打算在他房里过一夜，他陪他坐到夜深，最后，站起来说道：“我房里没留过客人，我要保持这记录，我陪你上旅馆去。”友人显然有点愠色，但他还是曳着友人上旅馆去了。这事后来那友人告诉我好多次，说他是有点不近人情的。\n\n　　他住的房间陈设简陋，但他守住这简陋的房间，像野兽守住它的洞穴，不愿意别兽闯入。我对个人的癖爱颇能谅解。像他这样的人，也许为了工作性质的关系，也许为了读书研习的关系，不愿别人打吵他，是说得过去的。我曾有个时期和他同住在一所公共的建筑内，同处在一个屋顶下，但我们仍旧保持着各人的生活习惯。因为我们有着不同的职业。我白天出去，晚上一早就睡了。他到夜深睡，早晨起床比较迟。有时候我们是数天不见面的。\n\n　　一天的夜里我发现了他孑身独处的原因。愿他原谅我，我是无心的。我看取了他的秘密，却无法把它交还原主，这使我时时引以为憾。我不是好奇的。这发现属于偶然，至今我还是懊悔那一次的闯入。\n\n　　那是一个有月亮的夏季的晚上，夜深使一切喧嚣归于静寂。我这夜特别比平时睡得迟，正预备熄灯睡的时候，突然想起一件东西遗在C君的房里，想立刻得到它。我想他是已经睡了，为了不惊扰他，我悄声走过去，我蹑着脚步走近他的房间。他的房门没有锁，被午夜的风吹开，留着一条阔缝。我一脚跨进去，仿佛眼前一个异景怔住了我，我几乎不相信我自己的眼睛了。C君在做什么啦！他跪在自己床前的地上，头伏在臂里，好像在作祈祷。从窗口斜射进来的月光把室内照成一种淡淡的晖明，他虽则跪在暗里，我却清楚地能够辨别他额上流着汗，脸孔是严肃而神秘的，一种不胜苦楚之情。这使我想起耶稣基督在客西马尼亚园中的祈祷：“汗珠大如血点，流在地上。”一种在苦杯前踌躇的惶悚。C君也好像是在推开一个苦杯而又准备接受。他全神贯注地沉在默念中，好像在一种不可见的神前忏悔，又好像是一个为热情所燃烧的男子在冷若冰霜的女子面前恳求，一种祈求幸福或是向幸福辞谢的神情……我几乎失声喊了出来，一种神秘的力量使我噤住。我悄悄退出，站在外面，从门隙中望他继续的动作。约莫过了四五分钟，他慢慢地站起来，走向窗口，面朝月光把手徐徐举起，好像迎接从月光中降落的天使似的。随后又把手垂下，向后摸索着床架，扶在上面，脸仍不回过来，这样站着好久好久。我只能从他偶然偏过来的脸望见那上面的神秘似的似乎痉挛的表情。“他是被痛苦啮噬着，”我忽然想到，于是迅速地跑回我自己的房间，忘记了适才去他房里的目的，我熄了灯，躺在床上，辗转了好久，我细细分析他平时的见解和行为，一丝也没有异样。但渐渐我从他偶尔流露的片言只语里，好像发觉他是怀着什么痛苦。\n\n　　那也是和他相识不久的时候，我们已有时常谈天的习惯，我坐在他房里，我们纵谈着各种琐事，讨论着许多问题。我们谈得很有兴趣，这时他手中揉弄着一条领带。我想到一个友人，爱把领带当作裤带束在腰间，于是我说：\n\n　　“你知道领带还有什么别的用途么？”\n\n　　“哈哈哈。”\n\n　　“猜得着吗？”\n\n　　“哈哈哈。”\n\n　　我不耐烦地就把我的发现告诉他。说是领带当裤带是适宜的。长短阔狭都好，只是一端太宽了些。\n\n　　“还有一个用途。”他补充说。\n\n　　“什么？”\n\n　　“哈哈哈。”他不说下去了。\n\n　　但是一转想我也猜到了。那是上吊用的。当时我觉得这家伙脑筋古怪，怎会想到这上面来呢？但是他那快活的笑声，立刻把我思想的阴云打散了。\n\n　　我从来不曾听到他悲观的论调。但有一次一个友人颂赞“生的欢喜”“生的美丽”说：\n\n　　“生是多美丽啊！我便从来没想到自杀过。”\n\n　　“谎话！”好像听见C君的自言自语。但他立刻用快活的声音接着道：\n\n　　“是的。生是美丽的。”\n\n　　谁能够解释他身上的矛盾呢？谁能够看出他极快活的表面底下潜藏着一个痛苦的灵魂？他有希望的光明，却又有失望的暗影；他有快乐的外表，却又有忧郁的内心。他好像是一池深深的潭水，表面平静光滑，反射着美丽的阳光，底里却翻涌着涡卷的伏流。有人留心到海面么？涡流最急的地方往往表面上显得异常光滑。C君的心境便是这样子。令人费于索解了。\n\n　　我想从他自己的口中和别人的口中探听，他是否受过什么大刺激，譬如失恋等情事，答案都是否定的。受过良好的教育，正如有着进步思想的人，他是自由主义者，他反对宗教，反对权力，反对加在人类身上的经济的和思想的一切桎梏，那么他为什么那样苦苦地祈祷呢？简直像一个虔诚的教徒！为什么他想到“死”呢？想到人们认为罪恶而自己也认为罪恶的“自杀”呢？这一切都是谜。他是在割舍一种人性上离不开的东西呢？他是不是凭他那严刻的内省，在替他自己的信念和理想觅取一种道德上的支持？好像他发现了一种理想，而又怀疑着，又给自己的怀疑解释，而这解释又不能使自己满意，他想抓住无定形的理想，而又抓不住，因而显得痛苦呢？这一些，也许连他自己也不会明白。\n\n　　于是我发现他平时乐观的态度倒是一种悲哀的掩饰了。嗣后每次他和我谈话的时候，我便不禁想起他夜晚苦苦跪着的样子。“他苦苦地制造了一个希望，一个理想，来扶掖自己。”我总这样地想。他是天生的有忧郁性格的人，却人为地在忧郁的底子上抹上一层愉快的色彩。这种努力是可敬的，但是这种努力，总给我以一种不可言说的悲哀。\n\n","tags":["散文"],"categories":["文学"]}]