<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LRU缓存算法</title>
    <url>/2026/01/03/LRU%E7%BC%93%E5%AD%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[引言LRU（最近最少使用算法），是一种内存数据淘汰策略，使用常见是当内存不足时，需要淘汰最近最少使用的数据，以腾出空间给新的数据
LRU缓存算法原理下面会重点介绍核心的数据结构和操作原理
核心数据结构：双向链表 + 哈希表LRU缓存算法的核心思想是维护一个有序的数据结构，记录数据的使用顺序。当数据被访问时，将其移动到数据结构的头部，表示它是最近使用的数据。当缓存达到容量限制时，淘汰数据结构尾部的数据，即最少使用的数据
核心操作原理1. 读取数据 (Get)  

查找：在哈希表中查找该 key。  
命中：如果找到，根据哈希表记录的指针直接访问链表节点，获取 value。  
更新状态：因为该节点被访问了，它变成了“最新”的，所以将其从链表当前位置删除，并重新插入到链表尾部。  
未命中：返回 -1。

2. 写入&#x2F;更新数据 (Put)节点已存在：  

修改该节点的 value。  
将该节点移到链表尾部（更新时序）。

节点不存在：  

检查容量：如果缓存已满（size &#x3D;&#x3D; capacity），则执行“淘汰”：  
删除链表头部（Head-&gt;next）的节点，因为它最久没被使用。  
同步在哈希表中删除该节点的 key。


插入新节点：创建新节点，放入链表尾部，并在哈希表中记录映射关系。

C语言实现LeetCode 146. LRU 缓存下面是LRU缓存算法的C语言实现代码
使用uthash库实现#include &quot;uthash.h&quot;typedef struct &#123;    int key;    int val;    UT_hash_handle hh;&#125; LRUNode;typedef struct &#123;    LRUNode* cacheTable;    int capacity;&#125; LRUCache;LRUCache* lRUCacheCreate(int capacity) &#123;    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));    cache-&gt;cacheTable = NULL;    cache-&gt;capacity = capacity;    return cache;&#125;int lRUCacheGet(LRUCache* obj, int key) &#123;    if (!obj) return -1;    LRUNode* node = NULL;    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);    if (node) &#123;        HASH_DEL(obj-&gt;cacheTable, node);        HASH_ADD_INT(obj-&gt;cacheTable, key, node);        return node-&gt;val;    &#125;    return -1;&#125;void lRUCachePut(LRUCache* obj, int key, int value) &#123;    if (!obj) return;    LRUNode* node = NULL;    HASH_FIND_INT(obj-&gt;cacheTable, &amp;key, node);    if (node) &#123;        HASH_DEL(obj-&gt;cacheTable, node);        node-&gt;val = value;        HASH_ADD_INT(obj-&gt;cacheTable, key, node);    &#125; else &#123;        if (HASH_COUNT(obj-&gt;cacheTable) == obj-&gt;capacity) &#123;            LRUNode* oldestNode = obj-&gt;cacheTable;            HASH_DEL(obj-&gt;cacheTable, oldestNode);            free(oldestNode);        &#125;        LRUNode* newNode = (LRUNode*)malloc(sizeof(LRUNode));        newNode-&gt;key = key;        newNode-&gt;val = value;        HASH_ADD_INT(obj-&gt;cacheTable, key, newNode);    &#125;&#125;void lRUCacheFree(LRUCache* obj) &#123;    if (!obj) return;    LRUNode* node, *tmp;    HASH_ITER(hh, obj-&gt;cacheTable, node, tmp) &#123;        HASH_DEL(obj-&gt;cacheTable, node);        free(node);    &#125;    free(obj);&#125;

手搓双向链表 + 哈希表实现// 双向链表节点typedef struct DLinkNode &#123;    int key;    int val;    struct DLinkNode* prev;    struct DLinkNode* next;&#125; DLinkNode;DLinkNode* createNode(int key, int val) &#123;    DLinkNode* node = (DLinkNode*)malloc(sizeof(DLinkNode));    node-&gt;key = key;    node-&gt;val = val;    node-&gt;prev = NULL;    node-&gt;next = NULL;    return node;&#125;// 简易哈希表（数组+链地址法）#define HASH_TABLE_SIZE 1009typedef struct HashBucket &#123;    int key;    DLinkNode* node;    struct HashBucket* next;&#125; HashBucket;static inline unsigned int hashFunc(int key) &#123;    return (unsigned int)(key &lt; 0 ? -key : key) % HASH_TABLE_SIZE;&#125;// LRU缓存对象typedef struct &#123;    DLinkNode* head;    DLinkNode* tail;    HashBucket* hashTable[HASH_TABLE_SIZE];    int capacity;    int size;&#125; LRUCache;// 辅助函数，双向链表操作// 将新节点加到双向链表尾部void addToTail(LRUCache* cache, DLinkNode* node) &#123;    node-&gt;prev = cache-&gt;tail-&gt;prev;    node-&gt;next = cache-&gt;tail;    cache-&gt;tail-&gt;prev-&gt;next = node;    cache-&gt;tail-&gt;prev = node;&#125;// 从链表中移除节点// 因为有哨兵节点，所以不需要考虑边界void removeNode(LRUCache* cache, DLinkNode* node) &#123;    node-&gt;prev-&gt;next = node-&gt;next;    node-&gt;next-&gt;prev = node-&gt;prev;&#125;// 将已有节点移到链表尾部（表示最近使用过）void moveToTail(LRUCache* cache, DLinkNode* node) &#123;    removeNode(cache, node);    addToTail(cache, node);&#125;// 删除头部节点，也就是最近没使用过，并返回keyint removeHead(LRUCache* cache) &#123;    DLinkNode* oldest = cache-&gt;head-&gt;next;    int key = oldest-&gt;key;    removeNode(cache, oldest);    free(oldest);    return key;&#125;// 哈希表操作// 查找key对应的节点指针DLinkNode* hashFind(LRUCache* cache, int key) &#123;    unsigned int idx = hashFunc(key);    HashBucket* bucket = cache-&gt;hashTable[idx];    while (bucket) &#123;        if (bucket-&gt;key == key) &#123;            return bucket-&gt;node;        &#125;        bucket = bucket-&gt;next;    &#125;    return NULL;&#125;// 插入，key-&gt;node的映射void hashInsert(LRUCache* cache, int key, DLinkNode* node) &#123;    unsigned int idx = hashFunc(key);    HashBucket* newBucket = (HashBucket*)malloc(sizeof(HashBucket));    newBucket-&gt;key = key;    newBucket-&gt;node = node;    newBucket-&gt;next = cache-&gt;hashTable[idx];    cache-&gt;hashTable[idx] = newBucket;&#125;// 删除key的映射void hashDelete(LRUCache* cache, int key) &#123;    unsigned int idx = hashFunc(key);    HashBucket** indirect = &amp;(cache-&gt;hashTable[idx]);    while (*indirect) &#123;        if ((*indirect)-&gt;key == key) &#123;            HashBucket* toFree = *indirect;            *indirect = toFree-&gt;next;            free(toFree);            return;        &#125;        // indirect本身,而不是*indirect指向的内容        indirect = &amp;((*indirect)-&gt;next);    &#125;&#125;// LRU接口实现LRUCache* lRUCacheCreate(int capacity) &#123;    LRUCache* cache = (LRUCache*)malloc(sizeof(LRUCache));    cache-&gt;capacity = capacity;    cache-&gt;size = 0;    // 初始化哨兵节点    cache-&gt;head = createNode(0, 0);    cache-&gt;tail = createNode(0, 0);    cache-&gt;head-&gt;next = cache-&gt;tail;    cache-&gt;tail-&gt;prev = cache-&gt;head;    // 初始化哈希表    memset(cache-&gt;hashTable, 0, sizeof(cache-&gt;hashTable));    return cache;&#125;int lRUCacheGet(LRUCache* obj, int key) &#123;    if (!obj) return -1;    DLinkNode* node = hashFind(obj, key);    if (node == NULL) return -1;    moveToTail(obj, node);    return node-&gt;val;&#125;void lRUCachePut(LRUCache* obj, int key, int value) &#123;    if (!obj) return;    DLinkNode* node = hashFind(obj, key);    if (node) &#123;        node-&gt;val = value;        moveToTail(obj, node);    &#125; else &#123;        if (obj-&gt;size &gt;= obj-&gt;capacity) &#123;            int oldestKey = removeHead(obj);            hashDelete(obj, oldestKey);            obj-&gt;size--;        &#125;        DLinkNode* newNode = createNode(key, value);        addToTail(obj, newNode);        hashInsert(obj, key, newNode);        obj-&gt;size++;    &#125;&#125;void lRUCacheFree(LRUCache* obj) &#123;    if (!obj) return;    DLinkNode* cur = obj-&gt;head-&gt;next;    while (cur != obj-&gt;tail) &#123;        DLinkNode* next = cur-&gt;next;        free(cur);        cur = next;    &#125;    free(obj-&gt;head);    free(obj-&gt;tail);    for (int i = 0; i &lt; HASH_TABLE_SIZE; i++) &#123;        HashBucket* bucket = obj-&gt;hashTable[i];        while (bucket) &#123;            HashBucket* next = bucket-&gt;next;            free(bucket);            bucket = next;        &#125;    &#125;    free(obj);&#125;
代码分析结构体分析
DLinkNode：双向链表节点，包含 key、val、prev、next。用于维护最近使用顺序（尾部为最近使用，头部为最久未用）。
HashBucket：哈希桶中的链表节点（链地址法），每个桶是一个链表，解决哈希冲突。存储 key 和对应的 DLinkNode* 指针，避免重复存储值
LRUCache：缓存主体，head &#x2F; tail：哨兵节点（dummy nodes），简化边界处理。hashTable：静态数组 + 链表，快速查找。capacity &#x2F; size：容量控制

操作分析
addToTail：将节点添加到链表尾部，表示最近使用
removeNode：从链表中移除节点
moveToTail：将已有节点移到链表尾部，更新使用顺序
removeHead：删除链表头部节点，淘 汰最久未用数据
hashFind &#x2F; hashInsert &#x2F; hashDelete：哈希表的基本操作
lRUCacheGet：获取数据，更新使用顺序
lRUCachePut：插入&#x2F;更新数据，处理容量限制

亮点学习
哨兵节点：使用 head &#x2F; tail 哨兵节点，简化链表边界操作，避免频繁判断 NULL
链地址法哈希表：使用静态数组 + 链表解决哈希冲突，节省空间
时间复杂度：所有操作均为 O(1)，满足 LRU 缓存的高效需求

总结LRU缓存算法通过双向链表和哈希表实现高效的缓存管理，本文介绍了两种C语言实现方式：一种使用uthash库简化哈希操作，另一种手搓数据结构以深入理解底层原理
]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希表</tag>
        <tag>链表</tag>
        <tag>双向链表</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树系列之递归</title>
    <url>/2026/01/06/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[引言首先我们需要知道，二叉树非常适合递归处理，因为二叉树本身就是递归定义的：

每个节点最多有两个子节点（左子树、右子树）
每个子树本身又是一棵二叉树
空树也是二叉树的一种情况（递归的终止条件）

此外，二叉树问题可以自然地分解为处理该节点与其左右子树的问题
递归问题需要注意以下三点：

递归终止条件：什么时候停止递归
递归逻辑：如何处理当前节点
返回值：向上一层返回什么

接下来我会列出一些我自己在写力扣的时候遇到的部分题目

二叉树的中序遍历LeetCode 94. 二叉树的中序遍历
问题描述给定一个二叉树的根节点 root ，返回它的 中序遍历 
递归思路中序遍历的顺序是：左子树 → 根节点 → 右子树
void inorder(struct TreeNode* root,int* num,int* ret)&#123;    if(root==NULL)    return;    inorder(root-&gt;left,num,ret);    ret[(*num)++]=root-&gt;val;    inorder(root-&gt;right,num,ret);    &#125;int* inorderTraversal(struct TreeNode* root, int* returnSize) &#123;    int *re =(int *)malloc(sizeof(int) * 501);    *returnSize = 0;    inorder(root,returnSize,re);    return re;&#125;
这里有一点我一开始没注意，就是传入的 returnSize 其实是一个指针，在使用inorder函数时不需要 &amp; 符号，直接传入 returnSize 即可

二叉搜索树中第K小的元素LeetCode 230. 二叉搜索树中第K小的元素
问题描述给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小的元素
递归思路利用BST中序遍历有序性，递减k计数，提前返回进行优化
代码实现void kFind(struct TreeNode* root, int* k, int* result)&#123;    if(root == NULL || *k == 0)//方便提前返回        return;        kFind(root-&gt;left, k, result);        (*k)--;    if(*k == 0)&#123;        *result = root-&gt;val;        return;    &#125;        kFind(root-&gt;right, k, result);&#125;int kthSmallest(struct TreeNode* root, int k) &#123;    int result = -1;    kFind(root, &amp;k, &amp;result);    return result;&#125;
这里在kFind函数中增加了一个提前返回的条件，当*k == 0时，说明已经找到了第k小的元素，可以直接返回，避免不必要的递归调用

对称二叉树LeetCode 101. 对称二叉树
问题描述给你一个二叉树的根节点 root ， 检查它是否轴对称
递归思路递归判断镜像，左子树的左孩子与右子树的右孩子对比
代码实现bool isMirror(struct TreeNode* left, struct TreeNode* right)&#123;    if(!left&amp;&amp;!right)    return true;    if(!left||!right)    return false;    if(left-&gt;val!=right-&gt;val)    return false;    return isMirror(left-&gt;left,right-&gt;right)&amp;&amp;isMirror(left-&gt;right,right-&gt;left);&#125; bool isSymmetric(struct TreeNode* root) &#123;    if(root==NULL)    return true;    return isMirror(root-&gt;left,root-&gt;right);&#125;
本题的思路还与一题判断两颗二叉树是否相同类似，不过那一题在递归传递参数时传递的是root1的左和root2的左，而本题传递的是root的左和root的右

二叉树的最大深度LeetCode 104. 二叉树的最大深度
问题描述给定一个二叉树的根节点 root ，返回其最大深度
递归思路自底向上递归，depth = max(leftDepth, rightDepth) + 1
代码实现int maxDepth(struct TreeNode* root) &#123;    if(root==NULL)    return 0;    int lmax = maxDepth(root-&gt;left);    int rmax = maxDepth(root-&gt;right);    return(lmax&gt;rmax?lmax:rmax)+1;&#125;
本题是典型的自底向上递归，先计算左右子树的最大深度，然后取较大值加一返回

二叉树的直径LeetCode 543. 二叉树的直径
问题描述给定一棵二叉树，你需要计算它的直径长度。二叉树的直径长度是任意两个节点路径长度中的最大值。这条路径可能穿过根节点
递归思路通过递归计算二叉树的最大深度，同时更新树的直径（即任意两个节点之间的最长路径）,最大深度函数返回左右子树深度的较大值，并更新全局最大路径值
代码实现int maxDepth(struct TreeNode* root,int* maxl)&#123;    if(root==NULL)    return 0;    int lmax=maxDepth(root-&gt;left,maxl);    int rmax=maxDepth(root-&gt;right,maxl);    *maxl=fmax(*maxl,lmax+rmax);    return fmax(lmax,rmax)+1;&#125;int diameterOfBinaryTree(struct TreeNode* root) &#123;    if(root==NULL)    return 0;    int maxl=0;    maxDepth(root,&amp;maxl);    return maxl;&#125;
在maxDepth函数中，我们计算左右子树的深度，并更新*maxl为当前的最大直径。最终在diameterOfBinaryTree函数中返回这个最大直径值

翻转二叉树LeetCode 226. 翻转二叉树
问题描述给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点
递归思路递归交换每个节点的左右子节点
代码实现struct TreeNode* invertTree(struct TreeNode* root) &#123;    if (root == NULL) &#123;        return NULL;    &#125;        struct TreeNode* temp = root-&gt;left;    root-&gt;left = root-&gt;right;    root-&gt;right = temp;        invertTree(root-&gt;left);    invertTree(root-&gt;right);        return root;&#125;
交换当前节点的左右子节点，接着递归调用invertTree函数来翻转左右子树,最后返回翻转后的根节点

二叉树的最近公共祖先LeetCode 236. 二叉树的最近公共祖先
问题描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先节点
递归思路递归遍历树，判断当前节点是否为p或q，若是则返回当前节点，否则递归左右子树，若左右子树均返回非空节点，则当前节点即为最近公共祖先
代码实现struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) &#123;    if (root == NULL || root == p || root == q) &#123;        return root; // 找到 p 或 q 就不往下递归了    &#125;    struct TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);    struct TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);    if (left &amp;&amp; right) &#123; // 左右都找到        return root; // 当前节点是最近公共祖先    &#125;    // 如果只有左子树找到，就返回左子树的返回值    // 如果只有右子树找到，就返回右子树的返回值    // 如果左右子树都没有找到，就返回 NULL（注意此时 right = NULL）    return left ? left : right;&#125;
这里的关键在于递归返回值的处理，通过判断左右子树的返回值来确定当前节点是否为最近公共祖先，像本题我们就要注意是后序遍历，因为这里我们需要左右子树的结果来决定当前节点的返回值

二叉树展开为链表LeetCode 114. 二叉树展开为链表
问题描述给你二叉树的根节点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个节点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历顺序相同。

递归思路本题要求与先序遍历顺序相同，这里可以采用头插法，按照先序的逆序（右-左-根）来处理节点，即先处理右子树，再处理左子树，这样在构建链表时就能保证顺序正确
代码实现void dfs(struct TreeNode* node, struct TreeNode** head) &#123;    if (node == NULL) &#123;        return;    &#125;    dfs(node-&gt;right, head);    dfs(node-&gt;left, head);    node-&gt;left = NULL;    node-&gt;right = *head; // 头插法，相当于链表的 node-&gt;next = head    *head = node; // 现在链表头节点是 node&#125;void flatten(struct TreeNode* root) &#123;    struct TreeNode* head = NULL;    dfs(root, &amp;head);&#125;
在dfs函数中，我们先递归处理右子树，再处理左子树，这样可以确保我们按照先序遍历的顺序构建链表，通过头插法，我们将当前节点的右指针指向链表的头节点，并更新头节点为当前节点，最终实现了二叉树的展开为链表

深入理解：二叉树递归顺序的选择一、核心本质：二叉树递归 &#x3D; 在”什么时候”处理当前节点任何二叉树递归，本质都是这三步的排列组合：

dfs(node-&gt;left);
处理当前节点;
dfs(node-&gt;right);

不同的递归顺序，本质区别在于：你希望在什么时候处理当前节点



递归顺序
处理节点的时机
本质含义



前序
先处理自己，再处理子树
自顶向下


中序
左子树后、右子树前
与结构强相关


后序
子树都处理完再处理自己
自底向上



二、不同递归顺序一般对应什么题目？① 前序遍历（根 → 左 → 右）特点：先用当前节点的信息，再递归子树
适合的题目类型
“当前节点会影响子节点” 的问题
典型特征：

父节点的信息要传递给子节点
路径类问题
从根向下的构造、记录、判断

常见题目

路径和（Path Sum）
根到叶子的路径
验证 BST（携带 min&#x2F;max）
树的序列化
建树（根据遍历）

思维模板
“我要先知道当前节点是什么，再决定怎么走下去”

② 中序遍历（左 → 根 → 右）特点：节点处理夹在左右之间
适合的题目类型
和”顺序””结构”强相关的题目，尤其是 BST（搜索二叉树）
常见题目

验证 BST（中序是否有序）
BST 转数组
第 k 小元素
BST 相关统计

思维模板
“左边处理完，当前节点才有意义”

③ 后序遍历（左 → 右 → 根）特点：先拿到子树结果，再处理当前节点
适合的题目类型
“当前节点的结果依赖子树”
常见题目

最大深度 &#x2F; 最小深度
直径
是否平衡二叉树
最大路径和
翻转 &#x2F; 删除 &#x2F; 合并子树
flatten（二叉树展开）

思维模板
“我得先知道左右子树情况，才能算我自己”

三、核心判断技巧：三问法看到一个二叉树递归题，先别写代码，先问自己这三个问题：
问题 1：当前节点的结果，依赖谁？


依赖对象
选择顺序



依赖父节点
前序


依赖左右子树
后序


依赖结构顺序
中序


问题 2：是”向下传信息”，还是”向上汇总信息”？


信息流方向
顺序



从根到叶子
前序


从叶子到根
后序


问题 3：递归函数”返回值”代表什么？这是决定后序遍历的最重要信号
如果递归函数有明确的返回值含义，且这个返回值用于父节点计算
大概率是后序遍历

四、总结要点
前序 &#x3D; 自顶向下传递信息（父节点影响子节点）
中序 &#x3D; BST 相关（利用中序遍历的有序性）
后序 &#x3D; 自底向上汇总信息（子树结果影响父节点）

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表之Uthash应用</title>
    <url>/2026/01/12/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B9%8BUthash%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[Uthash总览哈希表介绍哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。在这哈希表中，每一个元素的key和它的存储位置都存在一个f(key)的映射关系，我们可以通过f(key)快速的查找到这个元素在表中的位置
Uthash简介Uthash是一个用C语言编写的开源哈希表库，它提供了简单易用的接口来创建和操作哈希表。Uthash支持多种数据类型作为键，并且可以动态调整哈希表的大小以适应数据量的变化

hot100中Uthash的应用1. 两数之和LeetCode 1. 两数之和
问题描述： 给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标
Uthash应用： 使用Uthash存储数组元素及其索引，在遍历数组时，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在
代码实现
//哈希表结构体typedef struct&#123;    int key;    int val;    UT_hash_handle hh;&#125; hashTable;//定义全局变量哈希表指针，指向表头hashTable* table;//查找功能hashTable* find(int key)&#123;    hashTable* tmp;    HASH_FIND_INT(table,&amp;key,tmp);    return tmp;&#125;//插入功能void insert(int key,int val)&#123;    hashTable* node=find(key);    if(node==NULL)&#123;        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=key;        tmp-&gt;val=val;        HASH_ADD_INT(table,key,tmp);    &#125;    else&#123;        node-&gt;val=val;    &#125;&#125;int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;    table=NULL;    for(int i=0;i&lt;numsSize;i++)&#123;        hashTable* tmp=find(target-nums[i]);        if(tmp)&#123;            int* ret=(int*)malloc(sizeof(int)*2);            ret[0]=tmp-&gt;val;            ret[1]=i;            return ret;        &#125;        else&#123;            insert(nums[i],i);        &#125;    &#125;    *returnSize=0;    return NULL;&#125;
本题的解题思路是：

遍历数组，对于每个元素，计算目标值与当前元素的差值，并在哈希表中查找该差值是否存在
如果存在，返回对应的索引；如果不存在，将当前元素及其索引插入哈希表中
最后是在O(n)的时间复杂度内解决问题


2. 字母异位词分组LeetCode 49. 字母异位词分组
问题描述： 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串
Uthash应用： 使用Uthash存储排序后的字符串作为键，原始字符串列表作为值，将异位词分组
代码实现
//结构体定义typedef struct&#123;    char* key;          //键：排序后的字符串    char** list;        //值：原始字符串列表    int cnt;            //当前字符串对应的列表大小    int capacity;       //列表容量    UT_hash_handle hh;  //哈希表句柄&#125; hashTable;hashTable* table;//qsort比较函数需要使用的cmp函数int cmp(const void* a,const void* b)&#123;    return (*(char*)a-*(char*)b);&#125;hashTable* find(char* key)&#123;    hashTable* tmp;    HASH_FIND_STR(table,key,tmp);    return tmp;&#125;//这里需要注意字符串的+1是为了存储字符串的结束符&#x27;\0&#x27;hashTable* insert(char* key,char* str)&#123;    hashTable* node=find(key);    if(node==NULL)&#123;        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=malloc(strlen(key)+1);        strcpy(tmp-&gt;key,key);        tmp-&gt;capacity=10;        tmp-&gt;cnt=0;        tmp-&gt;list=malloc(sizeof(char*)*tmp-&gt;capacity);        tmp-&gt;list[tmp-&gt;cnt]=malloc(strlen(str)+1);        strcpy(tmp-&gt;list[tmp-&gt;cnt],str);        tmp-&gt;cnt++;        HASH_ADD_STR(table,key,tmp);    &#125;    else&#123;        //如果容量不够则扩容        if(node-&gt;cnt&gt;=node-&gt;capacity)&#123;            node-&gt;capacity*=2;            node-&gt;list=realloc(node-&gt;list,sizeof(char*)*node-&gt;capacity);        &#125;        node-&gt;list[node-&gt;cnt]=malloc(strlen(str)+1);        strcpy(node-&gt;list[node-&gt;cnt],str);        node-&gt;cnt++;    &#125;&#125;char*** groupAnagrams(char** strs, int strsSize, int* returnSize, int** returnColumnSizes)&#123;    table=NULL;    //构建哈希表，插入键与值    for(int i=0;i&lt;strsSize;i++)&#123;        int len=strlen(strs[i]);        char* sortedStr=malloc(len+1);        strcpy(sortedStr,strs[i]);        qsort(sortedStr,len,sizeof(char),cmp);        insert(sortedStr,strs[i]);        free(sortedStr);    &#125;    *returnSize=HASH_COUNT(table);    char*** res = malloc(sizeof(char**) * (*returnSize));    *returnColumnSizes = malloc(sizeof(int) * (*returnSize));    int idx=0;    hashTable* node,*tmp;    //遍历哈希表，构建结果集    HASH_ITER(hh,table,node,tmp)&#123;        res[idx]=malloc(sizeof(char*)*node-&gt;cnt);        (*returnColumnSizes)[idx]=node-&gt;cnt;        for(int j=0;j&lt;node-&gt;cnt;j++)&#123;            res[idx][j]=malloc(strlen(node-&gt;list[j])+1);            strcpy(res[idx][j],node-&gt;list[j]);        &#125;        idx++;    &#125;    //清理哈希表，释放内存    HASH_ITER(hh,table,node,tmp)&#123;        free(node-&gt;key);        for(int j=0;j&lt;node-&gt;cnt;j++)&#123;            free(node-&gt;list[j]);           &#125;        free(node-&gt;list);        HASH_DEL(table,node);        free(node);    &#125;    return res;&#125;
本题的解题思路是：

遍历字符串数组，对于每个字符串，排序后作为键插入哈希表
如果键已存在，则将原始字符串添加到对应的值列表中
最后遍历哈希表，构建结果集


3. 最长连续序列LeetCode 128. 最长连续序列
问题描述： 给定一个未排序的整数数组，找出最长连续序列的长度
Uthash应用： 使用Uthash存储数组元素，遍历数组时，检查每个元素的前后连续元素是否存在，计算最长连续序列长度
代码实现
#define MAX(a,b) ((a)&gt;(b)?(a):(b))//哈希表结构体typedef struct&#123;    int key;    UT_hash_handle hh;&#125; hashTable;int longestConsecutive(int* nums, int numsSize)&#123;    if(numsSize==0) return 0;    hashTable* table=NULL;    //构建哈希表,去重    for(int i=0;i&lt;numsSize;i++)&#123;        hashTable* tmp;        HASH_FIND_INT(table,&amp;nums[i],tmp);        if(tmp==NULL)&#123;            tmp=(hashTable*)malloc(sizeof(hashTable));            tmp-&gt;key=nums[i];            HASH_ADD_INT(table,key,tmp);        &#125;    &#125;    int longest=0;    hashTable* node,* findNode,* tmp;    HASH_ITER(hh,table,node,tmp)&#123;        int cur=node-&gt;key;        int prev=cur-1;        HASH_FIND_INT(table,&amp;prev,findNode);        //不是序列的起点，跳过        if(findNode!=NULL) continue;         int cnt=1;        int next=cur+1;        HASH_FIND_INT(table,&amp;next,findNode);        while(findNode!=NULL)&#123;            next++;            cnt++;            HASH_FIND_INT(table,&amp;next,findNode);        &#125;        longest=MAX(cnt,longest);    &#125;    //释放哈希表内存    HASH_ITER(hh,table,node,tmp)&#123;        HASH_DEL(table,node);        free(node);    &#125;    return longest;&#125;
本题的解题思路是：

使用Uthash构建哈希表，这一步可以去重
遍历哈希表，找到每个可能连续序列的起点，这一步算是一个优化，不需要对每个数字都找到最后，只需要对序列起点开始寻找cnt，计算连续长度
最后比较longest与cnt，返回最长序列长度即可


4. 路径总和ⅢLeetCode 437. 路径总和 III
问题描述： 给定一个二叉树和一个整数目标和targetSum，找出路径总和等于目标和的路径数量。路径不需要从根节点开始或结束，但必须向下移动（只能从父节点到子节点）
Uthash应用： 使用Uthash存储前缀和及其出现次数，在遍历二叉树时，计算当前路径的前缀和，并查找是否存在满足条件的前缀和
代码实现
//哈希表结构体typedef struct&#123;    long long sum;    int cnt;    UT_hash_handle hh;&#125; PrefixSumNode;static PrefixSumNode* prefixMap=NULL;void dfsPathSum(struct TreeNode* root,long long currSum,int targetSum,int* ans)&#123;    if(root==NULL) return;    //计算当前前缀和    currSum+=root-&gt;val;    //计算还需要的前缀和    long long need=currSum-targetSum;    PrefixSumNode* find;    //如果能找到need，则说明存在满足条件的路径    HASH_FIND(hh,prefixMap,&amp;need,sizeof(long long),find);    if(find)&#123;       *ans+=find-&gt;cnt;    &#125;    //将当前前缀和加入哈希表    PrefixSumNode* currNode=NULL;    HASH_FIND(hh,prefixMap,&amp;currSum,sizeof(long long),currNode);    if(currNode==NULL)&#123;       currNode=(PrefixSumNode*)malloc(sizeof(PrefixSumNode));       currNode-&gt;sum=currSum;       currNode-&gt;cnt=1;       HASH_ADD(hh,prefixMap,sum,sizeof(long long),currNode);    &#125; else&#123;       currNode-&gt;cnt++;    &#125;    //递归计算左右子树    dfsPathSum(root-&gt;left,currSum,targetSum,ans);    dfsPathSum(root-&gt;right,currSum,targetSum,ans);    //回溯，移除当前前缀和    currNode-&gt;cnt--;    if(currNode-&gt;cnt==0)&#123;        HASH_DEL(prefixMap,currNode);        free(currNode);    &#125;&#125;int pathSum(struct TreeNode* root, int targetSum)&#123;    int ans=0;    prefixMap=NULL;    // 加入初始前缀和0，1次    PrefixSumNode* baseNode=(PrefixSumNode*)malloc(sizeof(PrefixSumNode));    baseNode-&gt;sum=0;    baseNode-&gt;cnt=1;    HASH_ADD(hh,prefixMap,sum,sizeof(long long),baseNode);    dfsPathSum(root,0,targetSum,&amp;ans);    //释放哈希表内存    PrefixSumNode* node,*tmp;    HASH_ITER(hh,prefixMap,node,tmp)&#123;        HASH_DEL(prefixMap,node);        free(node);    &#125;    return ans;&#125;
本题使用哈希表的优势如下：

使用Uthash存储前缀和及其出现次数，可以在O(1)时间内查找是否存在满足条件的前缀和
通过前缀和的概念，可以高效地计算路径和，类似与两数之和的去查找need
本题的一个重点就是need=currSum-targetSum，通过这个公式可以快速定位到满足条件的前缀和，从而计算路径数量

解题思路如下：

使用DFS遍历二叉树，使用哈希表储存当前节点的前缀和（当前路径上的），通过前缀和之差计算出其中子路径的路径之和，判断是否等于targetSum
哈希表还要储存cnt，表示当前前缀和出现的次数，因为可能存在多条路径的前缀和相同
注意本题还需要回溯，在DFS返回上一层时，需要将当前前缀和的计数减一，确保哈希表中只包含当前路径上的前缀和信息


5. 从前序与中序遍历序列构造二叉树LeetCode 105. 从前序与中序遍历序列构造二叉树
问题描述： 给定两个整数数组preorder和inorder，其中preorder是二叉树的前序遍历，inorder是二叉树的中序遍历，请构造二叉树并返回其根节点
Uthash应用： 使用Uthash存储中序遍历数组中每个元素的索引，便于在构建二叉树时快速定位根节点在中序遍历中的位置，本题使用哈希表主要在于优化查找位置
代码实现
//结构体定义typedef struct&#123;    int key;    int val;    UT_hash_handle hh;&#125; hashTable;hashTable* table; struct TreeNode* buildTreeHelper(int* preorder,int lpre,int rpre,int* inorder,int lin,int rin)&#123;    if(lpre&gt;rpre || lin&gt;rin) return NULL;    // 找到根节点（先序序列当前区间的第一个节点）在中序遍历中的位置    int rootVal=preorder[lpre];    hashTable* find;    HASH_FIND_INT(table,&amp;rootVal,find);    int k=find-&gt;val;    // 构造二叉树    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));    root-&gt;val=rootVal;    int leftSize=k-lin;    root-&gt;left=builedTreeHelper(preorder,lpre+1,lpre+leftSize,inorder,lin,k-1);    root-&gt;right=builedTreeHelper(preorder,lpre+leftSize+1,rpre,inorder,k+1,rin);        return root; &#125;struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize)&#123;    table=NULL;    // 构建哈希表，存储中序遍历数组中每个元素的索引    for(int i=0;i&lt;inorderSize;i++)&#123;        hashTbale* tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=inorder[i];        tmp-&gt;val=i;        HASH_ADD_INT(table,key,tmp);    &#125;    struct TreeNode* root=buildTreeHelper(preorder,0,preorderSize-1,inorder,0,inorderSize-1);    hashTable* tmp,* curr;    HASH_ITER(hh,table,curr,tmp)&#123;        HASH_DEL(table,curr);        free(curr);    &#125;    return root;&#125;

本题相比如下的原始版本：
struct  TreeNode* Tree(int* preorder,int lpre,int rpre,int *inorder,int lin,int rin)&#123;    if(lpre &gt; rpre || lin &gt; rin)        return NULL;    int k;    for(k=lin;k&lt;=rin;k++)&#123;        if(inorder[k]==preorder[lpre])&#123;            break;        &#125;    &#125;    struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode));    root-&gt;val=preorder[lpre];    int leftSize = k - lin;    root-&gt;left=Tree(preorder,lpre+1,lpre+leftSize,inorder,lin,k-1);    root-&gt;right=Tree(preorder,lpre+leftSize+1,rpre,inorder,k+1,rin);    return root;&#125;struct TreeNode* buildTree(int* preorder, int preorderSize, int* inorder, int inorderSize) &#123;    return Tree(preorder,0,preorderSize-1,inorder,0,inorderSize-1);&#125;

使用哈希表的优势如下：

使用Uthash存储中序遍历数组中每个元素的索引，可以在O(1)时间内查找根节点在中序遍历中的位置
避免了在每次递归中使用循环查找根节点位置，提升了整体构建二叉树的效率

解题思路如下：

使用Uthash构建哈希表，存储中序遍历数组中每个元素的索引
递归构建二叉树，利用哈希表快速定位根节点在中序遍历中的位置，划分左右子树
最后释放哈希表内存，返回构建好的二叉树根节点


6. 多数元素LeetCode 169. 多数元素
问题描述： 给定一个大小为n的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于⌊ n/2 ⌋的元素
Uthash应用： 使用Uthash存储数组元素及其出现次数，遍历数组时，更新哈希表中的计数，最后找到出现次数超过n/2的元素
代码实现
//哈希表结构体typedef struct&#123;    int key;    int val;    UT_hash_handle hh;&#125; hashTable;int majorityElement(int* nums, int numsSize)&#123;    hashTable* table=NULL;    // 构建哈希表，统计每个元素的出现次数    for(int i;i&lt;numsSize;i++)&#123;        hashTable* node;        HASH_FIND_INT(table.&amp;nums[i],node);        if(node==NULL)&#123;            node=(hashTable*)malloc(sizeof(hashTable));            node-&gt;key=nums[i];            node-&gt;val=1;            HASH_ADD_INT(table,key,node);        &#125; else&#123;            node-&gt;val++;        &#125;    &#125;    int ans;    int maxCnt=0;    hashTable* node,* tmp;    // 遍历哈希表，找到出现次数最多的元素    HASH_ITER(hh,table,node,tmp)&#123;        if(node-&gt;val&gt;maxCnt)&#123;            max=node-&gt;val;            ans=node-&gt;key;        &#125;    &#125;    return ans;&#125;
本题除了技巧方法，其他方法较为好想,在这里使用哈希表主要还是为了熟悉哈希表的使用

7. 随机链表的复制LeetCode 138. 随机链表的复制
问题描述： 给定一个链表，每个节点包含一个额外的随机指针，该指针可以指向链表中的任何节点或null。请实现一个函数来复制这个链表
Uthash应用： 使用Uthash存储原始节点与其对应的复制节点的映射关系，在遍历原始链表时，创建复制节点并更新随机指针
代码实现
// 哈希表结构体typedef struct&#123;    struct Node* key;    struct Node* val;    UT_hash_handle hh;&#125; hashTable;struct Node* copyRandomList(struct Node* head)&#123;    if(!head) return NULL;    hashTable* table=NULL;    struct Node* curr=head;    // 构建哈希表，存储原始节点与复制节点的映射关系    while(curr)&#123;        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));        newNode-&gt;val=curr-&gt;val;        newNode-&gt;next=NULL;        newNode-&gt;random=NULL;                hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=curr;        tmp-&gt;val=newNode;        HASH_ADD_PTR(table,key,tmp);        curr=curr-&gt;next;    &#125;    // 更新复制节点的next和random指针    curr=head;    while(curr)&#123;        hashTable* find;        HASH_FIND_PTR(table,&amp;curr,find);        struct Node* newNode=find-&gt;val;        // 设置next指针        if(curr-&gt;next)&#123;            HASH_FIND_PTR(table,&amp;curr-&gt;next,find);            newNode-&gt;next=find-&gt;val;        &#125; else&#123;            newNode-&gt;next=NULL;        &#125;        // 设置random指针        if(curr-&gt;random)&#123;            HASH_FIND_PTR(table,&amp;curr-&gt;random,find);            newNode-&gt;random=find-&gt;val;        &#125; else&#123;            newNode-&gt;random=NULL;        &#125;        curr=curr-&gt;next;    &#125;    // 返回复制链表的头节点    hashTable* findHead;    HASH_FIND_PTR(table,&amp;head,findHead);    struct Node* newHead=findHead-&gt;val;    hashTable* curr,* tmp;    HASH_ITER(hh,table,curr,tmp)&#123;        HASH_DEL(table,curr);        free(curr);    &#125;    return newHead;&#125;
本题的解题思路是：

遍历原始链表，使用哈希表存储每个原始节点与其对应的复制节点的映射关系
再次遍历原始链表，使用哈希表更新复制节点的next和random指针
最后返回复制链表的头节点

除了上述的方法外，还有一种哈希表+递归的方法:

我们用哈希表记录每一个节点对应新节点的创建情况。
遍历该链表的过程中，我们检查当前节点的后继节点和当前节点的随机指针指向的节点的创建情况。如果这两个节点中的任何一个节点的新节点没有被创建，我们都立刻递归地进行创建。
当我们拷贝完成，回溯到当前层时，我们即可完成当前节点的指针赋值。
注意一个节点可能被多个其他节点指向，因此我们可能递归地多次尝试拷贝某个节点，为了防止重复拷贝，我们需要首先检查当前节点是否被拷贝过，如果已经拷贝过，我们可以直接从哈希表中取出拷贝后的节点的指针并返回即可。

下面我会给出代码实现：
// 哈希表结构体typedef struct&#123;    struct Node* key;    struct Node* val;    UT_hash_handle hh;&#125; hashTable;hashTable* table;struct Node* deepCopy(struct Node* head)&#123;    if(head==NULL) return NULL;    hashTable* tmp;    HASH_FIND_PTR(table,&amp;head,tmp);    if(tmp==NULL)&#123;        struct Node* newNode=(struct Node*)malloc(sizeof(struct Node));        newNode-&gt;val=head-&gt;val;        tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=head;        tmp-&gt;val=newNode;        HASH_ADD_PTR(table,key,tmp);        newNode-&gt;next=deepCopy(head-&gt;next);        newNode-&gt;random=deepCopy(head-&gt;random);    &#125;    return tmp-&gt;val;&#125;struct Node* copyRandomList(struct Node* head)&#123;    table=NULL;    struct Node* newHead=deepCopy(head);    hashTable* curr,* tmp;    HASH_ITER(hh,table,curr,tmp)&#123;        HASH_DEL(table,curr);        free(curr);    &#125;    return newHead;&#125;


8. 相交链表LeetCode 160. 相交链表
问题描述： 给定两个单链表的头节点headA和headB，找出并返回两个链表相交的起始节点。如果两个链表没有交点，返回null
Uthash应用： 使用Uthash存储第一个链表的节点地址，在遍历第二个链表时，检查节点是否存在于哈希表中，找到相交节点
代码实现
typedef struct&#123;    struct ListNode* key;    UT_hash_handle hh;&#125; hashTable;struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB)&#123;    hashTable* table=NULL;    struct ListNode* curr=headA;    // 构建哈希表，存储第一个链表的节点地址    while(curr)&#123;        hashTable* tmp=(hashTable*)malloc(sizeof(hashTable));        tmp-&gt;key=curr;        HASH_ADD_PTR(table,key,tmp);        curr=curr-&gt;next;    &#125;    // 遍历第二个链表，检查节点是否存在于哈希表中    curr=headB;    while(curr)&#123;        hashTable* find;        HASH_FIND_PTR(table,&amp;curr,find);        if(find)&#123;            return curr;        &#125;        curr=curr-&gt;next;    &#125;    return NULL;&#125;
本题的解题思路是：

遍历第一个链表，将每个节点的地址存储在哈希表中
遍历第二个链表，检查每个节点是否存在于哈希表中
如果找到相交节点，返回该节点；如果遍历结束未找到，返回null


9. 和为k的子数组LeetCode 560. 和为k的子数组
问题描述： 给定一个整数数组nums和一个整数k，请你统计并返回该数组中和为k的连续子数组的个数
Uthash应用： 使用Uthash存储前缀和及其出现次数，在遍历数组时，计算当前前缀和，并查找是否存在满足条件的前缀和
前缀和思想 本题与之前的路径总和Ⅲ(- 4. 路径总和Ⅲ)类似，都是利用前缀和的思想来解决问题。前缀和是指从数组开头到当前位置的元素之和。通过计算当前前缀和与目标值的差值，我们可以快速定位到满足条件的前缀和，从而计算出连续子数组的个数
代码实现
typedef struct &#123;    int sum;          // 当前前缀和    int count;        // 前缀和出现的次数    UT_hash_handle hh; // uthash 处理的哈希句柄&#125; HashMapEntry;int subarraySum(int* nums, int numsSize, int K) &#123;    HashMapEntry* sum_map = NULL;  // 哈希表的头指针    HashMapEntry* entry;    int current_sum = 0;    int count = 0;    // 初始情况下，前缀和为0出现一次    entry = (HashMapEntry*)malloc(sizeof(HashMapEntry));    entry-&gt;sum = 0;    entry-&gt;count = 1; // sum=0 出现 1 次    HASH_ADD_INT(sum_map, sum, entry);    for (int i = 0; i &lt; numsSize; i++) &#123;        current_sum += nums[i];  // 更新当前的前缀和        int target = current_sum - K;        // 查找前缀和为 target 的条目        HASH_FIND_INT(sum_map, &amp;target, entry);        if (entry) &#123;            count += entry-&gt;count;  // 如果存在，累加计数        &#125;        // 更新当前前缀和在哈希表中的计数        HASH_FIND_INT(sum_map, &amp;current_sum, entry);        if (entry) &#123;            entry-&gt;count += 1;        &#125; else &#123;            entry = (HashMapEntry*)malloc(sizeof(HashMapEntry));            entry-&gt;sum = current_sum;            entry-&gt;count = 1;            HASH_ADD_INT(sum_map, sum, entry);        &#125;    &#125;    // 清理哈希表内存    HashMapEntry *tmp, *current_entry;    HASH_ITER(hh, sum_map, current_entry, tmp) &#123;        HASH_DEL(sum_map, current_entry);        free(current_entry);    &#125;    return count;&#125;

本题的解题思路是：

使用Uthash构建哈希表，存储前缀和及其出现次数
遍历数组，计算当前前缀和，并查找是否存在满足条件的前缀和
如果存在，累加计数；如果不存在，更新当前前缀和在哈希表中的计数
最后返回计数结果


总结以上题目均是我在刷题过程中碰见的有关哈希表的题目，目前还在c语言，没有自带的哈希表数据结构，只能使用Uthash来进行实现，这些题目既可以帮助我学习哈希表的使用方法，也可以帮助我入门Uthash的使用，等到后面使用c++和python的时候应该就会轻松很多
]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法</title>
    <url>/2026/01/11/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[一、什么时候该想到「回溯 &#x2F; DFS」？只要题目出现这些关键词之一，优先考虑回溯：

“所有可能 &#x2F; 全部方案 &#x2F; 所有组合”
“列举 &#x2F; 返回所有”
“是否存在一种方式”
“组合 &#x2F; 排列 &#x2F; 子集”
“选择 or 不选择”
“一步一步尝试，失败就退回”

本质一句话：
这是一个「多步决策，每一步有多个选择」的问题
二、回溯题的 5 大核心题型① 组合类（Combination）典型题目
电话号码的字母组合
组合总和
k 个数的组合
选若干个元素满足条件

特征
顺序不重要
不允许重复 &#x2F; 有条件限制
“选哪个”比”选的顺序”重要

抽象模型在一个候选集合中一步一步做选择最终得到一个合法组合
思考套路
当前能选什么？
下一步从哪里开始选？
什么时候算完成？

模板（核心）void dfs(int start) &#123;    if (满足条件) &#123;        保存结果;        return;    &#125;    for (int i = start; i &lt; n; i++) &#123;        选择 i;        dfs(i + 1);        撤销选择;    &#125;&#125;

注意： 在组合类问题中，通过控制起始索引避免重复选择，确保组合的唯一性。
② 排列类（Permutation）典型题目
全排列
字符串全排列
有 &#x2F; 无重复元素的排列

特征
顺序很重要
同样的数字换顺序算不同结果

抽象模型每一位都要选一个没用过的数
思考套路
当前是第几位？
哪些元素还没用？
用一个 visited[] 标记

模板void dfs(int depth) &#123;    if (depth == n) &#123;        保存结果;        return;    &#125;    for (int i = 0; i &lt; n; i++) &#123;        if (used[i]) continue;        used[i] = 1;        path[depth] = nums[i];        dfs(depth + 1);        used[i] = 0;    &#125;&#125;

注意： 排列类需要使用 visited 数组来标记已使用的元素，避免重复使用同一元素。
③ 子集类（Subset &#x2F; 选或不选）典型题目
子集
子集 II（含重复）
所有子序列

特征
每个元素只有两种状态：选 &#x2F; 不选
没有顺序概念

抽象模型（决策树）    []  /    \选      不选

思考套路
到第 i 个元素
做 2 个决定

模板void dfs(int i) &#123;    if (i == n) &#123;        保存结果;        return;    &#125;    // 不选    dfs(i + 1);    // 选    path.push(nums[i]);    dfs(i + 1);    path.pop();&#125;

注意： 子集类通过递归遍历每个元素的选择状态，生成所有可能的子集。
④ 路径 &#x2F; 棋盘 &#x2F; 搜索类（DFS 搜索）典型题目
单词搜索
迷宫路径
N 皇后
数独

特征
在「二维 &#x2F; 多维空间」中走
有方向、边界、障碍
常有 visited 标记

抽象模型从一个点出发向多个方向尝试不合法就退回
思考套路
当前在哪？
能往哪走？
什么时候停止？
如何标记访问？

模板void dfs(int x, int y) &#123;    if (越界 / 不合法) return;    if (找到答案) return;    visited[x][y] = 1;    for (方向) &#123;        dfs(nx, ny);    &#125;    visited[x][y] = 0;&#125;

注意： 在搜索类问题中，visited 数组防止重复访问同一位置，确保路径的正确性。
⑤ 分割 &#x2F; 构造类（切分字符串）典型题目
回文串分割
IP 地址还原
表达式添加运算符

特征
从字符串中「切一刀」
每一段要合法

抽象模型当前位置开始尝试切不同长度
思考套路
从哪切？
切多长？
这一段是否合法？

模板void dfs(int start) &#123;    if (start == len) &#123;        保存结果;        return;    &#125;    for (int i = start; i &lt; len; i++) &#123;        if (合法(start, i)) &#123;            path.push(s[start..i]);            dfs(i + 1);            path.pop();        &#125;    &#125;&#125;

注意： 分割类需要验证每段的合法性，如回文或有效IP段。
三、回溯题要素
一步要做什么决定？选哪个数？往哪个方向走？切多长？

选择列表是什么？当前能选的所有可能

什么时候结束？深度到头条件满足

如何回退？覆盖popvisited 还原


回溯算法的核心在于通过递归探索所有可能的解决方案，并在不满足条件时回退。实践中，要注意剪枝优化，避免不必要的计算。
四、回溯算法的剪枝优化剪枝的基本概念如何剪枝： 通过在递归过程中添加条件判断，提前终止不可能成功的分支，从而减少搜索空间，提高效率。
什么时候剪枝： 当当前状态或路径不可能达到目标条件时，进行剪枝。例如，当前和超过目标、剩余元素不足等。
常见剪枝技巧分类讨论1. 排序去重剪枝
适用题型： 组合类（Combination）、子集类（Subset）中含有重复元素的题目，如子集 II、组合总和 II。
如何剪枝： 对候选数组进行排序，在选择元素时跳过与前一个相同的元素，避免生成重复结果。
代码示例：// 在组合类中for (int i = start; i &lt; n; i++) &#123;    if (i &gt; start &amp;&amp; nums[i] == nums[i-1]) continue;  // 跳过重复    // 选择 i&#125;
什么时候使用： 当题目允许重复选择但结果不能重复时。

2. 限制条件剪枝
适用题型： 组合总和类、背包问题变体。
如何剪枝： 在递归中检查当前累积值（如和、积）是否超过限制，如果超过则提前返回。
代码示例：if (currentSum &gt; target) return;  // 组合总和
什么时候使用： 当有数值限制（如和不能超过目标）时。

3. 长度限制剪枝
适用题型： 组合类（指定组合长度）、排列类（部分排列）。
如何剪枝： 计算剩余可选元素数量，如果不足以达到所需长度，则停止递归。
代码示例：if (n - i &lt; k - path.size()) return;  // k 个数的组合
什么时候使用： 当组合或排列有固定长度要求时。

4. 对称性剪枝
适用题型： N 皇后、其他对称性问题。
如何剪枝： 利用问题的对称性，只搜索一半或四分之一的空间，然后通过对称生成另一半。
代码示例： 在 N 皇后中，只考虑皇后放在左半边。
什么时候使用： 当问题具有对称性，且结果可以通过对称变换得到时。

5. 搜索类剪枝（路径 &#x2F; 棋盘）
适用题型： 单词搜索、迷宫路径、数独。
如何剪枝： 使用 visited 数组避免重复访问同一位置；边界检查；提前判断是否可能到达目标。
代码示例：if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visited[x][y]) return;
什么时候使用： 在二维或多维空间搜索时，防止循环和无效路径。

6. 分割类剪枝
适用题型： 回文串分割、IP 地址还原。
如何剪枝： 在分割时，检查当前段是否合法（如是否为回文、有效IP段），不合法则跳过。
代码示例：if (!isPalindrome(s, start, i)) continue;  // 回文分割
什么时候使用： 当分割后的每段必须满足特定条件时。

五、LeetCode 回溯算法实战合集1. 分割 &#x2F; 构造类这些问题涉及按某些特定条件对字符串、数字等进行切割或构造特定的结构。
131. 分割回文串LeetCode 131. 分割回文串
核心方向：按回文条件切割字符串，枚举所有回文切割方案。
回溯技巧：递归切割，每次递归检查子串是否为回文。
//1.回溯算法char*** result;char** path;int pathSize = 0;// 判断s字符串中的子串是否为回文串bool isPalindrome(char* s, int startIndex, int endIndex)&#123;    while(startIndex &lt;= endIndex)&#123;        if(s[endIndex--] != s[startIndex++])&#123;            return false;        &#125;    &#125;    return true;&#125;void backtracking(char* s, int* returnSize, int startIndex, int** returnColumnSizes)&#123;    if(startIndex == strlen(s))&#123;        result[*returnSize] = (char**)malloc(sizeof(char*) * pathSize);        for(int i = 0; i &lt; pathSize; i++)&#123;            result[*returnSize][i] = path[i];         &#125;        (*returnColumnSizes)[(*returnSize)++] = pathSize;        return;    &#125;    for(int i = startIndex; i &lt; strlen(s); i++)&#123;        if(isPalindrome(s, startIndex, i))&#123;            char* temp = (char*)malloc(sizeof(char) * (i - startIndex + 2));            int index = 0;            for(int j = startIndex; j &lt;= i; j++)&#123;                temp[index++] = s[j];            &#125;            temp[index] = &#x27;\0&#x27;;            path[pathSize++] = temp;        &#125;        else&#123;            continue;        &#125;        backtracking(s, returnSize, i + 1, returnColumnSizes);                pathSize--;    &#125;&#125;char*** partition(char* s, int* returnSize, int** returnColumnSizes) &#123;    result = (char***)malloc(sizeof(char**) * 100000);    path = (char**)malloc(sizeof(char*) * 100000);    *returnColumnSizes = (int*)malloc(sizeof(int) * 100000);    *returnSize = 0;    backtracking(s, returnSize, 0, returnColumnSizes);    return result;&#125;

22. 括号生成LeetCode 22. 括号生成
核心方向：生成所有合法的括号组合（左括号数 &#x3D; 右括号数）。
回溯技巧：递归生成括号，剪枝（如左括号数 ≤ n、右括号数 ≤ 左括号数）。
//1.回溯算法void dfs(char** res, int* returnSize, char* path, int pos, int left, int right, int n) &#123;    // 终止条件：构造完成    if (pos == 2 * n) &#123;        res[*returnSize] = (char*)malloc(2 * n + 1);        memcpy(res[*returnSize], path, 2 * n + 1);        (*returnSize)++;        return;    &#125;    // 尝试放 &#x27;(&#x27;    if (left &lt; n) &#123;        path[pos] = &#x27;(&#x27;;        dfs(res, returnSize, path, pos + 1, left + 1, right, n);    &#125;    // 尝试放 &#x27;)&#x27;    if (right &lt; left) &#123;        path[pos] = &#x27;)&#x27;;        dfs(res, returnSize, path, pos + 1, left, right + 1, n);    &#125;&#125;char** generateParenthesis(int n, int* returnSize) &#123;    *returnSize = 0;    char** res = (char**)malloc(sizeof(char*) * 1500);    char* path = (char*)malloc(2 * n + 1);    path[2 * n] = &#x27;\0&#x27;;    dfs(res, returnSize, path, 0, 0, 0, n);    free(path);    return res;&#125;

2. 路径 &#x2F; 棋盘 &#x2F; 搜索类这些问题通常涉及在二维或多维的空间中搜索路径。
79. 单词搜索LeetCode 79. 单词搜索
核心方向：在二维网格中搜索目标字符串的路径。
回溯技巧：标记访问过的格子，避免重复走，剪枝（越界或字符不匹配时终止）。
//1.回溯算法void backTracking(char** board,int m,int n,char* word,int size,int row,int col,bool* flag,int** used)&#123;    if(*flag) return;    if(word[size]==&#x27;\0&#x27;)&#123;        *flag=true;        return;    &#125;    //这里要注意对row和col的越界判断应该放在最前面，否则无法后面的数组判定无法进行    if (row &lt; 0 || row &gt;= m || col &lt; 0 || col &gt;= n || board[row][col] != word[size] || used[row][col] == 1) &#123;        return;    &#125;    used[row][col]=1;    backTracking(board,m,n,word,size+1,row+1,col,flag,used);    backTracking(board,m,n,word,size+1,row-1,col,flag,used);    backTracking(board,m,n,word,size+1,row,col+1,flag,used);    backTracking(board,m,n,word,size+1,row,col-1,flag,used);    used[row][col]=0;&#125;bool exist(char** board, int boardSize, int* boardColSize, char* word) &#123;    int m=boardSize;    int n=boardColSize[0];    bool flag=false;    int** used = (int**)malloc(m * sizeof(int*));    for (int i = 0; i &lt; m; i++) &#123;    used[i] = (int*)malloc(n * sizeof(int));    memset(used[i], 0, n * sizeof(int));    &#125;    for (int i = 0; i &lt; m; i++) &#123;        for (int j = 0; j &lt; n; j++) &#123;            if (board[i][j] == word[0]) &#123;  // 如果当前字符匹配，开始回溯                backTracking(board, m, n, word, 0, i, j, &amp;flag, used);                if (flag) return true;  // 找到匹配的单词            &#125;        &#125;    &#125;    for (int i = 0; i &lt; m; i++) &#123;        free(used[i]);    &#125;    free(used);    return flag;&#125;

3. 子集类这些问题通常是枚举所有可能的子集，包含空集。
78. 子集LeetCode 78. 子集
核心方向：枚举一个集合的所有子集（包括空集）。
回溯技巧：通过 start 参数控制选择顺序，避免重复子集。
//1.递归法（回溯）void dfs(int* nums, int numsSize, int start,int* path, int pathSize,int** res, int* returnSize, int* colSizes) &#123;    // 保存当前子集    res[*returnSize] = (int*)malloc(sizeof(int) * pathSize);    memcpy(res[*returnSize], path, sizeof(int) * pathSize);    colSizes[*returnSize] = pathSize;    (*returnSize)++;    for (int i = start; i &lt; numsSize; i++) &#123;        path[pathSize] = nums[i];        dfs(nums, numsSize, i + 1, path, pathSize + 1, res, returnSize, colSizes);    &#125;&#125;int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) &#123;    int maxSize = 1 &lt;&lt; numsSize;    int** res = (int**)malloc(sizeof(int*) * maxSize);    *returnColumnSizes = (int*)malloc(sizeof(int) * maxSize);    int* path = (int*)malloc(sizeof(int) * numsSize);    *returnSize = 0;    dfs(nums, numsSize, 0, path, 0, res, returnSize, *returnColumnSizes);    free(path);    return res;&#125;

4. 排列类这些问题涉及到元素的排列，通常要求考虑元素顺序。
46. 全排列LeetCode 46. 全排列
核心方向：枚举所有元素的排列。
回溯技巧：标记已使用的元素，避免重复排列。处理重复元素时需要去重。
//1.回溯算法/*void backtrack(当前状态, 其他参数) &#123;    if (满足结束条件) &#123;        记录结果;        return;    &#125;    for (每个可能的选择) &#123;        做出选择;           // 修改状态        backtrack(新状态, ...); // 递归        撤销选择;           // 恢复状态（关键！）    &#125;&#125;*/int count;void DFS(int *nums, int numsSize, int depth, int *path, bool *used, int **res) &#123;    if (depth == numsSize) &#123;        res[count] = (int *)malloc(sizeof(int) * numsSize);        memcpy(res[count++], path, sizeof(int) * numsSize);        return;    &#125;    for (int i = 0; i &lt; numsSize; i++) &#123;        if (used[i] == true) &#123;            continue;        &#125;        path[depth] = nums[i];        used[i] = true;        DFS(nums, numsSize, depth + 1, path, used, res);        used[i] = false;    &#125;&#125;int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes)&#123;    (*returnSize) = 1;    for (int i = 1; i &lt;= numsSize; i++) &#123;        (*returnSize) *= i;    &#125;    *returnColumnSizes = (int *)malloc(sizeof(int) * (*returnSize));    for (int i = 0; i &lt; (*returnSize); i++) &#123;        (*returnColumnSizes)[i] = numsSize;    &#125;    int **res = (int **)malloc(sizeof(int *) * (*returnSize));    int *path = (int *)malloc(sizeof(int) * numsSize);    bool *used = (bool *)calloc(numsSize, sizeof(bool));    count = 0;    DFS(nums, numsSize, 0, path, used, res);    return res;&#125;

5. 组合类这些问题通常涉及多个集合的组合或从一个集合中选择元素，可能会有条件限制（如总和、数量等）。
17. 电话号码的字母组合LeetCode 17. 电话号码的字母组合
核心方向：多个数字对应字母集合，选一个字母组合。
回溯技巧：每次递归选择一个字母，并递归继续选择下一个字母。
//1.回溯 / DFSchar *map[10] = &#123;    &quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;,    &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;void dfs(char *digits, int idx, char *path, char **res, int *returnSize) &#123;    if (digits[idx] == &#x27;\0&#x27;) &#123;        int len = strlen(path);        res[*returnSize] = malloc(len + 1);        memcpy(res[*returnSize], path, len + 1);          (*returnSize)++;        return;    &#125;    char *letters = map[digits[idx] - &#x27;0&#x27;];    for (int i = 0; letters[i]; i++) &#123;        path[idx] = letters[i];        path[idx + 1] = &#x27;\0&#x27;;        dfs(digits, idx + 1, path, res, returnSize);    &#125;&#125;char **letterCombinations(char *digits, int *returnSize) &#123;    *returnSize = 0;    if (!digits || !digits[0]) return NULL;    int len = strlen(digits);    char **res = malloc(sizeof(char *) * 256);    char path[len + 1];    dfs(digits, 0, path, res, returnSize);    return res;&#125;

39. 组合总和LeetCode 39. 组合总和
核心方向：从数组中选元素，使其和为目标值，允许重复选择。
回溯技巧：递归选择，控制选择范围，剪枝（如果和超过目标值，则提前停止递归）。
//1.回溯递归void dfs(int* candidates, int candidatesSize, int target, int* returnSize, int* path, int* returnColumnSizes, int pathSize, int** res, int start) &#123;    if (target == 0) &#123;        // 找到一个满足条件的组合        res[*returnSize] = (int*)malloc(sizeof(int) * pathSize);        memcpy(res[*returnSize], path, sizeof(int) * pathSize);        returnColumnSizes[*returnSize] = pathSize;  // 记录当前组合的大小        (*returnSize)++;  // 更新组合数量        return;    &#125;        if (target &lt; 0) &#123;        return;  // 剪枝：当 target 小于 0 时，当前路径无效    &#125;    for (int i = start; i &lt; candidatesSize; i++) &#123;        path[pathSize] = candidates[i];  // 选择当前候选数        // 递归，允许同一个数字多次选择，因此 start 还是从 i 开始        dfs(candidates, candidatesSize, target - candidates[i], returnSize, path, returnColumnSizes, pathSize + 1, res, i);    &#125;&#125;int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes) &#123;    *returnSize = 0;    int** res = (int**)malloc(sizeof(int*) * 150);    int* path = (int*)malloc(sizeof(int) *50);    *returnColumnSizes = (int*)malloc(sizeof(int) * 150);    dfs(candidates, candidatesSize, target, returnSize, path, *returnColumnSizes, 0, res, 0);    free(path);    return res;&#125;]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>堆的基本操作</title>
    <url>/2026/01/04/%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[引言堆是一种特殊的完全二叉树结构，常用于实现优先队列。在最大堆中，父节点的值总是大于或等于其子节点的值。本文将通过C语言代码实现一个最大堆
堆的基本概念堆是一种数据结构，具有以下特性：

完全二叉树：除了最后一层，其他层都是满的，且最后一层的节点都靠左排列
堆序性：在最大堆中，任意节点的值大于或等于其子节点的值

堆通常用数组来实现，其中：

根节点索引: 0
左子节点索引：2*i + 1
右子节点索引：2*i + 2
父节点索引： (i-1)/2

代码实现下面是最大堆的C语言实现
1. 堆的结构体定义typedef struct &#123;    int *data;      // 动态数组，数组指针    int size;       // 堆的元素个数    int capacity;   // 堆的最大容量&#125; MaxHeap;

2. 交换元素void swap(int *a, int *b) &#123;    int tmp = *a;    *a = *b;    *b = tmp;&#125;

3. 初始化堆MaxHeap* createHeap(int capacity) &#123;    // 初始化分配空间    MaxHeap* heap = (MaxHeap*)malloc(sizeof(MaxHeap));    heap-&gt;data = (int*)malloc(sizeof(int) * capacity);    // 堆数值初始化    heap-&gt;capacity = capacity;    heap-&gt;size = 0;    return heap;&#125;

4. 向上调整（siftUp）用于插入元素后维护堆的性质。从插入的节点开始，与父节点比较，如果大于父节点则交换，直到满足堆序性
void siftUp(MaxHeap* heap, int childIdx) &#123;    while (childIdx &gt; 0) &#123;        int parentIdx = (childIdx - 1) / 2;        if (heap-&gt;data[childIdx] &gt; heap-&gt;data[parentIdx]) &#123;            swap(&amp;heap-&gt;data[childIdx], &amp;heap-&gt;data[parentIdx]);            childIdx = parentIdx;        &#125; else &#123;            break;        &#125;    &#125;&#125;

5. 向下调整（siftDown）用于删除堆顶或建堆时维护堆的性质。从指定节点开始，与子节点比较，选择最大的子节点交换，直到满足堆序性
void siftDown(MaxHeap* heap, int parentIdx) &#123;    int size = heap-&gt;size;    while (true) &#123;        int leftChild = parentIdx * 2 + 1;        int rightChild = parentIdx * 2 + 2;        int largest = parentIdx;                if (leftChild &lt; size &amp;&amp; heap-&gt;data[leftChild] &gt; heap-&gt;data[largest]) &#123;            largest = leftChild;        &#125;        if (rightChild &lt; size &amp;&amp; heap-&gt;data[rightChild] &gt; heap-&gt;data[largest]) &#123;            largest = rightChild;        &#125;        if (largest != parentIdx) &#123;            swap(&amp;heap-&gt;data[largest], &amp;heap-&gt;data[parentIdx]);            parentIdx = largest;        &#125; else &#123;            break;        &#125;    &#125;&#125;

6. 入堆操作（push）bool push(MaxHeap* heap, int val) &#123;    // 满堆的处理    if (heap-&gt;size == heap-&gt;capacity)        return false;    heap-&gt;data[heap-&gt;size] = val;    // 这里siftUp与size无关，所以两者顺序不影响    siftUp(heap, heap-&gt;size);    heap-&gt;size++;    return true;&#125;

7. 出堆操作（pop）int pop(MaxHeap* heap) &#123;    // 空堆检查    if (heap-&gt;size == 0) return -1;    int root = heap-&gt;data[0];             // 用最后一个元素覆盖堆顶    heap-&gt;data[0] = heap-&gt;data[heap-&gt;size - 1];        // 必须先减size再siftDown：    // 1. siftDown依赖正确的heap-&gt;size判断子节点边界    // 2. 原末尾元素已移至堆顶，该位置不再属于堆    // 3. 避免siftDown访问到逻辑上已移除的元素    heap-&gt;size--;      siftDown(heap, 0);    return root;&#125;

8. 删除任意位置的元素void deleteElement(MaxHeap* heap, int i) &#123;    if (i &lt; 0 || i &gt;= heap-&gt;size)        return;    if (i == 0) &#123;        pop(heap);        return;    &#125;    if (i == heap-&gt;size - 1) &#123;        heap-&gt;size--;        return;    &#125;    int lastVal = heap-&gt;data[heap-&gt;size - 1];    heap-&gt;size--;    int oldVal = heap-&gt;data[i];    heap-&gt;data[i] = lastVal;    if (lastVal &gt; oldVal) &#123;        siftUp(heap, i);    &#125; else &#123;        siftDown(heap, i);    &#125;&#125;

9. 建堆操作MaxHeap* makeHeap(int* nums, int numsSize) &#123;    // 堆的初始化    MaxHeap* heap = createHeap(numsSize);    // 数组拷贝到堆    memcpy(heap-&gt;data, nums, numsSize * sizeof(int));    heap-&gt;size = numsSize;    // 从最后一个非叶节点开始向下调整    for (int i = (numsSize / 2) - 1; i &gt;= 0; i--) &#123;        siftDown(heap, i);    &#125;    return heap;&#125;

总结通过以上代码，我们实现了一个完整的大根堆数据结构，堆的基本操作包括：

插入：使用push函数，时间复杂度O(log n)
删除堆顶：使用pop函数，时间复杂度O(log n)
删除任意元素：使用deleteElement函数，时间复杂度O(log n)
建堆：使用makeHeap函数，时间复杂度O(n)

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>独居者</title>
    <url>/2023/07/26/%E7%8B%AC%E5%B1%85%E8%80%85/</url>
    <content><![CDATA[
作者：陆蠡




正文
现在我很懊悔无意中发现了C君的秘密，一个人在孤独时的秘密。这是一种痛苦，他原先紧紧藏着，预备留给他自己的，我无意中知道，这痛苦乃交给了我。他自己还不知道这回事，实际上另外有个人在分担他的痛苦了。听说有一种眚神，专给人家作祟的。但作祟的工作要在秘密中进行。譬如一个人在单房暗室，独处的时候，这眚神便用各种威胁引诱，弄得他害病为止。万一这作祟的工作被一个闯入者发现了或道破了，这眚神便舍掉原先想害的人，转向闯入者纠缠，将祸害嫁给后者。我碰到的正是这种情形。当我发现了他深自掩藏着的痛苦，我也要替他分负的了。

　　要说我为什么把这回事放在自己心上？我不知道。只好怪我自己了。要说他有什么痛苦，为什么痛苦？我也不知道。这是一个谜。痛苦是往往说不出的。好像挨了毒打，浑身疼痛，却摸不着痛处。C君是一个奇特的人！他是属于幸福的一群呢？还是属于不幸的一群呢？我不能下断语。要论断某一个人，总得自己的见解智慧比人高出一筹，方得中肯。正如景色的眺望者，从高处往下看，方见全景；若从卑处往高看，所见结果一定不对的。我对C君的观察是从卑处往高看吧，我的叙述也许是不对的。也许他不似我所猜想的，根本没有什么痛苦，这一切倒是我自己的幻觉，这也难定。总之，说他有点奇特，不算过分吧。
　　C君是我的朋友。我们认识有许多年头了。他给我最初的印象是一个可爱的，快乐的，和蔼的青年人。他服装穿得干净，鞋帽整齐。他的头发总是剪得齐齐的，两旁梳开，披在颞颥边，中间显出一条肉路。他的脸端正，端庄的表情浮在端正的脸上，有一种没有矜伐的厚道。他有明净的眼珠，不常直视人，偶然碰到别人的眼光在他的脸上搜索的时候，总是微微一笑避开。他鼻子方正，鼻准微平。嘴也搭配得大小适宜，嘴唇略厚一点，这使他的脸减损一分秀气。他会说话，不大流利，可够表达，显然是练习出来的。他的脸颜微嫌瘦削，照他的骨架子，应当更丰满些。总之，他是一望而知的没有受过生活鞭挞的人，在一个陌生人的眼中，正如一般生活优裕的人，往往多受人们尊敬。
　　从他对人和做事的态度看来，他是一个热情的没有自私的青年。他对朋友极诚恳，做事认真负责。他的信念极坚定，在他的眼前永远闪现着美丽的希望。他不颓沮，不懊丧，脸上心里总是浮着微笑的。他从没有对任何事失去忍耐，对任何人抱怨，责备；他忙，但颇有点闲情。有一次我见他照画报上的样子在剖剔一个水仙球茎，弄了好几个钟头，似乎没失去耐性。
　　我们时常在一起，散步谈天。我们谈到粗俗的，猥亵的，平凡的，崇高的，他很坦白，很少隐藏，因此我也约略知道他的身世，他的思想，他的感情。一切都没超人或异乎常人的地方。他正是一个脚踏实地地为理想的工作者。
　　但是当我发现他有一种爱好独居的性格的时候，我渐渐觉得他有点奇特。他的工作（我想对他的工作性质的说明是不必要的。世界上，哪种工作最高贵最重要，而哪一种又不重要的，无价值的，我想没有人能够品评），使他和人们亲近，同居处，同饮食。但他总是单独住一个房间。他从不肯留一个朋友在他房里住宿。他好像是洁身自爱的女子，不让别人占用她的闺闼。当有一次一位从远道来的友人来望他，那友人找不到别的宿处而又疲倦了，打算在他房里过一夜，他陪他坐到夜深，最后，站起来说道：“我房里没留过客人，我要保持这记录，我陪你上旅馆去。”友人显然有点愠色，但他还是曳着友人上旅馆去了。这事后来那友人告诉我好多次，说他是有点不近人情的。
　　他住的房间陈设简陋，但他守住这简陋的房间，像野兽守住它的洞穴，不愿意别兽闯入。我对个人的癖爱颇能谅解。像他这样的人，也许为了工作性质的关系，也许为了读书研习的关系，不愿别人打吵他，是说得过去的。我曾有个时期和他同住在一所公共的建筑内，同处在一个屋顶下，但我们仍旧保持着各人的生活习惯。因为我们有着不同的职业。我白天出去，晚上一早就睡了。他到夜深睡，早晨起床比较迟。有时候我们是数天不见面的。
　　一天的夜里我发现了他孑身独处的原因。愿他原谅我，我是无心的。我看取了他的秘密，却无法把它交还原主，这使我时时引以为憾。我不是好奇的。这发现属于偶然，至今我还是懊悔那一次的闯入。
　　那是一个有月亮的夏季的晚上，夜深使一切喧嚣归于静寂。我这夜特别比平时睡得迟，正预备熄灯睡的时候，突然想起一件东西遗在C君的房里，想立刻得到它。我想他是已经睡了，为了不惊扰他，我悄声走过去，我蹑着脚步走近他的房间。他的房门没有锁，被午夜的风吹开，留着一条阔缝。我一脚跨进去，仿佛眼前一个异景怔住了我，我几乎不相信我自己的眼睛了。C君在做什么啦！他跪在自己床前的地上，头伏在臂里，好像在作祈祷。从窗口斜射进来的月光把室内照成一种淡淡的晖明，他虽则跪在暗里，我却清楚地能够辨别他额上流着汗，脸孔是严肃而神秘的，一种不胜苦楚之情。这使我想起耶稣基督在客西马尼亚园中的祈祷：“汗珠大如血点，流在地上。”一种在苦杯前踌躇的惶悚。C君也好像是在推开一个苦杯而又准备接受。他全神贯注地沉在默念中，好像在一种不可见的神前忏悔，又好像是一个为热情所燃烧的男子在冷若冰霜的女子面前恳求，一种祈求幸福或是向幸福辞谢的神情……我几乎失声喊了出来，一种神秘的力量使我噤住。我悄悄退出，站在外面，从门隙中望他继续的动作。约莫过了四五分钟，他慢慢地站起来，走向窗口，面朝月光把手徐徐举起，好像迎接从月光中降落的天使似的。随后又把手垂下，向后摸索着床架，扶在上面，脸仍不回过来，这样站着好久好久。我只能从他偶然偏过来的脸望见那上面的神秘似的似乎痉挛的表情。“他是被痛苦啮噬着，”我忽然想到，于是迅速地跑回我自己的房间，忘记了适才去他房里的目的，我熄了灯，躺在床上，辗转了好久，我细细分析他平时的见解和行为，一丝也没有异样。但渐渐我从他偶尔流露的片言只语里，好像发觉他是怀着什么痛苦。
　　那也是和他相识不久的时候，我们已有时常谈天的习惯，我坐在他房里，我们纵谈着各种琐事，讨论着许多问题。我们谈得很有兴趣，这时他手中揉弄着一条领带。我想到一个友人，爱把领带当作裤带束在腰间，于是我说：
　　“你知道领带还有什么别的用途么？”
　　“哈哈哈。”
　　“猜得着吗？”
　　“哈哈哈。”
　　我不耐烦地就把我的发现告诉他。说是领带当裤带是适宜的。长短阔狭都好，只是一端太宽了些。
　　“还有一个用途。”他补充说。
　　“什么？”
　　“哈哈哈。”他不说下去了。
　　但是一转想我也猜到了。那是上吊用的。当时我觉得这家伙脑筋古怪，怎会想到这上面来呢？但是他那快活的笑声，立刻把我思想的阴云打散了。
　　我从来不曾听到他悲观的论调。但有一次一个友人颂赞“生的欢喜”“生的美丽”说：
　　“生是多美丽啊！我便从来没想到自杀过。”
　　“谎话！”好像听见C君的自言自语。但他立刻用快活的声音接着道：
　　“是的。生是美丽的。”
　　谁能够解释他身上的矛盾呢？谁能够看出他极快活的表面底下潜藏着一个痛苦的灵魂？他有希望的光明，却又有失望的暗影；他有快乐的外表，却又有忧郁的内心。他好像是一池深深的潭水，表面平静光滑，反射着美丽的阳光，底里却翻涌着涡卷的伏流。有人留心到海面么？涡流最急的地方往往表面上显得异常光滑。C君的心境便是这样子。令人费于索解了。
　　我想从他自己的口中和别人的口中探听，他是否受过什么大刺激，譬如失恋等情事，答案都是否定的。受过良好的教育，正如有着进步思想的人，他是自由主义者，他反对宗教，反对权力，反对加在人类身上的经济的和思想的一切桎梏，那么他为什么那样苦苦地祈祷呢？简直像一个虔诚的教徒！为什么他想到“死”呢？想到人们认为罪恶而自己也认为罪恶的“自杀”呢？这一切都是谜。他是在割舍一种人性上离不开的东西呢？他是不是凭他那严刻的内省，在替他自己的信念和理想觅取一种道德上的支持？好像他发现了一种理想，而又怀疑着，又给自己的怀疑解释，而这解释又不能使自己满意，他想抓住无定形的理想，而又抓不住，因而显得痛苦呢？这一些，也许连他自己也不会明白。
　　于是我发现他平时乐观的态度倒是一种悲哀的掩饰了。嗣后每次他和我谈话的时候，我便不禁想起他夜晚苦苦跪着的样子。“他苦苦地制造了一个希望，一个理想，来扶掖自己。”我总这样地想。他是天生的有忧郁性格的人，却人为地在忧郁的底子上抹上一层愉快的色彩。这种努力是可敬的，但是这种努力，总给我以一种不可言说的悲哀。
]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>链表系列之快慢指针</title>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[快慢指针核心快慢指针是链表问题中最经典的算法技巧之一
核心思想是使用两个指针同时遍历链表，但移动速度不同：

快指针每次移动2步
慢指针每次移动1步

这个简单的速度差异，能够解决环检测、找中点、定位特定位置等一系列问题

应用场景一：检测链表是否有环LeetCode 141. 环形链表
问题描述给定一个链表，判断链表中是否有环
核心思路如果链表有环，快慢指针最终一定会相遇
就像在操场跑步，速度快的人一定会追上速度慢的人
代码实现bool hasCycle(struct ListNode *head) &#123;    if (head == NULL) &#123;         return false;    &#125;    struct ListNode* slow = head;    struct ListNode* fast = head-&gt;next;    while(slow != fast) &#123;        if (fast == NULL || fast-&gt;next == NULL) &#123;            return false;        &#125;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;    &#125;    return true;&#125;

关键点
快指针走两步前要判断 fast-&gt;next 是否为空
快慢指针初始位置可以不同（一个在head，一个在head-&gt;next）
循环条件是 slow != fast


应用场景二：找到环的入口节点LeetCode 142. 环形链表 II
问题描述如果链表有环，找到环的起始节点
核心思路（Floyd判圈算法）这是快慢指针最精妙的应用，分为两个阶段：
第一阶段：判断是否有环

快慢指针同时从head出发
快指针每次2步，慢指针每次1步
如果相遇，说明有环

第二阶段：寻找环起点

将一个指针放回链表头
两个指针都改为每次走1步
再次相遇的点就是环起点

数学证明设链表头到环入口距离为 a，环入口到相遇点距离为 b，相遇点到环入口距离为 c
相遇时：

慢指针走了：a + b
快指针走了：a + b + c + b &#x3D; a + 2b + c

因为快指针速度是慢指针2倍，所以：

2(a + b) = a + 2b + c
化简得：a = c

这就是为什么从头节点和相遇点同时出发，会在环入口相遇
代码实现struct ListNode *detectCycle(struct ListNode *head) &#123;    if (head == NULL || head-&gt;next == NULL) &#123;        return NULL;    &#125;        // 关键：slow和fast都从head开始    struct ListNode* slow = head;    struct ListNode* fast = head;        // 第一阶段：判断是否有环    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;                if (slow == fast) &#123;            // 第二阶段：寻找环起点            fast = head;            while (fast != slow) &#123;                fast = fast-&gt;next;                slow = slow-&gt;next;            &#125;            return slow;  // 环起点        &#125;    &#125;        return NULL;  // 无环&#125;

关键点
第一阶段slow和fast必须从同一位置出发
相遇后将其中一个指针移回head
第二阶段两个指针都是每次走1步


应用场景三：删除倒数第N个节点LeetCode 19. 删除链表的倒数第 N 个结点
问题描述给定一个链表，删除倒数第N个节点
核心思路让快指针先走N步，然后快慢指针同时前进
当快指针到达末尾时，慢指针正好在倒数第N个节点的前一个位置
代码实现struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;    if(head-&gt;next==NULL)        return NULL;        struct ListNode dummy;    struct ListNode* curr = &amp;dummy;    dummy.next = head;        struct ListNode* fast=curr;    struct ListNode* low=curr;        // 快指针先走n步    for(int i=0;i&lt;n;i++)&#123;        fast=fast-&gt;next;    &#125;        // 快慢指针同时前进    while(fast-&gt;next!=NULL)&#123;        low=low-&gt;next;        fast=fast-&gt;next;    &#125;        // 删除节点    struct ListNode* tmp=low-&gt;next;    low-&gt;next=low-&gt;next-&gt;next;    free(tmp);        return dummy.next;&#125;

关键点
使用虚拟头节点，避免处理删除头节点的边界情况
快指针要先走N步
慢指针停在待删除节点的前一个位置


应用场景四：判断回文链表LeetCode 234. 回文链表
问题描述判断一个链表是否为回文结构
核心思路
用快慢指针找到链表中点
反转后半部分链表
比较前后两部分是否相同

代码实现// 反转链表辅助函数struct ListNode* reverseList(struct ListNode* head) &#123;    if(head==NULL)        return NULL;        struct ListNode* cur=head;    struct ListNode* prev=NULL;    struct ListNode* next;        while(cur)&#123;        next=cur-&gt;next;        cur-&gt;next=prev;        prev=cur;        cur=next;    &#125;    return prev;&#125;bool isPalindrome(struct ListNode* head) &#123;    if(head-&gt;next==NULL)&#123;        return true;    &#125;    struct ListNode* low=head;    struct ListNode* fast=head;    struct ListNode* tmp;    struct ListNode* head_behind;    struct ListNode* head_ahead;        // 快慢指针找中点    while(fast &amp;&amp; fast-&gt;next)&#123;        low=low-&gt;next;        fast=fast-&gt;next-&gt;next;    &#125;    // 根据链表奇偶判断后半段起点    if(fast)&#123;        tmp=low-&gt;next;  // 奇数个节点    &#125;    else&#123;        tmp=low;  // 偶数个节点    &#125;        // 反转后半部分    head_behind=reverseList(tmp);    head_ahead=head;    // 比较两部分    while(head_behind)&#123;        if(head_behind-&gt;val==head_ahead-&gt;val)&#123;            head_ahead=head_ahead-&gt;next;            head_behind=head_behind-&gt;next;        &#125;        else&#123;            return false;        &#125;    &#125;    return true;&#125;

关键点
快指针走到末尾时，慢指针在中点
要区分链表节点个数的奇偶性
空间复杂度O(1)，优于使用栈的方案


应用场景五：链表排序中找中点LeetCode 148. 排序链表
问题描述对链表进行排序，要求时间复杂度O(n log n)
核心思路使用归并排序：

用快慢指针找中点，分割链表
递归排序左右两部分
合并两个有序链表

代码实现// 找到链表中间节点struct ListNode* findMiddle(struct ListNode* head) &#123;    if (!head || !head-&gt;next) return head;        struct ListNode *slow = head;    struct ListNode *fast = head-&gt;next;  // fast从head-&gt;next开始        while (fast &amp;&amp; fast-&gt;next) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;    &#125;        return slow;&#125;// 合并两个有序链表struct ListNode* merge(struct ListNode* l1, struct ListNode* l2) &#123;    struct ListNode dummy;    struct ListNode* tail = &amp;dummy;    dummy.next = NULL;        while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            tail-&gt;next = l1;            l1 = l1-&gt;next;        &#125; else &#123;            tail-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        tail = tail-&gt;next;    &#125;        tail-&gt;next = l1 ? l1 : l2;    return dummy.next;&#125;// 递归归并排序主函数struct ListNode* sortList(struct ListNode* head) &#123;    // 递归终止条件    if (!head || !head-&gt;next) &#123;        return head;    &#125;        // 1. 找到中间节点并分割    struct ListNode* mid = findMiddle(head);    struct ListNode* right = mid-&gt;next;    mid-&gt;next = NULL;  // 切断链表        // 2. 递归排序左右两部分    struct ListNode* leftSorted = sortList(head);    struct ListNode* rightSorted = sortList(right);        // 3. 合并有序链表    return merge(leftSorted, rightSorted);&#125;

关键点
快指针从head-&gt;next开始，确保分割点在左半部分
分割后要将左半部分的尾节点指向NULL
归并排序是链表排序的最优解


快慢指针核心总结基本模板struct ListNode* slow = head;struct ListNode* fast = head;while (fast != NULL &amp;&amp; fast-&gt;next != NULL) &#123;    slow = slow-&gt;next;    fast = fast-&gt;next-&gt;next;&#125;


注意事项
空指针判断：快指针移动前要判断fast和fast-&gt;next
初始位置：根据具体问题选择是否从同一位置开始
奇偶处理：找中点时要注意链表长度奇偶的影响


总结快慢指针是链表算法中最优雅的技巧之一
它用简单的速度差异，解决了环检测、找中点、定位等多个经典问题
]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>链表系列之递归</title>
    <url>/2026/01/05/%E9%93%BE%E8%A1%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[递归的本质递归是一种将大问题分解为相同结构小问题的编程技巧
在链表中，递归特别适用，因为链表本身就是递归定义的：

链表 &#x3D; 头节点 + 剩余链表
剩余链表 &#x3D; 头节点 + 剩余链表
…直到空节点

递归解决链表问题的核心三要素：

递归终止条件：什么时候停止递归
递归逻辑：如何处理当前节点
返回值：向上一层返回什么


入门篇：反转链表LeetCode 206. 反转链表
问题描述给定一个链表，反转整个链表并返回新的头节点
递归思路假设链表为：1 → 2 → 3 → 4 → 5
递归的思考方式：

先递归反转 2 → 3 → 4 → 5，得到 5 → 4 → 3 → 2
然后处理节点1，让2的next指向1
将1的next设为NULL

代码实现struct ListNode* reverseList(struct ListNode* head) &#123;    if (head == NULL || head-&gt;next == NULL) &#123;        return head;    &#125;    struct ListNode* newHead = reverseList(head-&gt;next);    head-&gt;next-&gt;next = head;    head-&gt;next = NULL;    return newHead;&#125;

递归过程图解原链表：1 → 2 → 3 → NULL递归栈：第1层：reverseList(1) 第2层：  reverseList(2)第3层：    reverseList(3)第4层：      reverseList(NULL) → 返回3回溯过程：第3层：3已反转，处理2 → 3 → 2，2.next = NULL       返回3第2层：3 → 2已反转，处理1 → 2 → 1，1.next = NULL       返回3最终：3 → 2 → 1 → NULL

关键点
终止条件：head为空或head-&gt;next为空
核心操作：head-&gt;next-&gt;next = head（让下一个节点指向当前节点）
断开原连接：head-&gt;next = NULL（避免成环）
返回值：新的头节点（始终是原链表的尾节点）


进阶篇一：合并两个有序链表LeetCode 21. 合并两个有序链表
问题描述将两个升序链表合并为一个新的升序链表
递归思路每次选择两个链表中较小的头节点，然后递归处理剩余部分
代码实现struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) &#123;    if (!list1) return list2;    if (!list2) return list1;        if (list1-&gt;val &lt; list2-&gt;val) &#123;        list1-&gt;next = mergeTwoLists(list1-&gt;next, list2);        return list1;    &#125; else &#123;        list2-&gt;next = mergeTwoLists(list1, list2-&gt;next);        return list2;    &#125;&#125;

递归过程示例list1: 1 → 3 → 5list2: 2 → 4 → 6第1层：比较1和2，选1，递归merge(3→5, 2→4→6)第2层：比较3和2，选2，递归merge(3→5, 4→6)第3层：比较3和4，选3，递归merge(5, 4→6)第4层：比较5和4，选4，递归merge(5, 6)第5层：比较5和6，选5，递归merge(NULL, 6)第6层：返回6回溯构建：1 → 2 → 3 → 4 → 5 → 6

关键点
终止条件：任一链表为空，返回另一个链表
递归逻辑：选择较小的节点，将其next指向递归结果
时间复杂度：O(m+n)
空间复杂度：O(m+n)（递归栈深度）


进阶篇二：两两交换链表节点LeetCode 24. 两两交换链表中的节点
问题描述给定一个链表，两两交换其中相邻的节点
例如：1 → 2 → 3 → 4 变为 2 → 1 → 4 → 3
递归思路
递归处理后续节点（从第3个节点开始）
交换当前的两个节点
返回新的头节点

代码实现struct ListNode* swapPairs(struct ListNode* head) &#123;    if(!head || !head-&gt;next)        return head;        struct ListNode* cur = head;    struct ListNode* next = head-&gt;next;    struct ListNode* tmp = next-&gt;next;        next-&gt;next = cur;    cur-&gt;next = swapPairs(tmp);        return next;  // 新的头节点&#125;

递归过程图解原链表：1 → 2 → 3 → 4第1层：处理1和2       递归处理3 → 4第2层：处理3和4       递归处理NULL       返回4       回溯：第2层：交换3和4，返回 4 → 3第1层：交换1和2，连接返回结果       2 → 1 → (4 → 3)       返回2最终：2 → 1 → 4 → 3

关键点
终止条件：节点为空或只剩一个节点
保存三个关键指针：cur、next、tmp
返回值：交换后的新头节点（原来的第二个节点）


高级篇一：K个一组翻转链表LeetCode 25. K 个一组翻转链表
问题描述给定一个链表，每k个节点一组进行翻转
例如：1 → 2 → 3 → 4 → 5，k&#x3D;2结果：2 → 1 → 4 → 3 → 5
递归思路
检查是否有k个节点
如果有，翻转前k个节点
递归处理剩余部分
连接翻转后的部分和递归结果

代码实现struct ListNode* reverseKGroup(struct ListNode* head, int k) &#123;    // 检查是否有k个节点    struct ListNode *p = head;    for(int i = 0; i &lt; k; i++) &#123;        if(!p) return head;  // 不足k个，直接返回head        p = p-&gt;next;    &#125;        // 翻转前k个节点    struct ListNode *q = head;    struct ListNode *pre = NULL;        while(q != p) &#123;  // 翻转从head到p的前k个节点        struct ListNode *tmp = q-&gt;next;        q-&gt;next = pre;        pre = q;        q = tmp;    &#125;    head-&gt;next = reverseKGroup(p, k);    return pre;&#125;

递归过程示例原链表：1 → 2 → 3 → 4 → 5，k=2第1层：检查1,2存在       翻转1,2 得到 2 → 1       递归处理3 → 4 → 5       第2层：检查3,4存在       翻转3,4 得到 4 → 3       递归处理5       第3层：检查5后不足2个       直接返回5回溯连接：第2层：4 → 3 → 5，返回4第1层：2 → 1 → (4 → 3 → 5)，返回2最终：2 → 1 → 4 → 3 → 5

关键点
先检查是否有足够的节点
翻转逻辑与普通反转链表相同
递归处理剩余部分
head变成了翻转后这组的尾节点


高级篇二：排序链表（归并排序）LeetCode 148. 排序链表
问题描述对链表进行排序，要求时间复杂度O(n log n)
递归思路（分治法）归并排序的经典应用：

找到链表中点（快慢指针）
递归排序左半部分
递归排序右半部分
合并两个有序链表

代码实现// 找到链表中间节点struct ListNode* findMiddle(struct ListNode* head) &#123;    if (!head || !head-&gt;next) return head;        struct ListNode *slow = head;    struct ListNode *fast = head-&gt;next;        while (fast &amp;&amp; fast-&gt;next) &#123;        slow = slow-&gt;next;        fast = fast-&gt;next-&gt;next;    &#125;        return slow;&#125;// 合并两个有序链表struct ListNode* merge(struct ListNode* l1, struct ListNode* l2) &#123;    struct ListNode dummy;    struct ListNode* tail = &amp;dummy;    dummy.next = NULL;        while (l1 &amp;&amp; l2) &#123;        if (l1-&gt;val &lt;= l2-&gt;val) &#123;            tail-&gt;next = l1;            l1 = l1-&gt;next;        &#125; else &#123;            tail-&gt;next = l2;            l2 = l2-&gt;next;        &#125;        tail = tail-&gt;next;    &#125;        tail-&gt;next = l1 ? l1 : l2;    return dummy.next;&#125;// 递归归并排序主函数struct ListNode* sortList(struct ListNode* head) &#123;    // 递归终止条件：空链表或单节点    if (!head || !head-&gt;next) &#123;        return head;    &#125;        // 1. 找到中间节点并分割    struct ListNode* mid = findMiddle(head);    struct ListNode* right = mid-&gt;next;    mid-&gt;next = NULL;  // 切断链表        // 2. 递归排序左右两部分    struct ListNode* leftSorted = sortList(head);    struct ListNode* rightSorted = sortList(right);        // 3. 合并有序链表    return merge(leftSorted, rightSorted);&#125;

递归过程图解原链表：4 → 2 → 1 → 3分割阶段：层1：[4,2,1,3] → [4,2] 和 [1,3]层2：[4,2] → [4] 和 [2]     [1,3] → [1] 和 [3]合并阶段：层2：merge([4], [2]) → [2,4]     merge([1], [3]) → [1,3]层1：merge([2,4], [1,3]) → [1,2,3,4]最终：1 → 2 → 3 → 4

关键点
分治思想：分割、递归、合并
快慢指针找中点
切断链表很重要（mid-&gt;next &#x3D; NULL）
时间复杂度：O(n log n)
空间复杂度：O(log n)（递归栈）


高级篇三：复制带随机指针的链表LeetCode 138. 随机链表的复制
问题描述复制一个特殊的链表，每个节点除了next指针，还有一个random指针指向链表中的任意节点或null
递归思路使用哈希表缓存已复制的节点，递归复制next和random
代码实现struct HashTable &#123;    struct Node *key, *val;    UT_hash_handle hh;&#125; * cachedNode;struct Node* deepCopy(struct Node* head) &#123;    if (head == NULL) &#123;        return NULL;    &#125;        struct HashTable* tmp;    HASH_FIND_PTR(cachedNode, &amp;head, tmp);        if (tmp == NULL) &#123;        // 创建新节点        struct Node* headNew = malloc(sizeof(struct Node));        headNew-&gt;val = head-&gt;val;                // 加入哈希表        tmp = malloc(sizeof(struct HashTable));        tmp-&gt;key = head;        tmp-&gt;val = headNew;        HASH_ADD_PTR(cachedNode, key, tmp);                // 递归复制next和random        headNew-&gt;next = deepCopy(head-&gt;next);        headNew-&gt;random = deepCopy(head-&gt;random);    &#125;        return tmp-&gt;val;&#125;struct Node* copyRandomList(struct Node* head) &#123;    cachedNode = NULL;    return deepCopy(head);&#125;

关键点
使用哈希表避免重复复制同一个节点
先复制当前节点，再递归复制next和random
哈希表的key是原节点，value是新节点
递归可能会形成环，哈希表防止无限递归


递归核心总结递归三要素ReturnType recursive(Node* head) &#123;    // 1. 递归终止条件    if (终止条件) &#123;        return 终止值;    &#125;        // 2. 递归调用    ReturnType result = recursive(下一个节点);        // 3. 处理当前节点    处理当前节点与递归结果;        // 4. 返回结果    return 返回值;&#125;

常见递归模式模式一：自底向上先递归到底，回溯时处理例如：反转链表
模式二：自顶向下先处理当前节点，再递归例如：复制链表
模式三：分治合并分割问题，递归处理，合并结果例如：归并排序

总结递归是解决链表问题的强大工具
掌握递归的关键：

明确递归三要素：终止条件、递归逻辑、返回值
理解递归的本质：将大问题分解为小问题
学会画递归树，理解回溯过程
权衡递归与迭代的优劣

]]></content>
      <categories>
        <category>leetcode刷题笔记</category>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>递归</tag>
      </tags>
  </entry>
</search>
